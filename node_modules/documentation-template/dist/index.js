import { createContext, createElement, forwardRef, useContext, useEffect, useMemo, useRef, useState } from "react";
import { Link, Route, Routes, useLocation, useNavigate, useParams } from "react-router-dom";
var __create = Object.create, __defProp = Object.defineProperty, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __getOwnPropNames = Object.getOwnPropertyNames, __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty, __commonJSMin = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports), __export = (all$2) => {
	let target = {};
	for (var name$1 in all$2) __defProp(target, name$1, {
		get: all$2[name$1],
		enumerable: !0
	});
	return target;
}, __copyProps = (to, from$1, except, desc) => {
	if (from$1 && typeof from$1 == "object" || typeof from$1 == "function") for (var keys$1 = __getOwnPropNames(from$1), i$2 = 0, n = keys$1.length, key; i$2 < n; i$2++) key = keys$1[i$2], !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, {
		get: ((k) => from$1[k]).bind(null, key),
		enumerable: !(desc = __getOwnPropDesc(from$1, key)) || desc.enumerable
	});
	return to;
}, __toESM = (mod, isNodeMode, target) => (target = mod == null ? {} : __create(__getProtoOf(mod)), __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: !0
}) : target, mod)), __require = /* @__PURE__ */ ((x) => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(x, { get: (a, b) => (typeof require < "u" ? require : a)[b] }) : x)(function(x) {
	if (typeof require < "u") return require.apply(this, arguments);
	throw Error("Calling `require` for \"" + x + "\" in an environment that doesn't expose the `require` function.");
});
const defaultDocsConfig = {
	name: "Documentation",
	description: "Beautiful documentation template",
	logo: { text: "Docs" },
	navigation: [],
	search: {
		enabled: !0,
		placeholder: "Search documentation..."
	}
};
/**
* @license React
* react-jsx-runtime.production.js
*
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var require_react_jsx_runtime_production = /* @__PURE__ */ __commonJSMin(((exports) => {
	var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
	function jsxProd(type, config, maybeKey) {
		var key = null;
		if (maybeKey !== void 0 && (key = "" + maybeKey), config.key !== void 0 && (key = "" + config.key), "key" in config) for (var propName in maybeKey = {}, config) propName !== "key" && (maybeKey[propName] = config[propName]);
		else maybeKey = config;
		return config = maybeKey.ref, {
			$$typeof: REACT_ELEMENT_TYPE,
			type,
			key,
			ref: config === void 0 ? null : config,
			props: maybeKey
		};
	}
	exports.Fragment = REACT_FRAGMENT_TYPE, exports.jsx = jsxProd, exports.jsxs = jsxProd;
})), require_react_jsx_runtime_development = /* @__PURE__ */ __commonJSMin(((exports) => {
	process.env.NODE_ENV !== "production" && (function() {
		function getComponentNameFromType(type) {
			if (type == null) return null;
			if (typeof type == "function") return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
			if (typeof type == "string") return type;
			switch (type) {
				case REACT_FRAGMENT_TYPE$1: return "Fragment";
				case REACT_PROFILER_TYPE: return "Profiler";
				case REACT_STRICT_MODE_TYPE: return "StrictMode";
				case REACT_SUSPENSE_TYPE: return "Suspense";
				case REACT_SUSPENSE_LIST_TYPE: return "SuspenseList";
				case REACT_ACTIVITY_TYPE: return "Activity";
			}
			if (typeof type == "object") switch (typeof type.tag == "number" && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
				case REACT_PORTAL_TYPE: return "Portal";
				case REACT_CONTEXT_TYPE: return type.displayName || "Context";
				case REACT_CONSUMER_TYPE: return (type._context.displayName || "Context") + ".Consumer";
				case REACT_FORWARD_REF_TYPE:
					var innerType = type.render;
					return type = type.displayName, type ||= (type = innerType.displayName || innerType.name || "", type === "" ? "ForwardRef" : "ForwardRef(" + type + ")"), type;
				case REACT_MEMO_TYPE: return innerType = type.displayName || null, innerType === null ? getComponentNameFromType(type.type) || "Memo" : innerType;
				case REACT_LAZY_TYPE:
					innerType = type._payload, type = type._init;
					try {
						return getComponentNameFromType(type(innerType));
					} catch {}
			}
			return null;
		}
		function testStringCoercion(value) {
			return "" + value;
		}
		function checkKeyStringCoercion(value) {
			try {
				testStringCoercion(value);
				var JSCompiler_inline_result = !1;
			} catch {
				JSCompiler_inline_result = !0;
			}
			if (JSCompiler_inline_result) {
				JSCompiler_inline_result = console;
				var JSCompiler_temp_const = JSCompiler_inline_result.error, JSCompiler_inline_result$jscomp$0 = typeof Symbol == "function" && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
				return JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0), testStringCoercion(value);
			}
		}
		function getTaskName(type) {
			if (type === REACT_FRAGMENT_TYPE$1) return "<>";
			if (typeof type == "object" && type && type.$$typeof === REACT_LAZY_TYPE) return "<...>";
			try {
				var name$1 = getComponentNameFromType(type);
				return name$1 ? "<" + name$1 + ">" : "<...>";
			} catch {
				return "<...>";
			}
		}
		function getOwner() {
			var dispatcher = ReactSharedInternals.A;
			return dispatcher === null ? null : dispatcher.getOwner();
		}
		function UnknownOwner() {
			return Error("react-stack-top-frame");
		}
		function hasValidKey(config) {
			if (hasOwnProperty$1.call(config, "key")) {
				var getter = Object.getOwnPropertyDescriptor(config, "key").get;
				if (getter && getter.isReactWarning) return !1;
			}
			return config.key !== void 0;
		}
		function defineKeyPropWarningGetter(props, displayName) {
			function warnAboutAccessingKey() {
				specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
			}
			warnAboutAccessingKey.isReactWarning = !0, Object.defineProperty(props, "key", {
				get: warnAboutAccessingKey,
				configurable: !0
			});
		}
		function elementRefGetterWithDeprecationWarning() {
			var componentName = getComponentNameFromType(this.type);
			return didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.")), componentName = this.props.ref, componentName === void 0 ? null : componentName;
		}
		function ReactElement(type, key, props, owner, debugStack, debugTask) {
			var refProp = props.ref;
			return type = {
				$$typeof: REACT_ELEMENT_TYPE$1,
				type,
				key,
				props,
				_owner: owner
			}, (refProp === void 0 ? null : refProp) === null ? Object.defineProperty(type, "ref", {
				enumerable: !1,
				value: null
			}) : Object.defineProperty(type, "ref", {
				enumerable: !1,
				get: elementRefGetterWithDeprecationWarning
			}), type._store = {}, Object.defineProperty(type._store, "validated", {
				configurable: !1,
				enumerable: !1,
				writable: !0,
				value: 0
			}), Object.defineProperty(type, "_debugInfo", {
				configurable: !1,
				enumerable: !1,
				writable: !0,
				value: null
			}), Object.defineProperty(type, "_debugStack", {
				configurable: !1,
				enumerable: !1,
				writable: !0,
				value: debugStack
			}), Object.defineProperty(type, "_debugTask", {
				configurable: !1,
				enumerable: !1,
				writable: !0,
				value: debugTask
			}), Object.freeze && (Object.freeze(type.props), Object.freeze(type)), type;
		}
		function jsxDEVImpl(type, config, maybeKey, isStaticChildren, debugStack, debugTask) {
			var children = config.children;
			if (children !== void 0) if (isStaticChildren) if (isArrayImpl(children)) {
				for (isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++) validateChildKeys(children[isStaticChildren]);
				Object.freeze && Object.freeze(children);
			} else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
			else validateChildKeys(children);
			if (hasOwnProperty$1.call(config, "key")) {
				children = getComponentNameFromType(type);
				var keys$1 = Object.keys(config).filter(function(k) {
					return k !== "key";
				});
				isStaticChildren = 0 < keys$1.length ? "{key: someKey, " + keys$1.join(": ..., ") + ": ...}" : "{key: someKey}", didWarnAboutKeySpread[children + isStaticChildren] || (keys$1 = 0 < keys$1.length ? "{" + keys$1.join(": ..., ") + ": ...}" : "{}", console.error("A props object containing a \"key\" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />", isStaticChildren, children, keys$1, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
			}
			if (children = null, maybeKey !== void 0 && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey), hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key), "key" in config) for (var propName in maybeKey = {}, config) propName !== "key" && (maybeKey[propName] = config[propName]);
			else maybeKey = config;
			return children && defineKeyPropWarningGetter(maybeKey, typeof type == "function" ? type.displayName || type.name || "Unknown" : type), ReactElement(type, children, maybeKey, getOwner(), debugStack, debugTask);
		}
		function validateChildKeys(node$1) {
			isValidElement(node$1) ? node$1._store && (node$1._store.validated = 1) : typeof node$1 == "object" && node$1 && node$1.$$typeof === REACT_LAZY_TYPE && (node$1._payload.status === "fulfilled" ? isValidElement(node$1._payload.value) && node$1._payload.value._store && (node$1._payload.value._store.validated = 1) : node$1._store && (node$1._store.validated = 1));
		}
		function isValidElement(object) {
			return typeof object == "object" && !!object && object.$$typeof === REACT_ELEMENT_TYPE$1;
		}
		var React = __require("react"), REACT_ELEMENT_TYPE$1 = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE$1 = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty$1 = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
			return null;
		};
		React = { react_stack_bottom_frame: function(callStackForError) {
			return callStackForError();
		} };
		var specialPropKeyWarningShown, didWarnAboutElementRef = {}, unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(React, UnknownOwner)(), unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner)), didWarnAboutKeySpread = {};
		exports.Fragment = REACT_FRAGMENT_TYPE$1, exports.jsx = function(type, config, maybeKey) {
			var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
			return jsxDEVImpl(type, config, maybeKey, !1, trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
		}, exports.jsxs = function(type, config, maybeKey) {
			var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
			return jsxDEVImpl(type, config, maybeKey, !0, trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
		};
	})();
})), require_jsx_runtime = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	process.env.NODE_ENV === "production" ? module.exports = require_react_jsx_runtime_production() : module.exports = require_react_jsx_runtime_development();
})), import_jsx_runtime = require_jsx_runtime(), DocsContext = createContext(void 0);
function DocsProvider({ children, config: initialConfig = defaultDocsConfig }) {
	let [config, setConfig] = useState(initialConfig), [theme, setTheme] = useState(() => {
		if (typeof window < "u") {
			let stored = localStorage.getItem("docs-theme");
			return stored === "dark" || stored === "light" ? stored : window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
		}
		return "light";
	}), [sidebarOpen, setSidebarOpen] = useState(!1), [searchOpen, setSearchOpen] = useState(!1);
	return useEffect(() => {
		let root$3 = document.documentElement;
		root$3.classList.remove("light", "dark"), root$3.classList.add(theme), localStorage.setItem("docs-theme", theme);
	}, [theme]), useEffect(() => {
		let handleKeyDown = (e) => {
			(e.metaKey || e.ctrlKey) && e.key === "k" && (e.preventDefault(), setSearchOpen((prev) => !prev)), e.key === "Escape" && (setSearchOpen(!1), setSidebarOpen(!1));
		};
		return window.addEventListener("keydown", handleKeyDown), () => window.removeEventListener("keydown", handleKeyDown);
	}, []), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DocsContext.Provider, {
		value: {
			config,
			setConfig,
			theme,
			setTheme,
			sidebarOpen,
			setSidebarOpen,
			searchOpen,
			setSearchOpen
		},
		children
	});
}
function useDocs() {
	let context = useContext(DocsContext);
	if (!context) throw Error("useDocs must be used within a DocsProvider");
	return context;
}
function r$1(e) {
	var t, f, n = "";
	if (typeof e == "string" || typeof e == "number") n += e;
	else if (typeof e == "object") if (Array.isArray(e)) {
		var o = e.length;
		for (t = 0; t < o; t++) e[t] && (f = r$1(e[t])) && (n && (n += " "), n += f);
	} else for (f in e) e[f] && (n && (n += " "), n += f);
	return n;
}
function clsx() {
	for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r$1(e)) && (n && (n += " "), n += t);
	return n;
}
function cn(...inputs) {
	return clsx(inputs);
}
/**
* @license lucide-react v0.562.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
var toKebabCase = (string$2) => string$2.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), toCamelCase = (string$2) => string$2.replace(/^([A-Z])|[\s-_]+(\w)/g, (match, p1, p2) => p2 ? p2.toUpperCase() : p1.toLowerCase()), toPascalCase = (string$2) => {
	let camelCase$1 = toCamelCase(string$2);
	return camelCase$1.charAt(0).toUpperCase() + camelCase$1.slice(1);
}, mergeClasses = (...classes) => classes.filter((className, index$2, array) => !!className && className.trim() !== "" && array.indexOf(className) === index$2).join(" ").trim(), hasA11yProp = (props) => {
	for (let prop in props) if (prop.startsWith("aria-") || prop === "role" || prop === "title") return !0;
}, defaultAttributes = {
	xmlns: "http://www.w3.org/2000/svg",
	width: 24,
	height: 24,
	viewBox: "0 0 24 24",
	fill: "none",
	stroke: "currentColor",
	strokeWidth: 2,
	strokeLinecap: "round",
	strokeLinejoin: "round"
}, Icon$1 = forwardRef(({ color: color$1 = "currentColor", size = 24, strokeWidth = 2, absoluteStrokeWidth, className = "", children, iconNode, ...rest }, ref) => createElement("svg", {
	ref,
	...defaultAttributes,
	width: size,
	height: size,
	stroke: color$1,
	strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,
	className: mergeClasses("lucide", className),
	...!children && !hasA11yProp(rest) && { "aria-hidden": "true" },
	...rest
}, [...iconNode.map(([tag, attrs]) => createElement(tag, attrs)), ...Array.isArray(children) ? children : [children]])), createLucideIcon = (iconName, iconNode) => {
	let Component = forwardRef(({ className, ...props }, ref) => createElement(Icon$1, {
		ref,
		iconNode,
		className: mergeClasses(`lucide-${toKebabCase(toPascalCase(iconName))}`, `lucide-${iconName}`, className),
		...props
	}));
	return Component.displayName = toPascalCase(iconName), Component;
}, __iconNode$34 = [["path", {
	d: "M5 12h14",
	key: "1ays0h"
}], ["path", {
	d: "m12 5 7 7-7 7",
	key: "xquz4c"
}]], ArrowRight = createLucideIcon("arrow-right", __iconNode$34), __iconNode$33 = [
	["path", {
		d: "M10 12h4",
		key: "a56b0p"
	}],
	["path", {
		d: "M10 8h4",
		key: "1sr2af"
	}],
	["path", {
		d: "M14 21v-3a2 2 0 0 0-4 0v3",
		key: "1rgiei"
	}],
	["path", {
		d: "M6 10H4a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-2",
		key: "secmi2"
	}],
	["path", {
		d: "M6 21V5a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v16",
		key: "16ra0t"
	}]
], Building2 = createLucideIcon("building-2", __iconNode$33), __iconNode$32 = [["path", {
	d: "M20 6 9 17l-5-5",
	key: "1gmf2c"
}]], Check = createLucideIcon("check", __iconNode$32), __iconNode$31 = [["path", {
	d: "m6 9 6 6 6-6",
	key: "qrunsl"
}]], ChevronDown = createLucideIcon("chevron-down", __iconNode$31), __iconNode$30 = [["path", {
	d: "m15 18-6-6 6-6",
	key: "1wnfg3"
}]], ChevronLeft = createLucideIcon("chevron-left", __iconNode$30), __iconNode$29 = [["path", {
	d: "m9 18 6-6-6-6",
	key: "mthhwq"
}]], ChevronRight = createLucideIcon("chevron-right", __iconNode$29), __iconNode$28 = [
	["circle", {
		cx: "12",
		cy: "12",
		r: "10",
		key: "1mglay"
	}],
	["line", {
		x1: "12",
		x2: "12",
		y1: "8",
		y2: "12",
		key: "1pkeuh"
	}],
	["line", {
		x1: "12",
		x2: "12.01",
		y1: "16",
		y2: "16",
		key: "4dfq90"
	}]
], CircleAlert = createLucideIcon("circle-alert", __iconNode$28), __iconNode$27 = [["path", {
	d: "M21.801 10A10 10 0 1 1 17 3.335",
	key: "yps3ct"
}], ["path", {
	d: "m9 11 3 3L22 4",
	key: "1pflzl"
}]], CircleCheckBig = createLucideIcon("circle-check-big", __iconNode$27), __iconNode$26 = [
	["path", {
		d: "m18 16 4-4-4-4",
		key: "1inbqp"
	}],
	["path", {
		d: "m6 8-4 4 4 4",
		key: "15zrgr"
	}],
	["path", {
		d: "m14.5 4-5 16",
		key: "e7oirm"
	}]
], CodeXml = createLucideIcon("code-xml", __iconNode$26), __iconNode$25 = [["rect", {
	width: "14",
	height: "14",
	x: "8",
	y: "8",
	rx: "2",
	ry: "2",
	key: "17jyea"
}], ["path", {
	d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2",
	key: "zix9uf"
}]], Copy = createLucideIcon("copy", __iconNode$25), __iconNode$24 = [
	["path", {
		d: "M6 22a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h8a2.4 2.4 0 0 1 1.704.706l3.588 3.588A2.4 2.4 0 0 1 20 8v12a2 2 0 0 1-2 2z",
		key: "1oefj6"
	}],
	["path", {
		d: "M14 2v5a1 1 0 0 0 1 1h5",
		key: "wfsgrz"
	}],
	["path", {
		d: "M10 9H8",
		key: "b1mrlr"
	}],
	["path", {
		d: "M16 13H8",
		key: "t4e002"
	}],
	["path", {
		d: "M16 17H8",
		key: "z1uh3a"
	}]
], FileText = createLucideIcon("file-text", __iconNode$24), __iconNode$23 = [["path", {
	d: "M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4",
	key: "tonef"
}], ["path", {
	d: "M9 18c-4.51 2-5-2-7-2",
	key: "9comsn"
}]], Github = createLucideIcon("github", __iconNode$23), __iconNode$22 = [
	["circle", {
		cx: "12",
		cy: "12",
		r: "10",
		key: "1mglay"
	}],
	["path", {
		d: "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20",
		key: "13o1zl"
	}],
	["path", {
		d: "M2 12h20",
		key: "9i4pu4"
	}]
], Globe = createLucideIcon("globe", __iconNode$22), __iconNode$21 = [
	["line", {
		x1: "4",
		x2: "20",
		y1: "9",
		y2: "9",
		key: "4lhtct"
	}],
	["line", {
		x1: "4",
		x2: "20",
		y1: "15",
		y2: "15",
		key: "vyu0kd"
	}],
	["line", {
		x1: "10",
		x2: "8",
		y1: "3",
		y2: "21",
		key: "1ggp8o"
	}],
	["line", {
		x1: "16",
		x2: "14",
		y1: "3",
		y2: "21",
		key: "weycgp"
	}]
], Hash = createLucideIcon("hash", __iconNode$21), __iconNode$20 = [
	["circle", {
		cx: "12",
		cy: "12",
		r: "10",
		key: "1mglay"
	}],
	["path", {
		d: "M12 16v-4",
		key: "1dtifu"
	}],
	["path", {
		d: "M12 8h.01",
		key: "e9boi3"
	}]
], Info = createLucideIcon("info", __iconNode$20), __iconNode$19 = [
	["path", {
		d: "m15.5 7.5 2.3 2.3a1 1 0 0 0 1.4 0l2.1-2.1a1 1 0 0 0 0-1.4L19 4",
		key: "g0fldk"
	}],
	["path", {
		d: "m21 2-9.6 9.6",
		key: "1j0ho8"
	}],
	["circle", {
		cx: "7.5",
		cy: "15.5",
		r: "5.5",
		key: "yqb3hr"
	}]
], Key = createLucideIcon("key", __iconNode$19), __iconNode$18 = [
	["path", {
		d: "M12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83z",
		key: "zw3jo"
	}],
	["path", {
		d: "M2 12a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 12",
		key: "1wduqc"
	}],
	["path", {
		d: "M2 17a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 17",
		key: "kqbvx6"
	}]
], Layers = createLucideIcon("layers", __iconNode$18), __iconNode$17 = [
	["path", {
		d: "M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5",
		key: "1gvzjb"
	}],
	["path", {
		d: "M9 18h6",
		key: "x1upvd"
	}],
	["path", {
		d: "M10 22h4",
		key: "ceow96"
	}]
], Lightbulb = createLucideIcon("lightbulb", __iconNode$17), __iconNode$16 = [
	["path", {
		d: "M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z",
		key: "c2jq9f"
	}],
	["rect", {
		width: "4",
		height: "12",
		x: "2",
		y: "9",
		key: "mk3on5"
	}],
	["circle", {
		cx: "4",
		cy: "4",
		r: "2",
		key: "bt5ra8"
	}]
], Linkedin = createLucideIcon("linkedin", __iconNode$16), __iconNode$15 = [["rect", {
	width: "18",
	height: "11",
	x: "3",
	y: "11",
	rx: "2",
	ry: "2",
	key: "1w4ew1"
}], ["path", {
	d: "M7 11V7a5 5 0 0 1 10 0v4",
	key: "fwvmzm"
}]], Lock = createLucideIcon("lock", __iconNode$15), __iconNode$14 = [
	["path", {
		d: "M4 5h16",
		key: "1tepv9"
	}],
	["path", {
		d: "M4 12h16",
		key: "1lakjw"
	}],
	["path", {
		d: "M4 19h16",
		key: "1djgab"
	}]
], Menu = createLucideIcon("menu", __iconNode$14), __iconNode$13 = [["path", {
	d: "M20.985 12.486a9 9 0 1 1-9.473-9.472c.405-.022.617.46.402.803a6 6 0 0 0 8.268 8.268c.344-.215.825-.004.803.401",
	key: "kfwtm"
}]], Moon = createLucideIcon("moon", __iconNode$13), __iconNode$12 = [["path", {
	d: "M16 3a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2 1 1 0 0 1 1 1v1a2 2 0 0 1-2 2 1 1 0 0 0-1 1v2a1 1 0 0 0 1 1 6 6 0 0 0 6-6V5a2 2 0 0 0-2-2z",
	key: "rib7q0"
}], ["path", {
	d: "M5 3a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2 1 1 0 0 1 1 1v1a2 2 0 0 1-2 2 1 1 0 0 0-1 1v2a1 1 0 0 0 1 1 6 6 0 0 0 6-6V5a2 2 0 0 0-2-2z",
	key: "1ymkrd"
}]], Quote = createLucideIcon("quote", __iconNode$12), __iconNode$11 = [["path", {
	d: "m21 21-4.34-4.34",
	key: "14j7rj"
}], ["circle", {
	cx: "11",
	cy: "11",
	r: "8",
	key: "4ej97u"
}]], Search = createLucideIcon("search", __iconNode$11), __iconNode$10 = [["path", {
	d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
	key: "oel41y"
}]], Shield = createLucideIcon("shield", __iconNode$10), __iconNode$9 = [
	["path", {
		d: "M11.017 2.814a1 1 0 0 1 1.966 0l1.051 5.558a2 2 0 0 0 1.594 1.594l5.558 1.051a1 1 0 0 1 0 1.966l-5.558 1.051a2 2 0 0 0-1.594 1.594l-1.051 5.558a1 1 0 0 1-1.966 0l-1.051-5.558a2 2 0 0 0-1.594-1.594l-5.558-1.051a1 1 0 0 1 0-1.966l5.558-1.051a2 2 0 0 0 1.594-1.594z",
		key: "1s2grr"
	}],
	["path", {
		d: "M20 2v4",
		key: "1rf3ol"
	}],
	["path", {
		d: "M22 4h-4",
		key: "gwowj6"
	}],
	["circle", {
		cx: "4",
		cy: "20",
		r: "2",
		key: "6kqj1y"
	}]
], Sparkles = createLucideIcon("sparkles", __iconNode$9), __iconNode$8 = [["path", {
	d: "M11.525 2.295a.53.53 0 0 1 .95 0l2.31 4.679a2.123 2.123 0 0 0 1.595 1.16l5.166.756a.53.53 0 0 1 .294.904l-3.736 3.638a2.123 2.123 0 0 0-.611 1.878l.882 5.14a.53.53 0 0 1-.771.56l-4.618-2.428a2.122 2.122 0 0 0-1.973 0L6.396 21.01a.53.53 0 0 1-.77-.56l.881-5.139a2.122 2.122 0 0 0-.611-1.879L2.16 9.795a.53.53 0 0 1 .294-.906l5.165-.755a2.122 2.122 0 0 0 1.597-1.16z",
	key: "r04s7s"
}]], Star = createLucideIcon("star", __iconNode$8), __iconNode$7 = [
	["circle", {
		cx: "12",
		cy: "12",
		r: "4",
		key: "4exip2"
	}],
	["path", {
		d: "M12 2v2",
		key: "tus03m"
	}],
	["path", {
		d: "M12 20v2",
		key: "1lh1kg"
	}],
	["path", {
		d: "m4.93 4.93 1.41 1.41",
		key: "149t6j"
	}],
	["path", {
		d: "m17.66 17.66 1.41 1.41",
		key: "ptbguv"
	}],
	["path", {
		d: "M2 12h2",
		key: "1t8f8n"
	}],
	["path", {
		d: "M20 12h2",
		key: "1q8mjw"
	}],
	["path", {
		d: "m6.34 17.66-1.41 1.41",
		key: "1m8zz5"
	}],
	["path", {
		d: "m19.07 4.93-1.41 1.41",
		key: "1shlcs"
	}]
], Sun = createLucideIcon("sun", __iconNode$7), __iconNode$6 = [["path", {
	d: "M12 19h8",
	key: "baeox8"
}], ["path", {
	d: "m4 17 6-6-6-6",
	key: "1yngyt"
}]], Terminal = createLucideIcon("terminal", __iconNode$6), __iconNode$5 = [
	["path", {
		d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",
		key: "wmoenq"
	}],
	["path", {
		d: "M12 9v4",
		key: "juzpu7"
	}],
	["path", {
		d: "M12 17h.01",
		key: "p32p05"
	}]
], TriangleAlert = createLucideIcon("triangle-alert", __iconNode$5), __iconNode$4 = [["path", {
	d: "M22 4s-.7 2.1-2 3.4c1.6 10-9.4 17.3-18 11.6 2.2.1 4.4-.6 6-2C3 15.5.5 9.6 3 5c2.2 2.6 5.6 4.1 9 4-.9-4.2 4-6.6 7-3.8 1.1 0 3-1.2 3-1.2z",
	key: "pff0z6"
}]], Twitter = createLucideIcon("twitter", __iconNode$4), __iconNode$3 = [
	["path", {
		d: "m16 11 2 2 4-4",
		key: "9rsbq5"
	}],
	["path", {
		d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2",
		key: "1yyitq"
	}],
	["circle", {
		cx: "9",
		cy: "7",
		r: "4",
		key: "nufk8"
	}]
], UserCheck = createLucideIcon("user-check", __iconNode$3), __iconNode$2 = [
	["path", {
		d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2",
		key: "1yyitq"
	}],
	["path", {
		d: "M16 3.128a4 4 0 0 1 0 7.744",
		key: "16gr8j"
	}],
	["path", {
		d: "M22 21v-2a4 4 0 0 0-3-3.87",
		key: "kshegd"
	}],
	["circle", {
		cx: "9",
		cy: "7",
		r: "4",
		key: "nufk8"
	}]
], Users = createLucideIcon("users", __iconNode$2), __iconNode$1 = [["path", {
	d: "M18 6 6 18",
	key: "1bl5f8"
}], ["path", {
	d: "m6 6 12 12",
	key: "d8bk6v"
}]], X = createLucideIcon("x", __iconNode$1), __iconNode = [["path", {
	d: "M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",
	key: "1xq2db"
}]], Zap = createLucideIcon("zap", __iconNode), buttonVariants = {
	default: "bg-primary text-primary-foreground hover:bg-primary/90",
	secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
	ghost: "hover:bg-accent hover:text-accent-foreground",
	outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
	link: "text-primary underline-offset-4 hover:underline"
}, buttonSizes = {
	sm: "h-8 px-3 text-xs",
	md: "h-9 px-4 text-sm",
	lg: "h-10 px-6 text-base",
	icon: "h-9 w-9"
};
const Button = forwardRef(({ className, variant = "default", size = "md", ...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("button", {
	ref,
	className: cn("inline-flex items-center justify-center rounded-md font-medium transition-colors", "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2", "disabled:pointer-events-none disabled:opacity-50", buttonVariants[variant], buttonSizes[size], className),
	...props
}));
Button.displayName = "Button";
var iconSizes = {
	xs: 12,
	sm: 14,
	md: 16,
	lg: 20,
	xl: 24
};
function Icon({ icon: LucideIcon, size = "md", className }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(LucideIcon, {
		size: iconSizes[size],
		className: cn("shrink-0", className)
	});
}
function Header({ className }) {
	let { config, theme, setTheme, sidebarOpen, setSidebarOpen, setSearchOpen } = useDocs();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("header", {
		className: cn("sticky top-0 z-50 w-full border-b border-border bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60", className),
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
			className: "flex h-14 items-center px-4 lg:px-6",
			children: [
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Button, {
					variant: "ghost",
					size: "icon",
					className: "lg:hidden mr-2",
					onClick: () => setSidebarOpen(!sidebarOpen),
					"aria-label": "Toggle sidebar",
					children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Icon, { icon: sidebarOpen ? X : Menu })
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: "flex items-center gap-2",
					children: config.logo?.text && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("a", {
						href: "/",
						className: "flex items-center gap-2 font-semibold text-lg",
						children: config.logo.text
					})
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { className: "flex-1" }),
				/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
					className: "flex items-center gap-1",
					children: [
						config.search?.enabled && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Button, {
							variant: "outline",
							className: "hidden sm:flex items-center gap-2 text-muted-foreground w-64 justify-start",
							onClick: () => setSearchOpen(!0),
							children: [
								/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Icon, {
									icon: Search,
									size: "sm"
								}),
								/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
									className: "flex-1 text-left",
									children: config.search.placeholder || "Search..."
								}),
								/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("kbd", {
									className: "pointer-events-none hidden h-5 select-none items-center gap-1 rounded border border-border bg-muted px-1.5 font-mono text-xs font-medium sm:flex",
									children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
										className: "text-xs",
										children: "âŒ˜"
									}), "K"]
								})
							]
						}),
						/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Button, {
							variant: "ghost",
							size: "icon",
							className: "sm:hidden",
							onClick: () => setSearchOpen(!0),
							"aria-label": "Search",
							children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Icon, { icon: Search })
						}),
						config.github && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("a", {
							href: config.github,
							target: "_blank",
							rel: "noopener noreferrer",
							"aria-label": "GitHub",
							className: "inline-flex items-center justify-center h-9 w-9 rounded-md hover:bg-accent hover:text-accent-foreground transition-colors",
							children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Icon, { icon: Github })
						}),
						/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Button, {
							variant: "ghost",
							size: "icon",
							onClick: () => setTheme(theme === "dark" ? "light" : "dark"),
							"aria-label": "Toggle theme",
							children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Icon, { icon: theme === "dark" ? Sun : Moon })
						})
					]
				})
			]
		})
	});
}
var badgeVariants = {
	default: "bg-primary text-primary-foreground",
	secondary: "bg-secondary text-secondary-foreground",
	outline: "border border-border text-foreground",
	success: "bg-green-500/10 text-green-600 dark:text-green-400",
	warning: "bg-yellow-500/10 text-yellow-600 dark:text-yellow-400",
	destructive: "bg-destructive/10 text-destructive"
};
function Badge({ className, variant = "default", ...props }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
		className: cn("inline-flex items-center rounded-full px-2 py-0.5 text-xs font-medium", badgeVariants[variant], className),
		...props
	});
}
function NavItemComponent({ item, depth = 0, docs: docs$1 }) {
	let location = useLocation(), [status, setStatus] = useState("idle"), hoverRef = useRef(!1), [isOpen, setIsOpen] = useState(() => item.children ? item.children.some((child) => child.href === location.pathname || child.children?.some((c$1) => c$1.href === location.pathname)) : !1), hasChildren = item.children && item.children.length > 0, isActive = item.href === location.pathname, handleMouseEnter = () => {
		hoverRef.current = !0;
	}, handleMouseLeave = () => {
		hoverRef.current = !1, status === "cooldown" && setTimeout(() => setStatus("idle"), 300);
	}, handleCopy = async (e) => {
		if (e.preventDefault(), e.stopPropagation(), !docs$1) return;
		let collectContent = (navItem) => {
			let content$3 = "";
			if (navItem.href) {
				let doc = docs$1.find((d) => d.slug === navItem.href);
				doc && (content$3 += `# ${doc.meta.title || navItem.title}\n\n`, content$3 += doc.content);
			}
			if (navItem.children) for (let child of navItem.children) content$3 += "\n\n" + collectContent(child);
			return content$3;
		}, content$2 = collectContent(item);
		await navigator.clipboard.writeText(content$2.trim()), setStatus("copied"), setTimeout(() => {
			setStatus("cooldown"), hoverRef.current || setTimeout(() => setStatus("idle"), 300);
		}, 2e3);
	};
	return hasChildren ? /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		role: "button",
		onClick: () => setIsOpen(!isOpen),
		onMouseEnter: handleMouseEnter,
		onMouseLeave: handleMouseLeave,
		className: cn("flex w-full items-center justify-between rounded-md px-3 py-2 text-sm transition-colors cursor-pointer", "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground", depth > 0 && "pl-6"),
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
			className: "font-medium",
			children: item.title
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
			className: "flex items-center gap-1",
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("button", {
				onClick: handleCopy,
				className: cn("transition-opacity duration-300 p-1 rounded hover:bg-sidebar-accent/50", status === "idle" ? "pointer-events-none opacity-0 hover:opacity-100 group-hover:pointer-events-auto" : "", status === "copied" ? "opacity-100" : "", status === "cooldown" ? "opacity-0 pointer-events-none" : ""),
				title: "Copy section content",
				children: status === "idle" ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Copy, { className: "h-3 w-3" }) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Check, { className: "h-3 w-3 text-green-500" })
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ChevronRight, { className: cn("h-4 w-4 shrink-0 transition-transform duration-200", isOpen && "rotate-90") })]
		})]
	}), isOpen && item.children && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		className: "mt-1 space-y-1",
		children: item.children.map((child, i$2) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(NavItemComponent, {
			item: child,
			depth: depth + 1,
			docs: docs$1
		}, i$2))
	})] }) : /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Link, {
		to: item.href || "#",
		onMouseEnter: handleMouseEnter,
		onMouseLeave: handleMouseLeave,
		className: cn("flex items-center gap-2 rounded-md px-3 py-2 text-sm transition-colors group", "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground", isActive ? "bg-sidebar-accent text-sidebar-accent-foreground font-medium" : "text-sidebar-foreground/70", depth > 0 && "pl-6", depth > 1 && "pl-9"),
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { children: item.title }),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
				role: "button",
				onClick: handleCopy,
				className: cn("transition-opacity duration-300 ml-auto p-1 rounded hover:bg-sidebar-accent/50 cursor-pointer", status === "idle" ? "pointer-events-none opacity-0 group-hover:opacity-100 group-hover:pointer-events-auto" : "", status === "copied" ? "opacity-100" : "", status === "cooldown" ? "opacity-0 pointer-events-none" : ""),
				title: "Copy page content",
				children: status === "idle" ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Copy, { className: "h-3 w-3" }) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Check, { className: "h-3 w-3 text-green-500" })
			}),
			item.badge && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Badge, {
				variant: "secondary",
				className: "ml-auto",
				children: item.badge
			})
		]
	});
}
function Sidebar({ className, docs: docs$1 }) {
	let { config, sidebarOpen, setSidebarOpen } = useDocs(), SectionHeader = ({ title, items }) => {
		let [status, setStatus] = useState("idle"), hoverRef = useRef(!1);
		return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
			className: "flex items-center justify-between mb-2 px-3",
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("h4", {
				className: "text-xs font-semibold uppercase tracking-wider text-muted-foreground",
				children: title
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("button", {
				onClick: async (e) => {
					if (e.preventDefault(), e.stopPropagation(), !docs$1) return;
					let collectContent = (navItems) => {
						let content$3 = "";
						for (let navItem of navItems) {
							if (navItem.href) {
								let doc = docs$1.find((d) => d.slug === navItem.href);
								doc && (content$3 += `# ${doc.meta.title || navItem.title}\n\n`, content$3 += doc.content);
							}
							navItem.children && (content$3 += "\n\n" + collectContent(navItem.children));
						}
						return content$3;
					}, content$2 = collectContent(items);
					await navigator.clipboard.writeText(content$2.trim()), setStatus("copied"), setTimeout(() => {
						setStatus("cooldown"), hoverRef.current || setTimeout(() => setStatus("idle"), 300);
					}, 2e3);
				},
				onMouseEnter: () => {
					hoverRef.current = !0;
				},
				onMouseLeave: () => {
					hoverRef.current = !1, status === "cooldown" && setTimeout(() => setStatus("idle"), 300);
				},
				className: cn("transition-opacity duration-300 p-1 rounded hover:bg-sidebar-accent/50", status === "idle" ? "pointer-events-none opacity-0 hover:opacity-100 hover:pointer-events-auto" : "", status === "copied" ? "opacity-100" : "", status === "cooldown" ? "opacity-0 pointer-events-none" : ""),
				title: "Copy section content",
				children: status === "idle" ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Copy, { className: "h-3 w-3" }) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Check, { className: "h-3 w-3 text-green-500" })
			})]
		});
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [sidebarOpen && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		className: "fixed inset-0 z-40 bg-background/80 backdrop-blur-sm lg:hidden",
		onClick: () => setSidebarOpen(!1)
	}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("aside", {
		className: cn("fixed top-14 z-40 h-[calc(100vh-3.5rem)] w-72 border-r border-sidebar-border bg-sidebar", "transition-transform duration-300 ease-in-out lg:translate-x-0", sidebarOpen ? "translate-x-0" : "-translate-x-full", "lg:sticky lg:block", className),
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("nav", {
			className: "h-full overflow-y-auto scrollbar-thin p-4",
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "space-y-6",
				children: config.navigation.map((section, i$2) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { children: section.children ? /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(SectionHeader, {
					title: section.title,
					items: section.children
				}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: "space-y-1",
					children: section.children.map((item, j) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(NavItemComponent, {
						item,
						docs: docs$1
					}, j))
				})] }) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(NavItemComponent, {
					item: section,
					docs: docs$1
				}) }, i$2))
			})
		})
	})] });
}
function DocsLayout({ children, className, showSidebar = !0, showToc = !0, tocContent, docs: docs$1 }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: "min-h-screen bg-background",
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Header, {}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
			className: "flex",
			children: [showSidebar && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Sidebar, { docs: docs$1 }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("main", {
				className: cn("flex-1 min-w-0", showSidebar),
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
					className: cn("px-12 py-8", showToc ? "w-full xl:grid xl:grid-cols-[1fr_200px] xl:gap-8" : "max-w-5xl mx-auto", className),
					children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						className: "min-w-0",
						children
					}), showToc && tocContent && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("aside", {
						className: "hidden xl:block",
						children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
							className: "sticky top-20",
							children: tocContent
						})
					})]
				})
			})]
		})]
	});
}
function ok() {}
function unreachable() {}
function stringify$2(values, options) {
	let settings = options || {};
	return (values[values.length - 1] === "" ? [...values, ""] : values).join((settings.padRight ? " " : "") + "," + (settings.padLeft === !1 ? "" : " ")).trim();
}
var nameRe = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, nameReJsx = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, emptyOptions$6 = {};
function name(name$1, options) {
	return ((options || emptyOptions$6).jsx ? nameReJsx : nameRe).test(name$1);
}
var re = /[ \t\n\f\r]/g;
function whitespace(thing) {
	return typeof thing == "object" ? thing.type === "text" ? empty$1(thing.value) : !1 : empty$1(thing);
}
function empty$1(value) {
	return value.replace(re, "") === "";
}
var Schema$6 = class {
	constructor(property, normal, space$1) {
		this.normal = normal, this.property = property, space$1 && (this.space = space$1);
	}
};
Schema$6.prototype.normal = {}, Schema$6.prototype.property = {}, Schema$6.prototype.space = void 0;
function merge(definitions, space$1) {
	let property = {}, normal = {};
	for (let definition$2 of definitions) Object.assign(property, definition$2.property), Object.assign(normal, definition$2.normal);
	return new Schema$6(property, normal, space$1);
}
function normalize$1(value) {
	return value.toLowerCase();
}
var Info$1 = class {
	constructor(property, attribute) {
		this.attribute = attribute, this.property = property;
	}
};
Info$1.prototype.attribute = "", Info$1.prototype.booleanish = !1, Info$1.prototype.boolean = !1, Info$1.prototype.commaOrSpaceSeparated = !1, Info$1.prototype.commaSeparated = !1, Info$1.prototype.defined = !1, Info$1.prototype.mustUseProperty = !1, Info$1.prototype.number = !1, Info$1.prototype.overloadedBoolean = !1, Info$1.prototype.property = "", Info$1.prototype.spaceSeparated = !1, Info$1.prototype.space = void 0;
var types_exports = /* @__PURE__ */ __export({
	boolean: () => boolean,
	booleanish: () => booleanish,
	commaOrSpaceSeparated: () => commaOrSpaceSeparated,
	commaSeparated: () => commaSeparated,
	number: () => number,
	overloadedBoolean: () => overloadedBoolean,
	spaceSeparated: () => spaceSeparated
}), powers = 0;
const boolean = increment(), booleanish = increment(), overloadedBoolean = increment(), number = increment(), spaceSeparated = increment(), commaSeparated = increment(), commaOrSpaceSeparated = increment();
function increment() {
	return 2 ** ++powers;
}
var checks = Object.keys(types_exports), DefinedInfo = class extends Info$1 {
	constructor(property, attribute, mask, space$1) {
		let index$2 = -1;
		if (super(property, attribute), mark(this, "space", space$1), typeof mask == "number") for (; ++index$2 < checks.length;) {
			let check = checks[index$2];
			mark(this, checks[index$2], (mask & types_exports[check]) === types_exports[check]);
		}
	}
};
DefinedInfo.prototype.defined = !0;
function mark(values, key, value) {
	value && (values[key] = value);
}
function create(definition$2) {
	let properties = {}, normals = {};
	for (let [property, value] of Object.entries(definition$2.properties)) {
		let info = new DefinedInfo(property, definition$2.transform(definition$2.attributes || {}, property), value, definition$2.space);
		definition$2.mustUseProperty && definition$2.mustUseProperty.includes(property) && (info.mustUseProperty = !0), properties[property] = info, normals[normalize$1(property)] = property, normals[normalize$1(info.attribute)] = property;
	}
	return new Schema$6(properties, normals, definition$2.space);
}
const aria = create({
	properties: {
		ariaActiveDescendant: null,
		ariaAtomic: booleanish,
		ariaAutoComplete: null,
		ariaBusy: booleanish,
		ariaChecked: booleanish,
		ariaColCount: number,
		ariaColIndex: number,
		ariaColSpan: number,
		ariaControls: spaceSeparated,
		ariaCurrent: null,
		ariaDescribedBy: spaceSeparated,
		ariaDetails: null,
		ariaDisabled: booleanish,
		ariaDropEffect: spaceSeparated,
		ariaErrorMessage: null,
		ariaExpanded: booleanish,
		ariaFlowTo: spaceSeparated,
		ariaGrabbed: booleanish,
		ariaHasPopup: null,
		ariaHidden: booleanish,
		ariaInvalid: null,
		ariaKeyShortcuts: null,
		ariaLabel: null,
		ariaLabelledBy: spaceSeparated,
		ariaLevel: number,
		ariaLive: null,
		ariaModal: booleanish,
		ariaMultiLine: booleanish,
		ariaMultiSelectable: booleanish,
		ariaOrientation: null,
		ariaOwns: spaceSeparated,
		ariaPlaceholder: null,
		ariaPosInSet: number,
		ariaPressed: booleanish,
		ariaReadOnly: booleanish,
		ariaRelevant: null,
		ariaRequired: booleanish,
		ariaRoleDescription: spaceSeparated,
		ariaRowCount: number,
		ariaRowIndex: number,
		ariaRowSpan: number,
		ariaSelected: booleanish,
		ariaSetSize: number,
		ariaSort: null,
		ariaValueMax: number,
		ariaValueMin: number,
		ariaValueNow: number,
		ariaValueText: null,
		role: null
	},
	transform(_, property) {
		return property === "role" ? property : "aria-" + property.slice(4).toLowerCase();
	}
});
function caseSensitiveTransform(attributes, attribute) {
	return attribute in attributes ? attributes[attribute] : attribute;
}
function caseInsensitiveTransform(attributes, property) {
	return caseSensitiveTransform(attributes, property.toLowerCase());
}
const html$3 = create({
	attributes: {
		acceptcharset: "accept-charset",
		classname: "class",
		htmlfor: "for",
		httpequiv: "http-equiv"
	},
	mustUseProperty: [
		"checked",
		"multiple",
		"muted",
		"selected"
	],
	properties: {
		abbr: null,
		accept: commaSeparated,
		acceptCharset: spaceSeparated,
		accessKey: spaceSeparated,
		action: null,
		allow: null,
		allowFullScreen: boolean,
		allowPaymentRequest: boolean,
		allowUserMedia: boolean,
		alt: null,
		as: null,
		async: boolean,
		autoCapitalize: null,
		autoComplete: spaceSeparated,
		autoFocus: boolean,
		autoPlay: boolean,
		blocking: spaceSeparated,
		capture: null,
		charSet: null,
		checked: boolean,
		cite: null,
		className: spaceSeparated,
		cols: number,
		colSpan: null,
		content: null,
		contentEditable: booleanish,
		controls: boolean,
		controlsList: spaceSeparated,
		coords: number | commaSeparated,
		crossOrigin: null,
		data: null,
		dateTime: null,
		decoding: null,
		default: boolean,
		defer: boolean,
		dir: null,
		dirName: null,
		disabled: boolean,
		download: overloadedBoolean,
		draggable: booleanish,
		encType: null,
		enterKeyHint: null,
		fetchPriority: null,
		form: null,
		formAction: null,
		formEncType: null,
		formMethod: null,
		formNoValidate: boolean,
		formTarget: null,
		headers: spaceSeparated,
		height: number,
		hidden: overloadedBoolean,
		high: number,
		href: null,
		hrefLang: null,
		htmlFor: spaceSeparated,
		httpEquiv: spaceSeparated,
		id: null,
		imageSizes: null,
		imageSrcSet: null,
		inert: boolean,
		inputMode: null,
		integrity: null,
		is: null,
		isMap: boolean,
		itemId: null,
		itemProp: spaceSeparated,
		itemRef: spaceSeparated,
		itemScope: boolean,
		itemType: spaceSeparated,
		kind: null,
		label: null,
		lang: null,
		language: null,
		list: null,
		loading: null,
		loop: boolean,
		low: number,
		manifest: null,
		max: null,
		maxLength: number,
		media: null,
		method: null,
		min: null,
		minLength: number,
		multiple: boolean,
		muted: boolean,
		name: null,
		nonce: null,
		noModule: boolean,
		noValidate: boolean,
		onAbort: null,
		onAfterPrint: null,
		onAuxClick: null,
		onBeforeMatch: null,
		onBeforePrint: null,
		onBeforeToggle: null,
		onBeforeUnload: null,
		onBlur: null,
		onCancel: null,
		onCanPlay: null,
		onCanPlayThrough: null,
		onChange: null,
		onClick: null,
		onClose: null,
		onContextLost: null,
		onContextMenu: null,
		onContextRestored: null,
		onCopy: null,
		onCueChange: null,
		onCut: null,
		onDblClick: null,
		onDrag: null,
		onDragEnd: null,
		onDragEnter: null,
		onDragExit: null,
		onDragLeave: null,
		onDragOver: null,
		onDragStart: null,
		onDrop: null,
		onDurationChange: null,
		onEmptied: null,
		onEnded: null,
		onError: null,
		onFocus: null,
		onFormData: null,
		onHashChange: null,
		onInput: null,
		onInvalid: null,
		onKeyDown: null,
		onKeyPress: null,
		onKeyUp: null,
		onLanguageChange: null,
		onLoad: null,
		onLoadedData: null,
		onLoadedMetadata: null,
		onLoadEnd: null,
		onLoadStart: null,
		onMessage: null,
		onMessageError: null,
		onMouseDown: null,
		onMouseEnter: null,
		onMouseLeave: null,
		onMouseMove: null,
		onMouseOut: null,
		onMouseOver: null,
		onMouseUp: null,
		onOffline: null,
		onOnline: null,
		onPageHide: null,
		onPageShow: null,
		onPaste: null,
		onPause: null,
		onPlay: null,
		onPlaying: null,
		onPopState: null,
		onProgress: null,
		onRateChange: null,
		onRejectionHandled: null,
		onReset: null,
		onResize: null,
		onScroll: null,
		onScrollEnd: null,
		onSecurityPolicyViolation: null,
		onSeeked: null,
		onSeeking: null,
		onSelect: null,
		onSlotChange: null,
		onStalled: null,
		onStorage: null,
		onSubmit: null,
		onSuspend: null,
		onTimeUpdate: null,
		onToggle: null,
		onUnhandledRejection: null,
		onUnload: null,
		onVolumeChange: null,
		onWaiting: null,
		onWheel: null,
		open: boolean,
		optimum: number,
		pattern: null,
		ping: spaceSeparated,
		placeholder: null,
		playsInline: boolean,
		popover: null,
		popoverTarget: null,
		popoverTargetAction: null,
		poster: null,
		preload: null,
		readOnly: boolean,
		referrerPolicy: null,
		rel: spaceSeparated,
		required: boolean,
		reversed: boolean,
		rows: number,
		rowSpan: number,
		sandbox: spaceSeparated,
		scope: null,
		scoped: boolean,
		seamless: boolean,
		selected: boolean,
		shadowRootClonable: boolean,
		shadowRootDelegatesFocus: boolean,
		shadowRootMode: null,
		shape: null,
		size: number,
		sizes: null,
		slot: null,
		span: number,
		spellCheck: booleanish,
		src: null,
		srcDoc: null,
		srcLang: null,
		srcSet: null,
		start: number,
		step: null,
		style: null,
		tabIndex: number,
		target: null,
		title: null,
		translate: null,
		type: null,
		typeMustMatch: boolean,
		useMap: null,
		value: booleanish,
		width: number,
		wrap: null,
		writingSuggestions: null,
		align: null,
		aLink: null,
		archive: spaceSeparated,
		axis: null,
		background: null,
		bgColor: null,
		border: number,
		borderColor: null,
		bottomMargin: number,
		cellPadding: null,
		cellSpacing: null,
		char: null,
		charOff: null,
		classId: null,
		clear: null,
		code: null,
		codeBase: null,
		codeType: null,
		color: null,
		compact: boolean,
		declare: boolean,
		event: null,
		face: null,
		frame: null,
		frameBorder: null,
		hSpace: number,
		leftMargin: number,
		link: null,
		longDesc: null,
		lowSrc: null,
		marginHeight: number,
		marginWidth: number,
		noResize: boolean,
		noHref: boolean,
		noShade: boolean,
		noWrap: boolean,
		object: null,
		profile: null,
		prompt: null,
		rev: null,
		rightMargin: number,
		rules: null,
		scheme: null,
		scrolling: booleanish,
		standby: null,
		summary: null,
		text: null,
		topMargin: number,
		valueType: null,
		version: null,
		vAlign: null,
		vLink: null,
		vSpace: number,
		allowTransparency: null,
		autoCorrect: null,
		autoSave: null,
		disablePictureInPicture: boolean,
		disableRemotePlayback: boolean,
		prefix: null,
		property: null,
		results: number,
		security: null,
		unselectable: null
	},
	space: "html",
	transform: caseInsensitiveTransform
}), svg$1 = create({
	attributes: {
		accentHeight: "accent-height",
		alignmentBaseline: "alignment-baseline",
		arabicForm: "arabic-form",
		baselineShift: "baseline-shift",
		capHeight: "cap-height",
		className: "class",
		clipPath: "clip-path",
		clipRule: "clip-rule",
		colorInterpolation: "color-interpolation",
		colorInterpolationFilters: "color-interpolation-filters",
		colorProfile: "color-profile",
		colorRendering: "color-rendering",
		crossOrigin: "crossorigin",
		dataType: "datatype",
		dominantBaseline: "dominant-baseline",
		enableBackground: "enable-background",
		fillOpacity: "fill-opacity",
		fillRule: "fill-rule",
		floodColor: "flood-color",
		floodOpacity: "flood-opacity",
		fontFamily: "font-family",
		fontSize: "font-size",
		fontSizeAdjust: "font-size-adjust",
		fontStretch: "font-stretch",
		fontStyle: "font-style",
		fontVariant: "font-variant",
		fontWeight: "font-weight",
		glyphName: "glyph-name",
		glyphOrientationHorizontal: "glyph-orientation-horizontal",
		glyphOrientationVertical: "glyph-orientation-vertical",
		hrefLang: "hreflang",
		horizAdvX: "horiz-adv-x",
		horizOriginX: "horiz-origin-x",
		horizOriginY: "horiz-origin-y",
		imageRendering: "image-rendering",
		letterSpacing: "letter-spacing",
		lightingColor: "lighting-color",
		markerEnd: "marker-end",
		markerMid: "marker-mid",
		markerStart: "marker-start",
		navDown: "nav-down",
		navDownLeft: "nav-down-left",
		navDownRight: "nav-down-right",
		navLeft: "nav-left",
		navNext: "nav-next",
		navPrev: "nav-prev",
		navRight: "nav-right",
		navUp: "nav-up",
		navUpLeft: "nav-up-left",
		navUpRight: "nav-up-right",
		onAbort: "onabort",
		onActivate: "onactivate",
		onAfterPrint: "onafterprint",
		onBeforePrint: "onbeforeprint",
		onBegin: "onbegin",
		onCancel: "oncancel",
		onCanPlay: "oncanplay",
		onCanPlayThrough: "oncanplaythrough",
		onChange: "onchange",
		onClick: "onclick",
		onClose: "onclose",
		onCopy: "oncopy",
		onCueChange: "oncuechange",
		onCut: "oncut",
		onDblClick: "ondblclick",
		onDrag: "ondrag",
		onDragEnd: "ondragend",
		onDragEnter: "ondragenter",
		onDragExit: "ondragexit",
		onDragLeave: "ondragleave",
		onDragOver: "ondragover",
		onDragStart: "ondragstart",
		onDrop: "ondrop",
		onDurationChange: "ondurationchange",
		onEmptied: "onemptied",
		onEnd: "onend",
		onEnded: "onended",
		onError: "onerror",
		onFocus: "onfocus",
		onFocusIn: "onfocusin",
		onFocusOut: "onfocusout",
		onHashChange: "onhashchange",
		onInput: "oninput",
		onInvalid: "oninvalid",
		onKeyDown: "onkeydown",
		onKeyPress: "onkeypress",
		onKeyUp: "onkeyup",
		onLoad: "onload",
		onLoadedData: "onloadeddata",
		onLoadedMetadata: "onloadedmetadata",
		onLoadStart: "onloadstart",
		onMessage: "onmessage",
		onMouseDown: "onmousedown",
		onMouseEnter: "onmouseenter",
		onMouseLeave: "onmouseleave",
		onMouseMove: "onmousemove",
		onMouseOut: "onmouseout",
		onMouseOver: "onmouseover",
		onMouseUp: "onmouseup",
		onMouseWheel: "onmousewheel",
		onOffline: "onoffline",
		onOnline: "ononline",
		onPageHide: "onpagehide",
		onPageShow: "onpageshow",
		onPaste: "onpaste",
		onPause: "onpause",
		onPlay: "onplay",
		onPlaying: "onplaying",
		onPopState: "onpopstate",
		onProgress: "onprogress",
		onRateChange: "onratechange",
		onRepeat: "onrepeat",
		onReset: "onreset",
		onResize: "onresize",
		onScroll: "onscroll",
		onSeeked: "onseeked",
		onSeeking: "onseeking",
		onSelect: "onselect",
		onShow: "onshow",
		onStalled: "onstalled",
		onStorage: "onstorage",
		onSubmit: "onsubmit",
		onSuspend: "onsuspend",
		onTimeUpdate: "ontimeupdate",
		onToggle: "ontoggle",
		onUnload: "onunload",
		onVolumeChange: "onvolumechange",
		onWaiting: "onwaiting",
		onZoom: "onzoom",
		overlinePosition: "overline-position",
		overlineThickness: "overline-thickness",
		paintOrder: "paint-order",
		panose1: "panose-1",
		pointerEvents: "pointer-events",
		referrerPolicy: "referrerpolicy",
		renderingIntent: "rendering-intent",
		shapeRendering: "shape-rendering",
		stopColor: "stop-color",
		stopOpacity: "stop-opacity",
		strikethroughPosition: "strikethrough-position",
		strikethroughThickness: "strikethrough-thickness",
		strokeDashArray: "stroke-dasharray",
		strokeDashOffset: "stroke-dashoffset",
		strokeLineCap: "stroke-linecap",
		strokeLineJoin: "stroke-linejoin",
		strokeMiterLimit: "stroke-miterlimit",
		strokeOpacity: "stroke-opacity",
		strokeWidth: "stroke-width",
		tabIndex: "tabindex",
		textAnchor: "text-anchor",
		textDecoration: "text-decoration",
		textRendering: "text-rendering",
		transformOrigin: "transform-origin",
		typeOf: "typeof",
		underlinePosition: "underline-position",
		underlineThickness: "underline-thickness",
		unicodeBidi: "unicode-bidi",
		unicodeRange: "unicode-range",
		unitsPerEm: "units-per-em",
		vAlphabetic: "v-alphabetic",
		vHanging: "v-hanging",
		vIdeographic: "v-ideographic",
		vMathematical: "v-mathematical",
		vectorEffect: "vector-effect",
		vertAdvY: "vert-adv-y",
		vertOriginX: "vert-origin-x",
		vertOriginY: "vert-origin-y",
		wordSpacing: "word-spacing",
		writingMode: "writing-mode",
		xHeight: "x-height",
		playbackOrder: "playbackorder",
		timelineBegin: "timelinebegin"
	},
	properties: {
		about: commaOrSpaceSeparated,
		accentHeight: number,
		accumulate: null,
		additive: null,
		alignmentBaseline: null,
		alphabetic: number,
		amplitude: number,
		arabicForm: null,
		ascent: number,
		attributeName: null,
		attributeType: null,
		azimuth: number,
		bandwidth: null,
		baselineShift: null,
		baseFrequency: null,
		baseProfile: null,
		bbox: null,
		begin: null,
		bias: number,
		by: null,
		calcMode: null,
		capHeight: number,
		className: spaceSeparated,
		clip: null,
		clipPath: null,
		clipPathUnits: null,
		clipRule: null,
		color: null,
		colorInterpolation: null,
		colorInterpolationFilters: null,
		colorProfile: null,
		colorRendering: null,
		content: null,
		contentScriptType: null,
		contentStyleType: null,
		crossOrigin: null,
		cursor: null,
		cx: null,
		cy: null,
		d: null,
		dataType: null,
		defaultAction: null,
		descent: number,
		diffuseConstant: number,
		direction: null,
		display: null,
		dur: null,
		divisor: number,
		dominantBaseline: null,
		download: boolean,
		dx: null,
		dy: null,
		edgeMode: null,
		editable: null,
		elevation: number,
		enableBackground: null,
		end: null,
		event: null,
		exponent: number,
		externalResourcesRequired: null,
		fill: null,
		fillOpacity: number,
		fillRule: null,
		filter: null,
		filterRes: null,
		filterUnits: null,
		floodColor: null,
		floodOpacity: null,
		focusable: null,
		focusHighlight: null,
		fontFamily: null,
		fontSize: null,
		fontSizeAdjust: null,
		fontStretch: null,
		fontStyle: null,
		fontVariant: null,
		fontWeight: null,
		format: null,
		fr: null,
		from: null,
		fx: null,
		fy: null,
		g1: commaSeparated,
		g2: commaSeparated,
		glyphName: commaSeparated,
		glyphOrientationHorizontal: null,
		glyphOrientationVertical: null,
		glyphRef: null,
		gradientTransform: null,
		gradientUnits: null,
		handler: null,
		hanging: number,
		hatchContentUnits: null,
		hatchUnits: null,
		height: null,
		href: null,
		hrefLang: null,
		horizAdvX: number,
		horizOriginX: number,
		horizOriginY: number,
		id: null,
		ideographic: number,
		imageRendering: null,
		initialVisibility: null,
		in: null,
		in2: null,
		intercept: number,
		k: number,
		k1: number,
		k2: number,
		k3: number,
		k4: number,
		kernelMatrix: commaOrSpaceSeparated,
		kernelUnitLength: null,
		keyPoints: null,
		keySplines: null,
		keyTimes: null,
		kerning: null,
		lang: null,
		lengthAdjust: null,
		letterSpacing: null,
		lightingColor: null,
		limitingConeAngle: number,
		local: null,
		markerEnd: null,
		markerMid: null,
		markerStart: null,
		markerHeight: null,
		markerUnits: null,
		markerWidth: null,
		mask: null,
		maskContentUnits: null,
		maskUnits: null,
		mathematical: null,
		max: null,
		media: null,
		mediaCharacterEncoding: null,
		mediaContentEncodings: null,
		mediaSize: number,
		mediaTime: null,
		method: null,
		min: null,
		mode: null,
		name: null,
		navDown: null,
		navDownLeft: null,
		navDownRight: null,
		navLeft: null,
		navNext: null,
		navPrev: null,
		navRight: null,
		navUp: null,
		navUpLeft: null,
		navUpRight: null,
		numOctaves: null,
		observer: null,
		offset: null,
		onAbort: null,
		onActivate: null,
		onAfterPrint: null,
		onBeforePrint: null,
		onBegin: null,
		onCancel: null,
		onCanPlay: null,
		onCanPlayThrough: null,
		onChange: null,
		onClick: null,
		onClose: null,
		onCopy: null,
		onCueChange: null,
		onCut: null,
		onDblClick: null,
		onDrag: null,
		onDragEnd: null,
		onDragEnter: null,
		onDragExit: null,
		onDragLeave: null,
		onDragOver: null,
		onDragStart: null,
		onDrop: null,
		onDurationChange: null,
		onEmptied: null,
		onEnd: null,
		onEnded: null,
		onError: null,
		onFocus: null,
		onFocusIn: null,
		onFocusOut: null,
		onHashChange: null,
		onInput: null,
		onInvalid: null,
		onKeyDown: null,
		onKeyPress: null,
		onKeyUp: null,
		onLoad: null,
		onLoadedData: null,
		onLoadedMetadata: null,
		onLoadStart: null,
		onMessage: null,
		onMouseDown: null,
		onMouseEnter: null,
		onMouseLeave: null,
		onMouseMove: null,
		onMouseOut: null,
		onMouseOver: null,
		onMouseUp: null,
		onMouseWheel: null,
		onOffline: null,
		onOnline: null,
		onPageHide: null,
		onPageShow: null,
		onPaste: null,
		onPause: null,
		onPlay: null,
		onPlaying: null,
		onPopState: null,
		onProgress: null,
		onRateChange: null,
		onRepeat: null,
		onReset: null,
		onResize: null,
		onScroll: null,
		onSeeked: null,
		onSeeking: null,
		onSelect: null,
		onShow: null,
		onStalled: null,
		onStorage: null,
		onSubmit: null,
		onSuspend: null,
		onTimeUpdate: null,
		onToggle: null,
		onUnload: null,
		onVolumeChange: null,
		onWaiting: null,
		onZoom: null,
		opacity: null,
		operator: null,
		order: null,
		orient: null,
		orientation: null,
		origin: null,
		overflow: null,
		overlay: null,
		overlinePosition: number,
		overlineThickness: number,
		paintOrder: null,
		panose1: null,
		path: null,
		pathLength: number,
		patternContentUnits: null,
		patternTransform: null,
		patternUnits: null,
		phase: null,
		ping: spaceSeparated,
		pitch: null,
		playbackOrder: null,
		pointerEvents: null,
		points: null,
		pointsAtX: number,
		pointsAtY: number,
		pointsAtZ: number,
		preserveAlpha: null,
		preserveAspectRatio: null,
		primitiveUnits: null,
		propagate: null,
		property: commaOrSpaceSeparated,
		r: null,
		radius: null,
		referrerPolicy: null,
		refX: null,
		refY: null,
		rel: commaOrSpaceSeparated,
		rev: commaOrSpaceSeparated,
		renderingIntent: null,
		repeatCount: null,
		repeatDur: null,
		requiredExtensions: commaOrSpaceSeparated,
		requiredFeatures: commaOrSpaceSeparated,
		requiredFonts: commaOrSpaceSeparated,
		requiredFormats: commaOrSpaceSeparated,
		resource: null,
		restart: null,
		result: null,
		rotate: null,
		rx: null,
		ry: null,
		scale: null,
		seed: null,
		shapeRendering: null,
		side: null,
		slope: null,
		snapshotTime: null,
		specularConstant: number,
		specularExponent: number,
		spreadMethod: null,
		spacing: null,
		startOffset: null,
		stdDeviation: null,
		stemh: null,
		stemv: null,
		stitchTiles: null,
		stopColor: null,
		stopOpacity: null,
		strikethroughPosition: number,
		strikethroughThickness: number,
		string: null,
		stroke: null,
		strokeDashArray: commaOrSpaceSeparated,
		strokeDashOffset: null,
		strokeLineCap: null,
		strokeLineJoin: null,
		strokeMiterLimit: number,
		strokeOpacity: number,
		strokeWidth: null,
		style: null,
		surfaceScale: number,
		syncBehavior: null,
		syncBehaviorDefault: null,
		syncMaster: null,
		syncTolerance: null,
		syncToleranceDefault: null,
		systemLanguage: commaOrSpaceSeparated,
		tabIndex: number,
		tableValues: null,
		target: null,
		targetX: number,
		targetY: number,
		textAnchor: null,
		textDecoration: null,
		textRendering: null,
		textLength: null,
		timelineBegin: null,
		title: null,
		transformBehavior: null,
		type: null,
		typeOf: commaOrSpaceSeparated,
		to: null,
		transform: null,
		transformOrigin: null,
		u1: null,
		u2: null,
		underlinePosition: number,
		underlineThickness: number,
		unicode: null,
		unicodeBidi: null,
		unicodeRange: null,
		unitsPerEm: number,
		values: null,
		vAlphabetic: number,
		vMathematical: number,
		vectorEffect: null,
		vHanging: number,
		vIdeographic: number,
		version: null,
		vertAdvY: number,
		vertOriginX: number,
		vertOriginY: number,
		viewBox: null,
		viewTarget: null,
		visibility: null,
		width: null,
		widths: null,
		wordSpacing: null,
		writingMode: null,
		x: null,
		x1: null,
		x2: null,
		xChannelSelector: null,
		xHeight: number,
		y: null,
		y1: null,
		y2: null,
		yChannelSelector: null,
		z: null,
		zoomAndPan: null
	},
	space: "svg",
	transform: caseSensitiveTransform
}), xlink = create({
	properties: {
		xLinkActuate: null,
		xLinkArcRole: null,
		xLinkHref: null,
		xLinkRole: null,
		xLinkShow: null,
		xLinkTitle: null,
		xLinkType: null
	},
	space: "xlink",
	transform(_, property) {
		return "xlink:" + property.slice(5).toLowerCase();
	}
}), xmlns = create({
	attributes: { xmlnsxlink: "xmlns:xlink" },
	properties: {
		xmlnsXLink: null,
		xmlns: null
	},
	space: "xmlns",
	transform: caseInsensitiveTransform
}), xml$1 = create({
	properties: {
		xmlBase: null,
		xmlLang: null,
		xmlSpace: null
	},
	space: "xml",
	transform(_, property) {
		return "xml:" + property.slice(3).toLowerCase();
	}
}), hastToReact = {
	classId: "classID",
	dataType: "datatype",
	itemId: "itemID",
	strokeDashArray: "strokeDasharray",
	strokeDashOffset: "strokeDashoffset",
	strokeLineCap: "strokeLinecap",
	strokeLineJoin: "strokeLinejoin",
	strokeMiterLimit: "strokeMiterlimit",
	typeOf: "typeof",
	xLinkActuate: "xlinkActuate",
	xLinkArcRole: "xlinkArcrole",
	xLinkHref: "xlinkHref",
	xLinkRole: "xlinkRole",
	xLinkShow: "xlinkShow",
	xLinkTitle: "xlinkTitle",
	xLinkType: "xlinkType",
	xmlnsXLink: "xmlnsXlink"
};
var cap$1 = /[A-Z]/g, dash = /-[a-z]/g, valid = /^data[-\w.:]+$/i;
function find(schema, value) {
	let normal = normalize$1(value), property = value, Type$18 = Info$1;
	if (normal in schema.normal) return schema.property[schema.normal[normal]];
	if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
		if (value.charAt(4) === "-") {
			let rest = value.slice(5).replace(dash, camelcase);
			property = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
		} else {
			let rest = value.slice(4);
			if (!dash.test(rest)) {
				let dashes = rest.replace(cap$1, kebab);
				dashes.charAt(0) !== "-" && (dashes = "-" + dashes), value = "data" + dashes;
			}
		}
		Type$18 = DefinedInfo;
	}
	return new Type$18(property, value);
}
function kebab($0) {
	return "-" + $0.toLowerCase();
}
function camelcase($0) {
	return $0.charAt(1).toUpperCase();
}
const html$2 = merge([
	aria,
	html$3,
	xlink,
	xmlns,
	xml$1
], "html"), svg = merge([
	aria,
	svg$1,
	xlink,
	xmlns,
	xml$1
], "svg");
function stringify$3(values) {
	return values.join(" ").trim();
}
var require_cjs$2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, NEWLINE_REGEX = /\n/g, WHITESPACE_REGEX = /^\s*/, PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, COLON_REGEX = /^:\s*/, VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, SEMICOLON_REGEX = /^[;\s]*/, TRIM_REGEX = /^\s+|\s+$/g, NEWLINE = "\n", FORWARD_SLASH = "/", ASTERISK = "*", EMPTY_STRING = "", TYPE_COMMENT = "comment", TYPE_DECLARATION = "declaration";
	function index$1(style, options) {
		if (typeof style != "string") throw TypeError("First argument must be a string");
		if (!style) return [];
		options ||= {};
		var lineno = 1, column = 1;
		function updatePosition(str) {
			var lines = str.match(NEWLINE_REGEX);
			lines && (lineno += lines.length);
			var i$2 = str.lastIndexOf(NEWLINE);
			column = ~i$2 ? str.length - i$2 : column + str.length;
		}
		function position$2() {
			var start = {
				line: lineno,
				column
			};
			return function(node$1) {
				return node$1.position = new Position(start), whitespace$1(), node$1;
			};
		}
		function Position(start) {
			this.start = start, this.end = {
				line: lineno,
				column
			}, this.source = options.source;
		}
		Position.prototype.content = style;
		function error$1(msg) {
			var err = /* @__PURE__ */ Error(options.source + ":" + lineno + ":" + column + ": " + msg);
			if (err.reason = msg, err.filename = options.source, err.line = lineno, err.column = column, err.source = style, !options.silent) throw err;
		}
		function match(re$1) {
			var m = re$1.exec(style);
			if (m) {
				var str = m[0];
				return updatePosition(str), style = style.slice(str.length), m;
			}
		}
		function whitespace$1() {
			match(WHITESPACE_REGEX);
		}
		function comments(rules) {
			var c$1;
			for (rules ||= []; c$1 = comment();) c$1 !== !1 && rules.push(c$1);
			return rules;
		}
		function comment() {
			var pos = position$2();
			if (!(FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1))) {
				for (var i$2 = 2; EMPTY_STRING != style.charAt(i$2) && (ASTERISK != style.charAt(i$2) || FORWARD_SLASH != style.charAt(i$2 + 1));) ++i$2;
				if (i$2 += 2, EMPTY_STRING === style.charAt(i$2 - 1)) return error$1("End of comment missing");
				var str = style.slice(2, i$2 - 2);
				return column += 2, updatePosition(str), style = style.slice(i$2), column += 2, pos({
					type: TYPE_COMMENT,
					comment: str
				});
			}
		}
		function declaration() {
			var pos = position$2(), prop = match(PROPERTY_REGEX);
			if (prop) {
				if (comment(), !match(COLON_REGEX)) return error$1("property missing ':'");
				var val = match(VALUE_REGEX), ret = pos({
					type: TYPE_DECLARATION,
					property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
					value: val ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
				});
				return match(SEMICOLON_REGEX), ret;
			}
		}
		function declarations() {
			var decls = [];
			comments(decls);
			for (var decl; decl = declaration();) decl !== !1 && (decls.push(decl), comments(decls));
			return decls;
		}
		return whitespace$1(), declarations();
	}
	function trim(str) {
		return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
	}
	module.exports = index$1;
})), require_cjs$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { default: mod };
	};
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = StyleToObject;
	var inline_style_parser_1 = __importDefault(require_cjs$2());
	function StyleToObject(style, iterator) {
		let styleObject = null;
		if (!style || typeof style != "string") return styleObject;
		let declarations = (0, inline_style_parser_1.default)(style), hasIterator = typeof iterator == "function";
		return declarations.forEach((declaration) => {
			if (declaration.type !== "declaration") return;
			let { property, value } = declaration;
			hasIterator ? iterator(property, value, declaration) : value && (styleObject ||= {}, styleObject[property] = value);
		}), styleObject;
	}
})), require_utilities = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.camelCase = void 0;
	var CUSTOM_PROPERTY_REGEX = /^--[a-zA-Z0-9_-]+$/, HYPHEN_REGEX = /-([a-z])/g, NO_HYPHEN_REGEX = /^[^-]+$/, VENDOR_PREFIX_REGEX = /^-(webkit|moz|ms|o|khtml)-/, MS_VENDOR_PREFIX_REGEX = /^-(ms)-/, skipCamelCase = function(property) {
		return !property || NO_HYPHEN_REGEX.test(property) || CUSTOM_PROPERTY_REGEX.test(property);
	}, capitalize = function(match, character) {
		return character.toUpperCase();
	}, trimHyphen = function(match, prefix) {
		return `${prefix}-`;
	};
	exports.camelCase = function(property, options) {
		return options === void 0 && (options = {}), skipCamelCase(property) ? property : (property = property.toLowerCase(), property = options.reactCompat ? property.replace(MS_VENDOR_PREFIX_REGEX, trimHyphen) : property.replace(VENDOR_PREFIX_REGEX, trimHyphen), property.replace(HYPHEN_REGEX, capitalize));
	};
})), require_cjs = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var style_to_object_1 = (exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { default: mod };
	})(require_cjs$1()), utilities_1 = require_utilities();
	function StyleToJS(style, options) {
		var output = {};
		return !style || typeof style != "string" || (0, style_to_object_1.default)(style, function(property, value) {
			property && value && (output[(0, utilities_1.camelCase)(property, options)] = value);
		}), output;
	}
	StyleToJS.default = StyleToJS, module.exports = StyleToJS;
}));
const pointEnd = point$2("end"), pointStart = point$2("start");
function point$2(type) {
	return point$3;
	function point$3(node$1) {
		let point$4 = node$1 && node$1.position && node$1.position[type] || {};
		if (typeof point$4.line == "number" && point$4.line > 0 && typeof point$4.column == "number" && point$4.column > 0) return {
			line: point$4.line,
			column: point$4.column,
			offset: typeof point$4.offset == "number" && point$4.offset > -1 ? point$4.offset : void 0
		};
	}
}
function position(node$1) {
	let start = pointStart(node$1), end = pointEnd(node$1);
	if (start && end) return {
		start,
		end
	};
}
function stringifyPosition(value) {
	return !value || typeof value != "object" ? "" : "position" in value || "type" in value ? position$1(value.position) : "start" in value || "end" in value ? position$1(value) : "line" in value || "column" in value ? point$1(value) : "";
}
function point$1(point$3) {
	return index(point$3 && point$3.line) + ":" + index(point$3 && point$3.column);
}
function position$1(pos) {
	return point$1(pos && pos.start) + "-" + point$1(pos && pos.end);
}
function index(value) {
	return value && typeof value == "number" ? value : 1;
}
var VFileMessage = class extends Error {
	constructor(causeOrReason, optionsOrParentOrPlace, origin) {
		super(), typeof optionsOrParentOrPlace == "string" && (origin = optionsOrParentOrPlace, optionsOrParentOrPlace = void 0);
		let reason = "", options = {}, legacyCause = !1;
		if (optionsOrParentOrPlace && (options = "line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace || "start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace ? { place: optionsOrParentOrPlace } : "type" in optionsOrParentOrPlace ? {
			ancestors: [optionsOrParentOrPlace],
			place: optionsOrParentOrPlace.position
		} : { ...optionsOrParentOrPlace }), typeof causeOrReason == "string" ? reason = causeOrReason : !options.cause && causeOrReason && (legacyCause = !0, reason = causeOrReason.message, options.cause = causeOrReason), !options.ruleId && !options.source && typeof origin == "string") {
			let index$2 = origin.indexOf(":");
			index$2 === -1 ? options.ruleId = origin : (options.source = origin.slice(0, index$2), options.ruleId = origin.slice(index$2 + 1));
		}
		if (!options.place && options.ancestors && options.ancestors) {
			let parent = options.ancestors[options.ancestors.length - 1];
			parent && (options.place = parent.position);
		}
		let start = options.place && "start" in options.place ? options.place.start : options.place;
		this.ancestors = options.ancestors || void 0, this.cause = options.cause || void 0, this.column = start ? start.column : void 0, this.fatal = void 0, this.file = "", this.message = reason, this.line = start ? start.line : void 0, this.name = stringifyPosition(options.place) || "1:1", this.place = options.place || void 0, this.reason = this.message, this.ruleId = options.ruleId || void 0, this.source = options.source || void 0, this.stack = legacyCause && options.cause && typeof options.cause.stack == "string" ? options.cause.stack : "", this.actual = void 0, this.expected = void 0, this.note = void 0, this.url = void 0;
	}
};
VFileMessage.prototype.file = "", VFileMessage.prototype.name = "", VFileMessage.prototype.reason = "", VFileMessage.prototype.message = "", VFileMessage.prototype.stack = "", VFileMessage.prototype.column = void 0, VFileMessage.prototype.line = void 0, VFileMessage.prototype.ancestors = void 0, VFileMessage.prototype.cause = void 0, VFileMessage.prototype.fatal = void 0, VFileMessage.prototype.place = void 0, VFileMessage.prototype.ruleId = void 0, VFileMessage.prototype.source = void 0;
var import_cjs = /* @__PURE__ */ __toESM(require_cjs(), 1), own$4 = {}.hasOwnProperty, emptyMap = /* @__PURE__ */ new Map(), cap = /[A-Z]/g, tableElements = new Set([
	"table",
	"tbody",
	"thead",
	"tfoot",
	"tr"
]), tableCellElement = new Set(["td", "th"]), docs = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function toJsxRuntime(tree, options) {
	if (!options || options.Fragment === void 0) throw TypeError("Expected `Fragment` in options");
	let filePath = options.filePath || void 0, create$1;
	if (options.development) {
		if (typeof options.jsxDEV != "function") throw TypeError("Expected `jsxDEV` in options when `development: true`");
		create$1 = developmentCreate(filePath, options.jsxDEV);
	} else {
		if (typeof options.jsx != "function") throw TypeError("Expected `jsx` in production options");
		if (typeof options.jsxs != "function") throw TypeError("Expected `jsxs` in production options");
		create$1 = productionCreate(filePath, options.jsx, options.jsxs);
	}
	let state = {
		Fragment: options.Fragment,
		ancestors: [],
		components: options.components || {},
		create: create$1,
		elementAttributeNameCase: options.elementAttributeNameCase || "react",
		evaluater: options.createEvaluater ? options.createEvaluater() : void 0,
		filePath,
		ignoreInvalidStyle: options.ignoreInvalidStyle || !1,
		passKeys: options.passKeys !== !1,
		passNode: options.passNode || !1,
		schema: options.space === "svg" ? svg : html$2,
		stylePropertyNameCase: options.stylePropertyNameCase || "dom",
		tableCellAlignToStyle: options.tableCellAlignToStyle !== !1
	}, result = one$2(state, tree, void 0);
	return result && typeof result != "string" ? result : state.create(tree, state.Fragment, { children: result || void 0 }, void 0);
}
function one$2(state, node$1, key) {
	if (node$1.type === "element") return element$2(state, node$1, key);
	if (node$1.type === "mdxFlowExpression" || node$1.type === "mdxTextExpression") return mdxExpression(state, node$1);
	if (node$1.type === "mdxJsxFlowElement" || node$1.type === "mdxJsxTextElement") return mdxJsxElement(state, node$1, key);
	if (node$1.type === "mdxjsEsm") return mdxEsm(state, node$1);
	if (node$1.type === "root") return root$2(state, node$1, key);
	if (node$1.type === "text") return text$5(state, node$1);
}
function element$2(state, node$1, key) {
	let parentSchema = state.schema, schema = parentSchema;
	node$1.tagName.toLowerCase() === "svg" && parentSchema.space === "html" && (schema = svg, state.schema = schema), state.ancestors.push(node$1);
	let type = findComponentFromName(state, node$1.tagName, !1), props = createElementProps(state, node$1), children = createChildren(state, node$1);
	return tableElements.has(node$1.tagName) && (children = children.filter(function(child) {
		return typeof child == "string" ? !whitespace(child) : !0;
	})), addNode(state, props, type, node$1), addChildren(props, children), state.ancestors.pop(), state.schema = parentSchema, state.create(node$1, type, props, key);
}
function mdxExpression(state, node$1) {
	if (node$1.data && node$1.data.estree && state.evaluater) {
		let expression = node$1.data.estree.body[0];
		return expression.type, state.evaluater.evaluateExpression(expression.expression);
	}
	crashEstree(state, node$1.position);
}
function mdxEsm(state, node$1) {
	if (node$1.data && node$1.data.estree && state.evaluater) return state.evaluater.evaluateProgram(node$1.data.estree);
	crashEstree(state, node$1.position);
}
function mdxJsxElement(state, node$1, key) {
	let parentSchema = state.schema, schema = parentSchema;
	node$1.name === "svg" && parentSchema.space === "html" && (schema = svg, state.schema = schema), state.ancestors.push(node$1);
	let type = node$1.name === null ? state.Fragment : findComponentFromName(state, node$1.name, !0), props = createJsxElementProps(state, node$1), children = createChildren(state, node$1);
	return addNode(state, props, type, node$1), addChildren(props, children), state.ancestors.pop(), state.schema = parentSchema, state.create(node$1, type, props, key);
}
function root$2(state, node$1, key) {
	let props = {};
	return addChildren(props, createChildren(state, node$1)), state.create(node$1, state.Fragment, props, key);
}
function text$5(_, node$1) {
	return node$1.value;
}
function addNode(state, props, type, node$1) {
	typeof type != "string" && type !== state.Fragment && state.passNode && (props.node = node$1);
}
function addChildren(props, children) {
	if (children.length > 0) {
		let value = children.length > 1 ? children : children[0];
		value && (props.children = value);
	}
}
function productionCreate(_, jsx$1, jsxs$1) {
	return create$1;
	function create$1(_$1, type, props, key) {
		let fn = Array.isArray(props.children) ? jsxs$1 : jsx$1;
		return key ? fn(type, props, key) : fn(type, props);
	}
}
function developmentCreate(filePath, jsxDEV) {
	return create$1;
	function create$1(node$1, type, props, key) {
		let isStaticChildren = Array.isArray(props.children), point$3 = pointStart(node$1);
		return jsxDEV(type, props, key, isStaticChildren, {
			columnNumber: point$3 ? point$3.column - 1 : void 0,
			fileName: filePath,
			lineNumber: point$3 ? point$3.line : void 0
		}, void 0);
	}
}
function createElementProps(state, node$1) {
	let props = {}, alignValue, prop;
	for (prop in node$1.properties) if (prop !== "children" && own$4.call(node$1.properties, prop)) {
		let result = createProperty(state, prop, node$1.properties[prop]);
		if (result) {
			let [key, value] = result;
			state.tableCellAlignToStyle && key === "align" && typeof value == "string" && tableCellElement.has(node$1.tagName) ? alignValue = value : props[key] = value;
		}
	}
	if (alignValue) {
		let style = props.style ||= {};
		style[state.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = alignValue;
	}
	return props;
}
function createJsxElementProps(state, node$1) {
	let props = {};
	for (let attribute of node$1.attributes) if (attribute.type === "mdxJsxExpressionAttribute") if (attribute.data && attribute.data.estree && state.evaluater) {
		let expression = attribute.data.estree.body[0];
		expression.type;
		let objectExpression = expression.expression;
		objectExpression.type;
		let property = objectExpression.properties[0];
		property.type, Object.assign(props, state.evaluater.evaluateExpression(property.argument));
	} else crashEstree(state, node$1.position);
	else {
		let name$1 = attribute.name, value;
		if (attribute.value && typeof attribute.value == "object") if (attribute.value.data && attribute.value.data.estree && state.evaluater) {
			let expression = attribute.value.data.estree.body[0];
			expression.type, value = state.evaluater.evaluateExpression(expression.expression);
		} else crashEstree(state, node$1.position);
		else value = attribute.value === null ? !0 : attribute.value;
		props[name$1] = value;
	}
	return props;
}
function createChildren(state, node$1) {
	let children = [], index$2 = -1, countsByName = state.passKeys ? /* @__PURE__ */ new Map() : emptyMap;
	for (; ++index$2 < node$1.children.length;) {
		let child = node$1.children[index$2], key;
		if (state.passKeys) {
			let name$1 = child.type === "element" ? child.tagName : child.type === "mdxJsxFlowElement" || child.type === "mdxJsxTextElement" ? child.name : void 0;
			if (name$1) {
				let count = countsByName.get(name$1) || 0;
				key = name$1 + "-" + count, countsByName.set(name$1, count + 1);
			}
		}
		let result = one$2(state, child, key);
		result !== void 0 && children.push(result);
	}
	return children;
}
function createProperty(state, prop, value) {
	let info = find(state.schema, prop);
	if (!(value == null || typeof value == "number" && Number.isNaN(value))) {
		if (Array.isArray(value) && (value = info.commaSeparated ? stringify$2(value) : stringify$3(value)), info.property === "style") {
			let styleObject = typeof value == "object" ? value : parseStyle(state, String(value));
			return state.stylePropertyNameCase === "css" && (styleObject = transformStylesToCssCasing(styleObject)), ["style", styleObject];
		}
		return [state.elementAttributeNameCase === "react" && info.space ? hastToReact[info.property] || info.property : info.attribute, value];
	}
}
function parseStyle(state, value) {
	try {
		return (0, import_cjs.default)(value, { reactCompat: !0 });
	} catch (error$1) {
		if (state.ignoreInvalidStyle) return {};
		let cause = error$1, message = new VFileMessage("Cannot parse `style` attribute", {
			ancestors: state.ancestors,
			cause,
			ruleId: "style",
			source: "hast-util-to-jsx-runtime"
		});
		throw message.file = state.filePath || void 0, message.url = docs + "#cannot-parse-style-attribute", message;
	}
}
function findComponentFromName(state, name$1, allowExpression) {
	let result;
	if (!allowExpression) result = {
		type: "Literal",
		value: name$1
	};
	else if (name$1.includes(".")) {
		let identifiers = name$1.split("."), index$2 = -1, node$1;
		for (; ++index$2 < identifiers.length;) {
			let prop = name(identifiers[index$2]) ? {
				type: "Identifier",
				name: identifiers[index$2]
			} : {
				type: "Literal",
				value: identifiers[index$2]
			};
			node$1 = node$1 ? {
				type: "MemberExpression",
				object: node$1,
				property: prop,
				computed: !!(index$2 && prop.type === "Literal"),
				optional: !1
			} : prop;
		}
		result = node$1;
	} else result = name(name$1) && !/^[a-z]/.test(name$1) ? {
		type: "Identifier",
		name: name$1
	} : {
		type: "Literal",
		value: name$1
	};
	if (result.type === "Literal") {
		let name$2 = result.value;
		return own$4.call(state.components, name$2) ? state.components[name$2] : name$2;
	}
	if (state.evaluater) return state.evaluater.evaluateExpression(result);
	crashEstree(state);
}
function crashEstree(state, place) {
	let message = new VFileMessage("Cannot handle MDX estrees without `createEvaluater`", {
		ancestors: state.ancestors,
		place,
		ruleId: "mdx-estree",
		source: "hast-util-to-jsx-runtime"
	});
	throw message.file = state.filePath || void 0, message.url = docs + "#cannot-handle-mdx-estrees-without-createevaluater", message;
}
function transformStylesToCssCasing(domCasing) {
	let cssCasing = {}, from$1;
	for (from$1 in domCasing) own$4.call(domCasing, from$1) && (cssCasing[transformStyleToCssCasing(from$1)] = domCasing[from$1]);
	return cssCasing;
}
function transformStyleToCssCasing(from$1) {
	let to = from$1.replace(cap, toDash);
	return to.slice(0, 3) === "ms-" && (to = "-" + to), to;
}
function toDash($0) {
	return "-" + $0.toLowerCase();
}
const urlAttributes = {
	action: ["form"],
	cite: [
		"blockquote",
		"del",
		"ins",
		"q"
	],
	data: ["object"],
	formAction: ["button", "input"],
	href: [
		"a",
		"area",
		"base",
		"link"
	],
	icon: ["menuitem"],
	itemId: null,
	manifest: ["html"],
	ping: ["a", "area"],
	poster: ["video"],
	src: [
		"audio",
		"embed",
		"iframe",
		"img",
		"input",
		"script",
		"source",
		"track",
		"video"
	]
};
var emptyOptions$5 = {};
function toString$2(value, options) {
	let settings = options || emptyOptions$5;
	return one$1(value, typeof settings.includeImageAlt == "boolean" ? settings.includeImageAlt : !0, typeof settings.includeHtml == "boolean" ? settings.includeHtml : !0);
}
function one$1(value, includeImageAlt, includeHtml) {
	if (node(value)) {
		if ("value" in value) return value.type === "html" && !includeHtml ? "" : value.value;
		if (includeImageAlt && "alt" in value && value.alt) return value.alt;
		if ("children" in value) return all$1(value.children, includeImageAlt, includeHtml);
	}
	return Array.isArray(value) ? all$1(value, includeImageAlt, includeHtml) : "";
}
function all$1(values, includeImageAlt, includeHtml) {
	let result = [], index$2 = -1;
	for (; ++index$2 < values.length;) result[index$2] = one$1(values[index$2], includeImageAlt, includeHtml);
	return result.join("");
}
function node(value) {
	return !!(value && typeof value == "object");
}
var element$1 = document.createElement("i");
function decodeNamedCharacterReference(value) {
	let characterReference$1 = "&" + value + ";";
	element$1.innerHTML = characterReference$1;
	let character = element$1.textContent;
	return character.charCodeAt(character.length - 1) === 59 && value !== "semi" || character === characterReference$1 ? !1 : character;
}
function splice(list$3, start, remove, items) {
	let end = list$3.length, chunkStart = 0, parameters;
	if (start = start < 0 ? -start > end ? 0 : end + start : start > end ? end : start, remove = remove > 0 ? remove : 0, items.length < 1e4) parameters = Array.from(items), parameters.unshift(start, remove), list$3.splice(...parameters);
	else for (remove && list$3.splice(start, remove); chunkStart < items.length;) parameters = items.slice(chunkStart, chunkStart + 1e4), parameters.unshift(start, 0), list$3.splice(...parameters), chunkStart += 1e4, start += 1e4;
}
function push(list$3, items) {
	return list$3.length > 0 ? (splice(list$3, list$3.length, 0, items), list$3) : items;
}
var hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(extensions) {
	let all$2 = {}, index$2 = -1;
	for (; ++index$2 < extensions.length;) syntaxExtension(all$2, extensions[index$2]);
	return all$2;
}
function syntaxExtension(all$2, extension$1) {
	let hook;
	for (hook in extension$1) {
		let left = (hasOwnProperty.call(all$2, hook) ? all$2[hook] : void 0) || (all$2[hook] = {}), right = extension$1[hook], code$4;
		if (right) for (code$4 in right) {
			hasOwnProperty.call(left, code$4) || (left[code$4] = []);
			let value = right[code$4];
			constructs(left[code$4], Array.isArray(value) ? value : value ? [value] : []);
		}
	}
}
function constructs(existing, list$3) {
	let index$2 = -1, before = [];
	for (; ++index$2 < list$3.length;) (list$3[index$2].add === "after" ? existing : before).push(list$3[index$2]);
	splice(existing, 0, 0, before);
}
function decodeNumericCharacterReference(value, base) {
	let code$4 = Number.parseInt(value, base);
	return code$4 < 9 || code$4 === 11 || code$4 > 13 && code$4 < 32 || code$4 > 126 && code$4 < 160 || code$4 > 55295 && code$4 < 57344 || code$4 > 64975 && code$4 < 65008 || (code$4 & 65535) == 65535 || (code$4 & 65535) == 65534 || code$4 > 1114111 ? "ï¿½" : String.fromCodePoint(code$4);
}
function normalizeIdentifier(value) {
	return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const asciiAlpha = regexCheck(/[A-Za-z]/), asciiAlphanumeric = regexCheck(/[\dA-Za-z]/), asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code$4) {
	return code$4 !== null && (code$4 < 32 || code$4 === 127);
}
const asciiDigit = regexCheck(/\d/), asciiHexDigit = regexCheck(/[\dA-Fa-f]/), asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding(code$4) {
	return code$4 !== null && code$4 < -2;
}
function markdownLineEndingOrSpace(code$4) {
	return code$4 !== null && (code$4 < 0 || code$4 === 32);
}
function markdownSpace(code$4) {
	return code$4 === -2 || code$4 === -1 || code$4 === 32;
}
const unicodePunctuation = regexCheck(/\p{P}|\p{S}/u), unicodeWhitespace = regexCheck(/\s/);
function regexCheck(regex$1) {
	return check;
	function check(code$4) {
		return code$4 !== null && code$4 > -1 && regex$1.test(String.fromCharCode(code$4));
	}
}
function normalizeUri(value) {
	let result = [], index$2 = -1, start = 0, skip = 0;
	for (; ++index$2 < value.length;) {
		let code$4 = value.charCodeAt(index$2), replace$1 = "";
		if (code$4 === 37 && asciiAlphanumeric(value.charCodeAt(index$2 + 1)) && asciiAlphanumeric(value.charCodeAt(index$2 + 2))) skip = 2;
		else if (code$4 < 128) /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code$4)) || (replace$1 = String.fromCharCode(code$4));
		else if (code$4 > 55295 && code$4 < 57344) {
			let next = value.charCodeAt(index$2 + 1);
			code$4 < 56320 && next > 56319 && next < 57344 ? (replace$1 = String.fromCharCode(code$4, next), skip = 1) : replace$1 = "ï¿½";
		} else replace$1 = String.fromCharCode(code$4);
		replace$1 &&= (result.push(value.slice(start, index$2), encodeURIComponent(replace$1)), start = index$2 + skip + 1, ""), skip &&= (index$2 += skip, 0);
	}
	return result.join("") + value.slice(start);
}
function factorySpace(effects, ok$2, type, max) {
	let limit = max ? max - 1 : Infinity, size = 0;
	return start;
	function start(code$4) {
		return markdownSpace(code$4) ? (effects.enter(type), prefix(code$4)) : ok$2(code$4);
	}
	function prefix(code$4) {
		return markdownSpace(code$4) && size++ < limit ? (effects.consume(code$4), prefix) : (effects.exit(type), ok$2(code$4));
	}
}
const content = { tokenize: initializeContent };
function initializeContent(effects) {
	let contentStart = effects.attempt(this.parser.constructs.contentInitial, afterContentStartConstruct, paragraphInitial), previous$2;
	return contentStart;
	function afterContentStartConstruct(code$4) {
		if (code$4 === null) {
			effects.consume(code$4);
			return;
		}
		return effects.enter("lineEnding"), effects.consume(code$4), effects.exit("lineEnding"), factorySpace(effects, contentStart, "linePrefix");
	}
	function paragraphInitial(code$4) {
		return effects.enter("paragraph"), lineStart(code$4);
	}
	function lineStart(code$4) {
		let token = effects.enter("chunkText", {
			contentType: "text",
			previous: previous$2
		});
		return previous$2 && (previous$2.next = token), previous$2 = token, data(code$4);
	}
	function data(code$4) {
		if (code$4 === null) {
			effects.exit("chunkText"), effects.exit("paragraph"), effects.consume(code$4);
			return;
		}
		return markdownLineEnding(code$4) ? (effects.consume(code$4), effects.exit("chunkText"), lineStart) : (effects.consume(code$4), data);
	}
}
const document$1 = { tokenize: initializeDocument };
var containerConstruct = { tokenize: tokenizeContainer };
function initializeDocument(effects) {
	let self$1 = this, stack = [], continued = 0, childFlow, childToken, lineStartOffset;
	return start;
	function start(code$4) {
		if (continued < stack.length) {
			let item = stack[continued];
			return self$1.containerState = item[1], effects.attempt(item[0].continuation, documentContinue, checkNewContainers)(code$4);
		}
		return checkNewContainers(code$4);
	}
	function documentContinue(code$4) {
		if (continued++, self$1.containerState._closeFlow) {
			self$1.containerState._closeFlow = void 0, childFlow && closeFlow();
			let indexBeforeExits = self$1.events.length, indexBeforeFlow = indexBeforeExits, point$3;
			for (; indexBeforeFlow--;) if (self$1.events[indexBeforeFlow][0] === "exit" && self$1.events[indexBeforeFlow][1].type === "chunkFlow") {
				point$3 = self$1.events[indexBeforeFlow][1].end;
				break;
			}
			exitContainers(continued);
			let index$2 = indexBeforeExits;
			for (; index$2 < self$1.events.length;) self$1.events[index$2][1].end = { ...point$3 }, index$2++;
			return splice(self$1.events, indexBeforeFlow + 1, 0, self$1.events.slice(indexBeforeExits)), self$1.events.length = index$2, checkNewContainers(code$4);
		}
		return start(code$4);
	}
	function checkNewContainers(code$4) {
		if (continued === stack.length) {
			if (!childFlow) return documentContinued(code$4);
			if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) return flowStart(code$4);
			self$1.interrupt = !!(childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack);
		}
		return self$1.containerState = {}, effects.check(containerConstruct, thereIsANewContainer, thereIsNoNewContainer)(code$4);
	}
	function thereIsANewContainer(code$4) {
		return childFlow && closeFlow(), exitContainers(continued), documentContinued(code$4);
	}
	function thereIsNoNewContainer(code$4) {
		return self$1.parser.lazy[self$1.now().line] = continued !== stack.length, lineStartOffset = self$1.now().offset, flowStart(code$4);
	}
	function documentContinued(code$4) {
		return self$1.containerState = {}, effects.attempt(containerConstruct, containerContinue, flowStart)(code$4);
	}
	function containerContinue(code$4) {
		return continued++, stack.push([self$1.currentConstruct, self$1.containerState]), documentContinued(code$4);
	}
	function flowStart(code$4) {
		if (code$4 === null) {
			childFlow && closeFlow(), exitContainers(0), effects.consume(code$4);
			return;
		}
		return childFlow ||= self$1.parser.flow(self$1.now()), effects.enter("chunkFlow", {
			_tokenizer: childFlow,
			contentType: "flow",
			previous: childToken
		}), flowContinue(code$4);
	}
	function flowContinue(code$4) {
		if (code$4 === null) {
			writeToChild(effects.exit("chunkFlow"), !0), exitContainers(0), effects.consume(code$4);
			return;
		}
		return markdownLineEnding(code$4) ? (effects.consume(code$4), writeToChild(effects.exit("chunkFlow")), continued = 0, self$1.interrupt = void 0, start) : (effects.consume(code$4), flowContinue);
	}
	function writeToChild(token, endOfFile) {
		let stream = self$1.sliceStream(token);
		if (endOfFile && stream.push(null), token.previous = childToken, childToken && (childToken.next = token), childToken = token, childFlow.defineSkip(token.start), childFlow.write(stream), self$1.parser.lazy[token.start.line]) {
			let index$2 = childFlow.events.length;
			for (; index$2--;) if (childFlow.events[index$2][1].start.offset < lineStartOffset && (!childFlow.events[index$2][1].end || childFlow.events[index$2][1].end.offset > lineStartOffset)) return;
			let indexBeforeExits = self$1.events.length, indexBeforeFlow = indexBeforeExits, seen, point$3;
			for (; indexBeforeFlow--;) if (self$1.events[indexBeforeFlow][0] === "exit" && self$1.events[indexBeforeFlow][1].type === "chunkFlow") {
				if (seen) {
					point$3 = self$1.events[indexBeforeFlow][1].end;
					break;
				}
				seen = !0;
			}
			for (exitContainers(continued), index$2 = indexBeforeExits; index$2 < self$1.events.length;) self$1.events[index$2][1].end = { ...point$3 }, index$2++;
			splice(self$1.events, indexBeforeFlow + 1, 0, self$1.events.slice(indexBeforeExits)), self$1.events.length = index$2;
		}
	}
	function exitContainers(size) {
		let index$2 = stack.length;
		for (; index$2-- > size;) {
			let entry = stack[index$2];
			self$1.containerState = entry[1], entry[0].exit.call(self$1, effects);
		}
		stack.length = size;
	}
	function closeFlow() {
		childFlow.write([null]), childToken = void 0, childFlow = void 0, self$1.containerState._closeFlow = void 0;
	}
}
function tokenizeContainer(effects, ok$2, nok) {
	return factorySpace(effects, effects.attempt(this.parser.constructs.document, ok$2, nok), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function classifyCharacter(code$4) {
	if (code$4 === null || markdownLineEndingOrSpace(code$4) || unicodeWhitespace(code$4)) return 1;
	if (unicodePunctuation(code$4)) return 2;
}
function resolveAll(constructs$1, events, context) {
	let called = [], index$2 = -1;
	for (; ++index$2 < constructs$1.length;) {
		let resolve = constructs$1[index$2].resolveAll;
		resolve && !called.includes(resolve) && (events = resolve(events, context), called.push(resolve));
	}
	return events;
}
const attention = {
	name: "attention",
	resolveAll: resolveAllAttention,
	tokenize: tokenizeAttention
};
function resolveAllAttention(events, context) {
	let index$2 = -1, open, group, text$6, openingSequence, closingSequence, use, nextEvents, offset;
	for (; ++index$2 < events.length;) if (events[index$2][0] === "enter" && events[index$2][1].type === "attentionSequence" && events[index$2][1]._close) {
		for (open = index$2; open--;) if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index$2][1]).charCodeAt(0)) {
			if ((events[open][1]._close || events[index$2][1]._open) && (events[index$2][1].end.offset - events[index$2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index$2][1].end.offset - events[index$2][1].start.offset) % 3)) continue;
			use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index$2][1].end.offset - events[index$2][1].start.offset > 1 ? 2 : 1;
			let start = { ...events[open][1].end }, end = { ...events[index$2][1].start };
			movePoint(start, -use), movePoint(end, use), openingSequence = {
				type: use > 1 ? "strongSequence" : "emphasisSequence",
				start,
				end: { ...events[open][1].end }
			}, closingSequence = {
				type: use > 1 ? "strongSequence" : "emphasisSequence",
				start: { ...events[index$2][1].start },
				end
			}, text$6 = {
				type: use > 1 ? "strongText" : "emphasisText",
				start: { ...events[open][1].end },
				end: { ...events[index$2][1].start }
			}, group = {
				type: use > 1 ? "strong" : "emphasis",
				start: { ...openingSequence.start },
				end: { ...closingSequence.end }
			}, events[open][1].end = { ...openingSequence.start }, events[index$2][1].start = { ...closingSequence.end }, nextEvents = [], events[open][1].end.offset - events[open][1].start.offset && (nextEvents = push(nextEvents, [[
				"enter",
				events[open][1],
				context
			], [
				"exit",
				events[open][1],
				context
			]])), nextEvents = push(nextEvents, [
				[
					"enter",
					group,
					context
				],
				[
					"enter",
					openingSequence,
					context
				],
				[
					"exit",
					openingSequence,
					context
				],
				[
					"enter",
					text$6,
					context
				]
			]), nextEvents = push(nextEvents, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index$2), context)), nextEvents = push(nextEvents, [
				[
					"exit",
					text$6,
					context
				],
				[
					"enter",
					closingSequence,
					context
				],
				[
					"exit",
					closingSequence,
					context
				],
				[
					"exit",
					group,
					context
				]
			]), events[index$2][1].end.offset - events[index$2][1].start.offset ? (offset = 2, nextEvents = push(nextEvents, [[
				"enter",
				events[index$2][1],
				context
			], [
				"exit",
				events[index$2][1],
				context
			]])) : offset = 0, splice(events, open - 1, index$2 - open + 3, nextEvents), index$2 = open + nextEvents.length - offset - 2;
			break;
		}
	}
	for (index$2 = -1; ++index$2 < events.length;) events[index$2][1].type === "attentionSequence" && (events[index$2][1].type = "data");
	return events;
}
function tokenizeAttention(effects, ok$2) {
	let attentionMarkers$1 = this.parser.constructs.attentionMarkers.null, previous$2 = this.previous, before = classifyCharacter(previous$2), marker;
	return start;
	function start(code$4) {
		return marker = code$4, effects.enter("attentionSequence"), inside(code$4);
	}
	function inside(code$4) {
		if (code$4 === marker) return effects.consume(code$4), inside;
		let token = effects.exit("attentionSequence"), after = classifyCharacter(code$4), open = !after || after === 2 && before || attentionMarkers$1.includes(code$4), close = !before || before === 2 && after || attentionMarkers$1.includes(previous$2);
		return token._open = !!(marker === 42 ? open : open && (before || !close)), token._close = !!(marker === 42 ? close : close && (after || !open)), ok$2(code$4);
	}
}
function movePoint(point$3, offset) {
	point$3.column += offset, point$3.offset += offset, point$3._bufferIndex += offset;
}
const autolink = {
	name: "autolink",
	tokenize: tokenizeAutolink
};
function tokenizeAutolink(effects, ok$2, nok) {
	let size = 0;
	return start;
	function start(code$4) {
		return effects.enter("autolink"), effects.enter("autolinkMarker"), effects.consume(code$4), effects.exit("autolinkMarker"), effects.enter("autolinkProtocol"), open;
	}
	function open(code$4) {
		return asciiAlpha(code$4) ? (effects.consume(code$4), schemeOrEmailAtext) : code$4 === 64 ? nok(code$4) : emailAtext(code$4);
	}
	function schemeOrEmailAtext(code$4) {
		return code$4 === 43 || code$4 === 45 || code$4 === 46 || asciiAlphanumeric(code$4) ? (size = 1, schemeInsideOrEmailAtext(code$4)) : emailAtext(code$4);
	}
	function schemeInsideOrEmailAtext(code$4) {
		return code$4 === 58 ? (effects.consume(code$4), size = 0, urlInside) : (code$4 === 43 || code$4 === 45 || code$4 === 46 || asciiAlphanumeric(code$4)) && size++ < 32 ? (effects.consume(code$4), schemeInsideOrEmailAtext) : (size = 0, emailAtext(code$4));
	}
	function urlInside(code$4) {
		return code$4 === 62 ? (effects.exit("autolinkProtocol"), effects.enter("autolinkMarker"), effects.consume(code$4), effects.exit("autolinkMarker"), effects.exit("autolink"), ok$2) : code$4 === null || code$4 === 32 || code$4 === 60 || asciiControl(code$4) ? nok(code$4) : (effects.consume(code$4), urlInside);
	}
	function emailAtext(code$4) {
		return code$4 === 64 ? (effects.consume(code$4), emailAtSignOrDot) : asciiAtext(code$4) ? (effects.consume(code$4), emailAtext) : nok(code$4);
	}
	function emailAtSignOrDot(code$4) {
		return asciiAlphanumeric(code$4) ? emailLabel(code$4) : nok(code$4);
	}
	function emailLabel(code$4) {
		return code$4 === 46 ? (effects.consume(code$4), size = 0, emailAtSignOrDot) : code$4 === 62 ? (effects.exit("autolinkProtocol").type = "autolinkEmail", effects.enter("autolinkMarker"), effects.consume(code$4), effects.exit("autolinkMarker"), effects.exit("autolink"), ok$2) : emailValue(code$4);
	}
	function emailValue(code$4) {
		if ((code$4 === 45 || asciiAlphanumeric(code$4)) && size++ < 63) {
			let next = code$4 === 45 ? emailValue : emailLabel;
			return effects.consume(code$4), next;
		}
		return nok(code$4);
	}
}
const blankLine = {
	partial: !0,
	tokenize: tokenizeBlankLine
};
function tokenizeBlankLine(effects, ok$2, nok) {
	return start;
	function start(code$4) {
		return markdownSpace(code$4) ? factorySpace(effects, after, "linePrefix")(code$4) : after(code$4);
	}
	function after(code$4) {
		return code$4 === null || markdownLineEnding(code$4) ? ok$2(code$4) : nok(code$4);
	}
}
const blockQuote = {
	continuation: { tokenize: tokenizeBlockQuoteContinuation },
	exit: exit$1,
	name: "blockQuote",
	tokenize: tokenizeBlockQuoteStart
};
function tokenizeBlockQuoteStart(effects, ok$2, nok) {
	let self$1 = this;
	return start;
	function start(code$4) {
		if (code$4 === 62) {
			let state = self$1.containerState;
			return state.open ||= (effects.enter("blockQuote", { _container: !0 }), !0), effects.enter("blockQuotePrefix"), effects.enter("blockQuoteMarker"), effects.consume(code$4), effects.exit("blockQuoteMarker"), after;
		}
		return nok(code$4);
	}
	function after(code$4) {
		return markdownSpace(code$4) ? (effects.enter("blockQuotePrefixWhitespace"), effects.consume(code$4), effects.exit("blockQuotePrefixWhitespace"), effects.exit("blockQuotePrefix"), ok$2) : (effects.exit("blockQuotePrefix"), ok$2(code$4));
	}
}
function tokenizeBlockQuoteContinuation(effects, ok$2, nok) {
	let self$1 = this;
	return contStart;
	function contStart(code$4) {
		return markdownSpace(code$4) ? factorySpace(effects, contBefore, "linePrefix", self$1.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code$4) : contBefore(code$4);
	}
	function contBefore(code$4) {
		return effects.attempt(blockQuote, ok$2, nok)(code$4);
	}
}
function exit$1(effects) {
	effects.exit("blockQuote");
}
const characterEscape = {
	name: "characterEscape",
	tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok$2, nok) {
	return start;
	function start(code$4) {
		return effects.enter("characterEscape"), effects.enter("escapeMarker"), effects.consume(code$4), effects.exit("escapeMarker"), inside;
	}
	function inside(code$4) {
		return asciiPunctuation(code$4) ? (effects.enter("characterEscapeValue"), effects.consume(code$4), effects.exit("characterEscapeValue"), effects.exit("characterEscape"), ok$2) : nok(code$4);
	}
}
const characterReference = {
	name: "characterReference",
	tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok$2, nok) {
	let self$1 = this, size = 0, max, test;
	return start;
	function start(code$4) {
		return effects.enter("characterReference"), effects.enter("characterReferenceMarker"), effects.consume(code$4), effects.exit("characterReferenceMarker"), open;
	}
	function open(code$4) {
		return code$4 === 35 ? (effects.enter("characterReferenceMarkerNumeric"), effects.consume(code$4), effects.exit("characterReferenceMarkerNumeric"), numeric) : (effects.enter("characterReferenceValue"), max = 31, test = asciiAlphanumeric, value(code$4));
	}
	function numeric(code$4) {
		return code$4 === 88 || code$4 === 120 ? (effects.enter("characterReferenceMarkerHexadecimal"), effects.consume(code$4), effects.exit("characterReferenceMarkerHexadecimal"), effects.enter("characterReferenceValue"), max = 6, test = asciiHexDigit, value) : (effects.enter("characterReferenceValue"), max = 7, test = asciiDigit, value(code$4));
	}
	function value(code$4) {
		if (code$4 === 59 && size) {
			let token = effects.exit("characterReferenceValue");
			return test === asciiAlphanumeric && !decodeNamedCharacterReference(self$1.sliceSerialize(token)) ? nok(code$4) : (effects.enter("characterReferenceMarker"), effects.consume(code$4), effects.exit("characterReferenceMarker"), effects.exit("characterReference"), ok$2);
		}
		return test(code$4) && size++ < max ? (effects.consume(code$4), value) : nok(code$4);
	}
}
var nonLazyContinuation = {
	partial: !0,
	tokenize: tokenizeNonLazyContinuation
};
const codeFenced = {
	concrete: !0,
	name: "codeFenced",
	tokenize: tokenizeCodeFenced
};
function tokenizeCodeFenced(effects, ok$2, nok) {
	let self$1 = this, closeStart = {
		partial: !0,
		tokenize: tokenizeCloseStart
	}, initialPrefix = 0, sizeOpen = 0, marker;
	return start;
	function start(code$4) {
		return beforeSequenceOpen(code$4);
	}
	function beforeSequenceOpen(code$4) {
		let tail = self$1.events[self$1.events.length - 1];
		return initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], !0).length : 0, marker = code$4, effects.enter("codeFenced"), effects.enter("codeFencedFence"), effects.enter("codeFencedFenceSequence"), sequenceOpen(code$4);
	}
	function sequenceOpen(code$4) {
		return code$4 === marker ? (sizeOpen++, effects.consume(code$4), sequenceOpen) : sizeOpen < 3 ? nok(code$4) : (effects.exit("codeFencedFenceSequence"), markdownSpace(code$4) ? factorySpace(effects, infoBefore, "whitespace")(code$4) : infoBefore(code$4));
	}
	function infoBefore(code$4) {
		return code$4 === null || markdownLineEnding(code$4) ? (effects.exit("codeFencedFence"), self$1.interrupt ? ok$2(code$4) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code$4)) : (effects.enter("codeFencedFenceInfo"), effects.enter("chunkString", { contentType: "string" }), info(code$4));
	}
	function info(code$4) {
		return code$4 === null || markdownLineEnding(code$4) ? (effects.exit("chunkString"), effects.exit("codeFencedFenceInfo"), infoBefore(code$4)) : markdownSpace(code$4) ? (effects.exit("chunkString"), effects.exit("codeFencedFenceInfo"), factorySpace(effects, metaBefore, "whitespace")(code$4)) : code$4 === 96 && code$4 === marker ? nok(code$4) : (effects.consume(code$4), info);
	}
	function metaBefore(code$4) {
		return code$4 === null || markdownLineEnding(code$4) ? infoBefore(code$4) : (effects.enter("codeFencedFenceMeta"), effects.enter("chunkString", { contentType: "string" }), meta(code$4));
	}
	function meta(code$4) {
		return code$4 === null || markdownLineEnding(code$4) ? (effects.exit("chunkString"), effects.exit("codeFencedFenceMeta"), infoBefore(code$4)) : code$4 === 96 && code$4 === marker ? nok(code$4) : (effects.consume(code$4), meta);
	}
	function atNonLazyBreak(code$4) {
		return effects.attempt(closeStart, after, contentBefore)(code$4);
	}
	function contentBefore(code$4) {
		return effects.enter("lineEnding"), effects.consume(code$4), effects.exit("lineEnding"), contentStart;
	}
	function contentStart(code$4) {
		return initialPrefix > 0 && markdownSpace(code$4) ? factorySpace(effects, beforeContentChunk, "linePrefix", initialPrefix + 1)(code$4) : beforeContentChunk(code$4);
	}
	function beforeContentChunk(code$4) {
		return code$4 === null || markdownLineEnding(code$4) ? effects.check(nonLazyContinuation, atNonLazyBreak, after)(code$4) : (effects.enter("codeFlowValue"), contentChunk(code$4));
	}
	function contentChunk(code$4) {
		return code$4 === null || markdownLineEnding(code$4) ? (effects.exit("codeFlowValue"), beforeContentChunk(code$4)) : (effects.consume(code$4), contentChunk);
	}
	function after(code$4) {
		return effects.exit("codeFenced"), ok$2(code$4);
	}
	function tokenizeCloseStart(effects$1, ok$3, nok$1) {
		let size = 0;
		return startBefore;
		function startBefore(code$4) {
			return effects$1.enter("lineEnding"), effects$1.consume(code$4), effects$1.exit("lineEnding"), start$1;
		}
		function start$1(code$4) {
			return effects$1.enter("codeFencedFence"), markdownSpace(code$4) ? factorySpace(effects$1, beforeSequenceClose, "linePrefix", self$1.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code$4) : beforeSequenceClose(code$4);
		}
		function beforeSequenceClose(code$4) {
			return code$4 === marker ? (effects$1.enter("codeFencedFenceSequence"), sequenceClose(code$4)) : nok$1(code$4);
		}
		function sequenceClose(code$4) {
			return code$4 === marker ? (size++, effects$1.consume(code$4), sequenceClose) : size >= sizeOpen ? (effects$1.exit("codeFencedFenceSequence"), markdownSpace(code$4) ? factorySpace(effects$1, sequenceCloseAfter, "whitespace")(code$4) : sequenceCloseAfter(code$4)) : nok$1(code$4);
		}
		function sequenceCloseAfter(code$4) {
			return code$4 === null || markdownLineEnding(code$4) ? (effects$1.exit("codeFencedFence"), ok$3(code$4)) : nok$1(code$4);
		}
	}
}
function tokenizeNonLazyContinuation(effects, ok$2, nok) {
	let self$1 = this;
	return start;
	function start(code$4) {
		return code$4 === null ? nok(code$4) : (effects.enter("lineEnding"), effects.consume(code$4), effects.exit("lineEnding"), lineStart);
	}
	function lineStart(code$4) {
		return self$1.parser.lazy[self$1.now().line] ? nok(code$4) : ok$2(code$4);
	}
}
const codeIndented = {
	name: "codeIndented",
	tokenize: tokenizeCodeIndented
};
var furtherStart = {
	partial: !0,
	tokenize: tokenizeFurtherStart
};
function tokenizeCodeIndented(effects, ok$2, nok) {
	let self$1 = this;
	return start;
	function start(code$4) {
		return effects.enter("codeIndented"), factorySpace(effects, afterPrefix, "linePrefix", 5)(code$4);
	}
	function afterPrefix(code$4) {
		let tail = self$1.events[self$1.events.length - 1];
		return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], !0).length >= 4 ? atBreak(code$4) : nok(code$4);
	}
	function atBreak(code$4) {
		return code$4 === null ? after(code$4) : markdownLineEnding(code$4) ? effects.attempt(furtherStart, atBreak, after)(code$4) : (effects.enter("codeFlowValue"), inside(code$4));
	}
	function inside(code$4) {
		return code$4 === null || markdownLineEnding(code$4) ? (effects.exit("codeFlowValue"), atBreak(code$4)) : (effects.consume(code$4), inside);
	}
	function after(code$4) {
		return effects.exit("codeIndented"), ok$2(code$4);
	}
}
function tokenizeFurtherStart(effects, ok$2, nok) {
	let self$1 = this;
	return furtherStart$1;
	function furtherStart$1(code$4) {
		return self$1.parser.lazy[self$1.now().line] ? nok(code$4) : markdownLineEnding(code$4) ? (effects.enter("lineEnding"), effects.consume(code$4), effects.exit("lineEnding"), furtherStart$1) : factorySpace(effects, afterPrefix, "linePrefix", 5)(code$4);
	}
	function afterPrefix(code$4) {
		let tail = self$1.events[self$1.events.length - 1];
		return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], !0).length >= 4 ? ok$2(code$4) : markdownLineEnding(code$4) ? furtherStart$1(code$4) : nok(code$4);
	}
}
const codeText = {
	name: "codeText",
	previous: previous$1,
	resolve: resolveCodeText,
	tokenize: tokenizeCodeText
};
function resolveCodeText(events) {
	let tailExitIndex = events.length - 4, headEnterIndex = 3, index$2, enter;
	if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
		for (index$2 = headEnterIndex; ++index$2 < tailExitIndex;) if (events[index$2][1].type === "codeTextData") {
			events[headEnterIndex][1].type = "codeTextPadding", events[tailExitIndex][1].type = "codeTextPadding", headEnterIndex += 2, tailExitIndex -= 2;
			break;
		}
	}
	for (index$2 = headEnterIndex - 1, tailExitIndex++; ++index$2 <= tailExitIndex;) enter === void 0 ? index$2 !== tailExitIndex && events[index$2][1].type !== "lineEnding" && (enter = index$2) : (index$2 === tailExitIndex || events[index$2][1].type === "lineEnding") && (events[enter][1].type = "codeTextData", index$2 !== enter + 2 && (events[enter][1].end = events[index$2 - 1][1].end, events.splice(enter + 2, index$2 - enter - 2), tailExitIndex -= index$2 - enter - 2, index$2 = enter + 2), enter = void 0);
	return events;
}
function previous$1(code$4) {
	return code$4 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeCodeText(effects, ok$2, nok) {
	let sizeOpen = 0, size, token;
	return start;
	function start(code$4) {
		return effects.enter("codeText"), effects.enter("codeTextSequence"), sequenceOpen(code$4);
	}
	function sequenceOpen(code$4) {
		return code$4 === 96 ? (effects.consume(code$4), sizeOpen++, sequenceOpen) : (effects.exit("codeTextSequence"), between(code$4));
	}
	function between(code$4) {
		return code$4 === null ? nok(code$4) : code$4 === 32 ? (effects.enter("space"), effects.consume(code$4), effects.exit("space"), between) : code$4 === 96 ? (token = effects.enter("codeTextSequence"), size = 0, sequenceClose(code$4)) : markdownLineEnding(code$4) ? (effects.enter("lineEnding"), effects.consume(code$4), effects.exit("lineEnding"), between) : (effects.enter("codeTextData"), data(code$4));
	}
	function data(code$4) {
		return code$4 === null || code$4 === 32 || code$4 === 96 || markdownLineEnding(code$4) ? (effects.exit("codeTextData"), between(code$4)) : (effects.consume(code$4), data);
	}
	function sequenceClose(code$4) {
		return code$4 === 96 ? (effects.consume(code$4), size++, sequenceClose) : size === sizeOpen ? (effects.exit("codeTextSequence"), effects.exit("codeText"), ok$2(code$4)) : (token.type = "codeTextData", data(code$4));
	}
}
var SpliceBuffer = class {
	constructor(initial) {
		this.left = initial ? [...initial] : [], this.right = [];
	}
	get(index$2) {
		if (index$2 < 0 || index$2 >= this.left.length + this.right.length) throw RangeError("Cannot access index `" + index$2 + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
		return index$2 < this.left.length ? this.left[index$2] : this.right[this.right.length - index$2 + this.left.length - 1];
	}
	get length() {
		return this.left.length + this.right.length;
	}
	shift() {
		return this.setCursor(0), this.right.pop();
	}
	slice(start, end) {
		let stop = end ?? Infinity;
		return stop < this.left.length ? this.left.slice(start, stop) : start > this.left.length ? this.right.slice(this.right.length - stop + this.left.length, this.right.length - start + this.left.length).reverse() : this.left.slice(start).concat(this.right.slice(this.right.length - stop + this.left.length).reverse());
	}
	splice(start, deleteCount, items) {
		let count = deleteCount || 0;
		this.setCursor(Math.trunc(start));
		let removed = this.right.splice(this.right.length - count, Infinity);
		return items && chunkedPush(this.left, items), removed.reverse();
	}
	pop() {
		return this.setCursor(Infinity), this.left.pop();
	}
	push(item) {
		this.setCursor(Infinity), this.left.push(item);
	}
	pushMany(items) {
		this.setCursor(Infinity), chunkedPush(this.left, items);
	}
	unshift(item) {
		this.setCursor(0), this.right.push(item);
	}
	unshiftMany(items) {
		this.setCursor(0), chunkedPush(this.right, items.reverse());
	}
	setCursor(n) {
		if (!(n === this.left.length || n > this.left.length && this.right.length === 0 || n < 0 && this.left.length === 0)) if (n < this.left.length) {
			let removed = this.left.splice(n, Infinity);
			chunkedPush(this.right, removed.reverse());
		} else {
			let removed = this.right.splice(this.left.length + this.right.length - n, Infinity);
			chunkedPush(this.left, removed.reverse());
		}
	}
};
function chunkedPush(list$3, right) {
	let chunkStart = 0;
	if (right.length < 1e4) list$3.push(...right);
	else for (; chunkStart < right.length;) list$3.push(...right.slice(chunkStart, chunkStart + 1e4)), chunkStart += 1e4;
}
function subtokenize(eventsArray) {
	let jumps = {}, index$2 = -1, event, lineIndex, otherIndex, otherEvent, parameters, subevents, more, events = new SpliceBuffer(eventsArray);
	for (; ++index$2 < events.length;) {
		for (; index$2 in jumps;) index$2 = jumps[index$2];
		if (event = events.get(index$2), index$2 && event[1].type === "chunkFlow" && events.get(index$2 - 1)[1].type === "listItemPrefix" && (subevents = event[1]._tokenizer.events, otherIndex = 0, otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank" && (otherIndex += 2), otherIndex < subevents.length && subevents[otherIndex][1].type === "content")) for (; ++otherIndex < subevents.length && subevents[otherIndex][1].type !== "content";) subevents[otherIndex][1].type === "chunkText" && (subevents[otherIndex][1]._isInFirstContentOfListItem = !0, otherIndex++);
		if (event[0] === "enter") event[1].contentType && (Object.assign(jumps, subcontent(events, index$2)), index$2 = jumps[index$2], more = !0);
		else if (event[1]._container) {
			for (otherIndex = index$2, lineIndex = void 0; otherIndex--;) if (otherEvent = events.get(otherIndex), otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") otherEvent[0] === "enter" && (lineIndex && (events.get(lineIndex)[1].type = "lineEndingBlank"), otherEvent[1].type = "lineEnding", lineIndex = otherIndex);
			else if (!(otherEvent[1].type === "linePrefix" || otherEvent[1].type === "listItemIndent")) break;
			lineIndex && (event[1].end = { ...events.get(lineIndex)[1].start }, parameters = events.slice(lineIndex, index$2), parameters.unshift(event), events.splice(lineIndex, index$2 - lineIndex + 1, parameters));
		}
	}
	return splice(eventsArray, 0, Infinity, events.slice(0)), !more;
}
function subcontent(events, eventIndex) {
	let token = events.get(eventIndex)[1], context = events.get(eventIndex)[2], startPosition = eventIndex - 1, startPositions = [], tokenizer = token._tokenizer;
	tokenizer || (tokenizer = context.parser[token.contentType](token.start), token._contentTypeTextTrailing && (tokenizer._contentTypeTextTrailing = !0));
	let childEvents = tokenizer.events, jumps = [], gaps = {}, stream, previous$2, index$2 = -1, current = token, adjust = 0, start = 0, breaks = [start];
	for (; current;) {
		for (; events.get(++startPosition)[1] !== current;);
		startPositions.push(startPosition), current._tokenizer || (stream = context.sliceStream(current), current.next || stream.push(null), previous$2 && tokenizer.defineSkip(current.start), current._isInFirstContentOfListItem && (tokenizer._gfmTasklistFirstContentOfListItem = !0), tokenizer.write(stream), current._isInFirstContentOfListItem && (tokenizer._gfmTasklistFirstContentOfListItem = void 0)), previous$2 = current, current = current.next;
	}
	for (current = token; ++index$2 < childEvents.length;) childEvents[index$2][0] === "exit" && childEvents[index$2 - 1][0] === "enter" && childEvents[index$2][1].type === childEvents[index$2 - 1][1].type && childEvents[index$2][1].start.line !== childEvents[index$2][1].end.line && (start = index$2 + 1, breaks.push(start), current._tokenizer = void 0, current.previous = void 0, current = current.next);
	for (tokenizer.events = [], current ? (current._tokenizer = void 0, current.previous = void 0) : breaks.pop(), index$2 = breaks.length; index$2--;) {
		let slice = childEvents.slice(breaks[index$2], breaks[index$2 + 1]), start$1 = startPositions.pop();
		jumps.push([start$1, start$1 + slice.length - 1]), events.splice(start$1, 2, slice);
	}
	for (jumps.reverse(), index$2 = -1; ++index$2 < jumps.length;) gaps[adjust + jumps[index$2][0]] = adjust + jumps[index$2][1], adjust += jumps[index$2][1] - jumps[index$2][0] - 1;
	return gaps;
}
const content$1 = {
	resolve: resolveContent,
	tokenize: tokenizeContent
};
var continuationConstruct = {
	partial: !0,
	tokenize: tokenizeContinuation
};
function resolveContent(events) {
	return subtokenize(events), events;
}
function tokenizeContent(effects, ok$2) {
	let previous$2;
	return chunkStart;
	function chunkStart(code$4) {
		return effects.enter("content"), previous$2 = effects.enter("chunkContent", { contentType: "content" }), chunkInside(code$4);
	}
	function chunkInside(code$4) {
		return code$4 === null ? contentEnd(code$4) : markdownLineEnding(code$4) ? effects.check(continuationConstruct, contentContinue, contentEnd)(code$4) : (effects.consume(code$4), chunkInside);
	}
	function contentEnd(code$4) {
		return effects.exit("chunkContent"), effects.exit("content"), ok$2(code$4);
	}
	function contentContinue(code$4) {
		return effects.consume(code$4), effects.exit("chunkContent"), previous$2.next = effects.enter("chunkContent", {
			contentType: "content",
			previous: previous$2
		}), previous$2 = previous$2.next, chunkInside;
	}
}
function tokenizeContinuation(effects, ok$2, nok) {
	let self$1 = this;
	return startLookahead;
	function startLookahead(code$4) {
		return effects.exit("chunkContent"), effects.enter("lineEnding"), effects.consume(code$4), effects.exit("lineEnding"), factorySpace(effects, prefixed, "linePrefix");
	}
	function prefixed(code$4) {
		if (code$4 === null || markdownLineEnding(code$4)) return nok(code$4);
		let tail = self$1.events[self$1.events.length - 1];
		return !self$1.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], !0).length >= 4 ? ok$2(code$4) : effects.interrupt(self$1.parser.constructs.flow, nok, ok$2)(code$4);
	}
}
function factoryDestination(effects, ok$2, nok, type, literalType, literalMarkerType, rawType, stringType, max) {
	let limit = max || Infinity, balance = 0;
	return start;
	function start(code$4) {
		return code$4 === 60 ? (effects.enter(type), effects.enter(literalType), effects.enter(literalMarkerType), effects.consume(code$4), effects.exit(literalMarkerType), enclosedBefore) : code$4 === null || code$4 === 32 || code$4 === 41 || asciiControl(code$4) ? nok(code$4) : (effects.enter(type), effects.enter(rawType), effects.enter(stringType), effects.enter("chunkString", { contentType: "string" }), raw(code$4));
	}
	function enclosedBefore(code$4) {
		return code$4 === 62 ? (effects.enter(literalMarkerType), effects.consume(code$4), effects.exit(literalMarkerType), effects.exit(literalType), effects.exit(type), ok$2) : (effects.enter(stringType), effects.enter("chunkString", { contentType: "string" }), enclosed(code$4));
	}
	function enclosed(code$4) {
		return code$4 === 62 ? (effects.exit("chunkString"), effects.exit(stringType), enclosedBefore(code$4)) : code$4 === null || code$4 === 60 || markdownLineEnding(code$4) ? nok(code$4) : (effects.consume(code$4), code$4 === 92 ? enclosedEscape : enclosed);
	}
	function enclosedEscape(code$4) {
		return code$4 === 60 || code$4 === 62 || code$4 === 92 ? (effects.consume(code$4), enclosed) : enclosed(code$4);
	}
	function raw(code$4) {
		return !balance && (code$4 === null || code$4 === 41 || markdownLineEndingOrSpace(code$4)) ? (effects.exit("chunkString"), effects.exit(stringType), effects.exit(rawType), effects.exit(type), ok$2(code$4)) : balance < limit && code$4 === 40 ? (effects.consume(code$4), balance++, raw) : code$4 === 41 ? (effects.consume(code$4), balance--, raw) : code$4 === null || code$4 === 32 || code$4 === 40 || asciiControl(code$4) ? nok(code$4) : (effects.consume(code$4), code$4 === 92 ? rawEscape : raw);
	}
	function rawEscape(code$4) {
		return code$4 === 40 || code$4 === 41 || code$4 === 92 ? (effects.consume(code$4), raw) : raw(code$4);
	}
}
function factoryLabel(effects, ok$2, nok, type, markerType, stringType) {
	let self$1 = this, size = 0, seen;
	return start;
	function start(code$4) {
		return effects.enter(type), effects.enter(markerType), effects.consume(code$4), effects.exit(markerType), effects.enter(stringType), atBreak;
	}
	function atBreak(code$4) {
		return size > 999 || code$4 === null || code$4 === 91 || code$4 === 93 && !seen || code$4 === 94 && !size && "_hiddenFootnoteSupport" in self$1.parser.constructs ? nok(code$4) : code$4 === 93 ? (effects.exit(stringType), effects.enter(markerType), effects.consume(code$4), effects.exit(markerType), effects.exit(type), ok$2) : markdownLineEnding(code$4) ? (effects.enter("lineEnding"), effects.consume(code$4), effects.exit("lineEnding"), atBreak) : (effects.enter("chunkString", { contentType: "string" }), labelInside(code$4));
	}
	function labelInside(code$4) {
		return code$4 === null || code$4 === 91 || code$4 === 93 || markdownLineEnding(code$4) || size++ > 999 ? (effects.exit("chunkString"), atBreak(code$4)) : (effects.consume(code$4), seen ||= !markdownSpace(code$4), code$4 === 92 ? labelEscape : labelInside);
	}
	function labelEscape(code$4) {
		return code$4 === 91 || code$4 === 92 || code$4 === 93 ? (effects.consume(code$4), size++, labelInside) : labelInside(code$4);
	}
}
function factoryTitle(effects, ok$2, nok, type, markerType, stringType) {
	let marker;
	return start;
	function start(code$4) {
		return code$4 === 34 || code$4 === 39 || code$4 === 40 ? (effects.enter(type), effects.enter(markerType), effects.consume(code$4), effects.exit(markerType), marker = code$4 === 40 ? 41 : code$4, begin) : nok(code$4);
	}
	function begin(code$4) {
		return code$4 === marker ? (effects.enter(markerType), effects.consume(code$4), effects.exit(markerType), effects.exit(type), ok$2) : (effects.enter(stringType), atBreak(code$4));
	}
	function atBreak(code$4) {
		return code$4 === marker ? (effects.exit(stringType), begin(marker)) : code$4 === null ? nok(code$4) : markdownLineEnding(code$4) ? (effects.enter("lineEnding"), effects.consume(code$4), effects.exit("lineEnding"), factorySpace(effects, atBreak, "linePrefix")) : (effects.enter("chunkString", { contentType: "string" }), inside(code$4));
	}
	function inside(code$4) {
		return code$4 === marker || code$4 === null || markdownLineEnding(code$4) ? (effects.exit("chunkString"), atBreak(code$4)) : (effects.consume(code$4), code$4 === 92 ? escape$1 : inside);
	}
	function escape$1(code$4) {
		return code$4 === marker || code$4 === 92 ? (effects.consume(code$4), inside) : inside(code$4);
	}
}
function factoryWhitespace(effects, ok$2) {
	let seen;
	return start;
	function start(code$4) {
		return markdownLineEnding(code$4) ? (effects.enter("lineEnding"), effects.consume(code$4), effects.exit("lineEnding"), seen = !0, start) : markdownSpace(code$4) ? factorySpace(effects, start, seen ? "linePrefix" : "lineSuffix")(code$4) : ok$2(code$4);
	}
}
const definition$1 = {
	name: "definition",
	tokenize: tokenizeDefinition
};
var titleBefore = {
	partial: !0,
	tokenize: tokenizeTitleBefore
};
function tokenizeDefinition(effects, ok$2, nok) {
	let self$1 = this, identifier$1;
	return start;
	function start(code$4) {
		return effects.enter("definition"), before(code$4);
	}
	function before(code$4) {
		return factoryLabel.call(self$1, effects, labelAfter, nok, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(code$4);
	}
	function labelAfter(code$4) {
		return identifier$1 = normalizeIdentifier(self$1.sliceSerialize(self$1.events[self$1.events.length - 1][1]).slice(1, -1)), code$4 === 58 ? (effects.enter("definitionMarker"), effects.consume(code$4), effects.exit("definitionMarker"), markerAfter) : nok(code$4);
	}
	function markerAfter(code$4) {
		return markdownLineEndingOrSpace(code$4) ? factoryWhitespace(effects, destinationBefore)(code$4) : destinationBefore(code$4);
	}
	function destinationBefore(code$4) {
		return factoryDestination(effects, destinationAfter, nok, "definitionDestination", "definitionDestinationLiteral", "definitionDestinationLiteralMarker", "definitionDestinationRaw", "definitionDestinationString")(code$4);
	}
	function destinationAfter(code$4) {
		return effects.attempt(titleBefore, after, after)(code$4);
	}
	function after(code$4) {
		return markdownSpace(code$4) ? factorySpace(effects, afterWhitespace, "whitespace")(code$4) : afterWhitespace(code$4);
	}
	function afterWhitespace(code$4) {
		return code$4 === null || markdownLineEnding(code$4) ? (effects.exit("definition"), self$1.parser.defined.push(identifier$1), ok$2(code$4)) : nok(code$4);
	}
}
function tokenizeTitleBefore(effects, ok$2, nok) {
	return titleBefore$1;
	function titleBefore$1(code$4) {
		return markdownLineEndingOrSpace(code$4) ? factoryWhitespace(effects, beforeMarker)(code$4) : nok(code$4);
	}
	function beforeMarker(code$4) {
		return factoryTitle(effects, titleAfter, nok, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(code$4);
	}
	function titleAfter(code$4) {
		return markdownSpace(code$4) ? factorySpace(effects, titleAfterOptionalWhitespace, "whitespace")(code$4) : titleAfterOptionalWhitespace(code$4);
	}
	function titleAfterOptionalWhitespace(code$4) {
		return code$4 === null || markdownLineEnding(code$4) ? ok$2(code$4) : nok(code$4);
	}
}
const hardBreakEscape = {
	name: "hardBreakEscape",
	tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok$2, nok) {
	return start;
	function start(code$4) {
		return effects.enter("hardBreakEscape"), effects.consume(code$4), after;
	}
	function after(code$4) {
		return markdownLineEnding(code$4) ? (effects.exit("hardBreakEscape"), ok$2(code$4)) : nok(code$4);
	}
}
const headingAtx = {
	name: "headingAtx",
	resolve: resolveHeadingAtx,
	tokenize: tokenizeHeadingAtx
};
function resolveHeadingAtx(events, context) {
	let contentEnd = events.length - 2, contentStart = 3, content$2, text$6;
	return events[contentStart][1].type === "whitespace" && (contentStart += 2), contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace" && (contentEnd -= 2), events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace") && (contentEnd -= contentStart + 1 === contentEnd ? 2 : 4), contentEnd > contentStart && (content$2 = {
		type: "atxHeadingText",
		start: events[contentStart][1].start,
		end: events[contentEnd][1].end
	}, text$6 = {
		type: "chunkText",
		start: events[contentStart][1].start,
		end: events[contentEnd][1].end,
		contentType: "text"
	}, splice(events, contentStart, contentEnd - contentStart + 1, [
		[
			"enter",
			content$2,
			context
		],
		[
			"enter",
			text$6,
			context
		],
		[
			"exit",
			text$6,
			context
		],
		[
			"exit",
			content$2,
			context
		]
	])), events;
}
function tokenizeHeadingAtx(effects, ok$2, nok) {
	let size = 0;
	return start;
	function start(code$4) {
		return effects.enter("atxHeading"), before(code$4);
	}
	function before(code$4) {
		return effects.enter("atxHeadingSequence"), sequenceOpen(code$4);
	}
	function sequenceOpen(code$4) {
		return code$4 === 35 && size++ < 6 ? (effects.consume(code$4), sequenceOpen) : code$4 === null || markdownLineEndingOrSpace(code$4) ? (effects.exit("atxHeadingSequence"), atBreak(code$4)) : nok(code$4);
	}
	function atBreak(code$4) {
		return code$4 === 35 ? (effects.enter("atxHeadingSequence"), sequenceFurther(code$4)) : code$4 === null || markdownLineEnding(code$4) ? (effects.exit("atxHeading"), ok$2(code$4)) : markdownSpace(code$4) ? factorySpace(effects, atBreak, "whitespace")(code$4) : (effects.enter("atxHeadingText"), data(code$4));
	}
	function sequenceFurther(code$4) {
		return code$4 === 35 ? (effects.consume(code$4), sequenceFurther) : (effects.exit("atxHeadingSequence"), atBreak(code$4));
	}
	function data(code$4) {
		return code$4 === null || code$4 === 35 || markdownLineEndingOrSpace(code$4) ? (effects.exit("atxHeadingText"), atBreak(code$4)) : (effects.consume(code$4), data);
	}
}
const htmlBlockNames = /* @__PURE__ */ "address.article.aside.base.basefont.blockquote.body.caption.center.col.colgroup.dd.details.dialog.dir.div.dl.dt.fieldset.figcaption.figure.footer.form.frame.frameset.h1.h2.h3.h4.h5.h6.head.header.hr.html.iframe.legend.li.link.main.menu.menuitem.nav.noframes.ol.optgroup.option.p.param.search.section.summary.table.tbody.td.tfoot.th.thead.title.tr.track.ul".split("."), htmlRawNames = [
	"pre",
	"script",
	"style",
	"textarea"
], htmlFlow = {
	concrete: !0,
	name: "htmlFlow",
	resolveTo: resolveToHtmlFlow,
	tokenize: tokenizeHtmlFlow
};
var blankLineBefore = {
	partial: !0,
	tokenize: tokenizeBlankLineBefore
}, nonLazyContinuationStart = {
	partial: !0,
	tokenize: tokenizeNonLazyContinuationStart
};
function resolveToHtmlFlow(events) {
	let index$2 = events.length;
	for (; index$2-- && !(events[index$2][0] === "enter" && events[index$2][1].type === "htmlFlow"););
	return index$2 > 1 && events[index$2 - 2][1].type === "linePrefix" && (events[index$2][1].start = events[index$2 - 2][1].start, events[index$2 + 1][1].start = events[index$2 - 2][1].start, events.splice(index$2 - 2, 2)), events;
}
function tokenizeHtmlFlow(effects, ok$2, nok) {
	let self$1 = this, marker, closingTag, buffer, index$2, markerB;
	return start;
	function start(code$4) {
		return before(code$4);
	}
	function before(code$4) {
		return effects.enter("htmlFlow"), effects.enter("htmlFlowData"), effects.consume(code$4), open;
	}
	function open(code$4) {
		return code$4 === 33 ? (effects.consume(code$4), declarationOpen) : code$4 === 47 ? (effects.consume(code$4), closingTag = !0, tagCloseStart) : code$4 === 63 ? (effects.consume(code$4), marker = 3, self$1.interrupt ? ok$2 : continuationDeclarationInside) : asciiAlpha(code$4) ? (effects.consume(code$4), buffer = String.fromCharCode(code$4), tagName) : nok(code$4);
	}
	function declarationOpen(code$4) {
		return code$4 === 45 ? (effects.consume(code$4), marker = 2, commentOpenInside) : code$4 === 91 ? (effects.consume(code$4), marker = 5, index$2 = 0, cdataOpenInside) : asciiAlpha(code$4) ? (effects.consume(code$4), marker = 4, self$1.interrupt ? ok$2 : continuationDeclarationInside) : nok(code$4);
	}
	function commentOpenInside(code$4) {
		return code$4 === 45 ? (effects.consume(code$4), self$1.interrupt ? ok$2 : continuationDeclarationInside) : nok(code$4);
	}
	function cdataOpenInside(code$4) {
		return code$4 === "CDATA[".charCodeAt(index$2++) ? (effects.consume(code$4), index$2 === 6 ? self$1.interrupt ? ok$2 : continuation : cdataOpenInside) : nok(code$4);
	}
	function tagCloseStart(code$4) {
		return asciiAlpha(code$4) ? (effects.consume(code$4), buffer = String.fromCharCode(code$4), tagName) : nok(code$4);
	}
	function tagName(code$4) {
		if (code$4 === null || code$4 === 47 || code$4 === 62 || markdownLineEndingOrSpace(code$4)) {
			let slash = code$4 === 47, name$1 = buffer.toLowerCase();
			return !slash && !closingTag && htmlRawNames.includes(name$1) ? (marker = 1, self$1.interrupt ? ok$2(code$4) : continuation(code$4)) : htmlBlockNames.includes(buffer.toLowerCase()) ? (marker = 6, slash ? (effects.consume(code$4), basicSelfClosing) : self$1.interrupt ? ok$2(code$4) : continuation(code$4)) : (marker = 7, self$1.interrupt && !self$1.parser.lazy[self$1.now().line] ? nok(code$4) : closingTag ? completeClosingTagAfter(code$4) : completeAttributeNameBefore(code$4));
		}
		return code$4 === 45 || asciiAlphanumeric(code$4) ? (effects.consume(code$4), buffer += String.fromCharCode(code$4), tagName) : nok(code$4);
	}
	function basicSelfClosing(code$4) {
		return code$4 === 62 ? (effects.consume(code$4), self$1.interrupt ? ok$2 : continuation) : nok(code$4);
	}
	function completeClosingTagAfter(code$4) {
		return markdownSpace(code$4) ? (effects.consume(code$4), completeClosingTagAfter) : completeEnd(code$4);
	}
	function completeAttributeNameBefore(code$4) {
		return code$4 === 47 ? (effects.consume(code$4), completeEnd) : code$4 === 58 || code$4 === 95 || asciiAlpha(code$4) ? (effects.consume(code$4), completeAttributeName) : markdownSpace(code$4) ? (effects.consume(code$4), completeAttributeNameBefore) : completeEnd(code$4);
	}
	function completeAttributeName(code$4) {
		return code$4 === 45 || code$4 === 46 || code$4 === 58 || code$4 === 95 || asciiAlphanumeric(code$4) ? (effects.consume(code$4), completeAttributeName) : completeAttributeNameAfter(code$4);
	}
	function completeAttributeNameAfter(code$4) {
		return code$4 === 61 ? (effects.consume(code$4), completeAttributeValueBefore) : markdownSpace(code$4) ? (effects.consume(code$4), completeAttributeNameAfter) : completeAttributeNameBefore(code$4);
	}
	function completeAttributeValueBefore(code$4) {
		return code$4 === null || code$4 === 60 || code$4 === 61 || code$4 === 62 || code$4 === 96 ? nok(code$4) : code$4 === 34 || code$4 === 39 ? (effects.consume(code$4), markerB = code$4, completeAttributeValueQuoted) : markdownSpace(code$4) ? (effects.consume(code$4), completeAttributeValueBefore) : completeAttributeValueUnquoted(code$4);
	}
	function completeAttributeValueQuoted(code$4) {
		return code$4 === markerB ? (effects.consume(code$4), markerB = null, completeAttributeValueQuotedAfter) : code$4 === null || markdownLineEnding(code$4) ? nok(code$4) : (effects.consume(code$4), completeAttributeValueQuoted);
	}
	function completeAttributeValueUnquoted(code$4) {
		return code$4 === null || code$4 === 34 || code$4 === 39 || code$4 === 47 || code$4 === 60 || code$4 === 61 || code$4 === 62 || code$4 === 96 || markdownLineEndingOrSpace(code$4) ? completeAttributeNameAfter(code$4) : (effects.consume(code$4), completeAttributeValueUnquoted);
	}
	function completeAttributeValueQuotedAfter(code$4) {
		return code$4 === 47 || code$4 === 62 || markdownSpace(code$4) ? completeAttributeNameBefore(code$4) : nok(code$4);
	}
	function completeEnd(code$4) {
		return code$4 === 62 ? (effects.consume(code$4), completeAfter) : nok(code$4);
	}
	function completeAfter(code$4) {
		return code$4 === null || markdownLineEnding(code$4) ? continuation(code$4) : markdownSpace(code$4) ? (effects.consume(code$4), completeAfter) : nok(code$4);
	}
	function continuation(code$4) {
		return code$4 === 45 && marker === 2 ? (effects.consume(code$4), continuationCommentInside) : code$4 === 60 && marker === 1 ? (effects.consume(code$4), continuationRawTagOpen) : code$4 === 62 && marker === 4 ? (effects.consume(code$4), continuationClose) : code$4 === 63 && marker === 3 ? (effects.consume(code$4), continuationDeclarationInside) : code$4 === 93 && marker === 5 ? (effects.consume(code$4), continuationCdataInside) : markdownLineEnding(code$4) && (marker === 6 || marker === 7) ? (effects.exit("htmlFlowData"), effects.check(blankLineBefore, continuationAfter, continuationStart)(code$4)) : code$4 === null || markdownLineEnding(code$4) ? (effects.exit("htmlFlowData"), continuationStart(code$4)) : (effects.consume(code$4), continuation);
	}
	function continuationStart(code$4) {
		return effects.check(nonLazyContinuationStart, continuationStartNonLazy, continuationAfter)(code$4);
	}
	function continuationStartNonLazy(code$4) {
		return effects.enter("lineEnding"), effects.consume(code$4), effects.exit("lineEnding"), continuationBefore;
	}
	function continuationBefore(code$4) {
		return code$4 === null || markdownLineEnding(code$4) ? continuationStart(code$4) : (effects.enter("htmlFlowData"), continuation(code$4));
	}
	function continuationCommentInside(code$4) {
		return code$4 === 45 ? (effects.consume(code$4), continuationDeclarationInside) : continuation(code$4);
	}
	function continuationRawTagOpen(code$4) {
		return code$4 === 47 ? (effects.consume(code$4), buffer = "", continuationRawEndTag) : continuation(code$4);
	}
	function continuationRawEndTag(code$4) {
		if (code$4 === 62) {
			let name$1 = buffer.toLowerCase();
			return htmlRawNames.includes(name$1) ? (effects.consume(code$4), continuationClose) : continuation(code$4);
		}
		return asciiAlpha(code$4) && buffer.length < 8 ? (effects.consume(code$4), buffer += String.fromCharCode(code$4), continuationRawEndTag) : continuation(code$4);
	}
	function continuationCdataInside(code$4) {
		return code$4 === 93 ? (effects.consume(code$4), continuationDeclarationInside) : continuation(code$4);
	}
	function continuationDeclarationInside(code$4) {
		return code$4 === 62 ? (effects.consume(code$4), continuationClose) : code$4 === 45 && marker === 2 ? (effects.consume(code$4), continuationDeclarationInside) : continuation(code$4);
	}
	function continuationClose(code$4) {
		return code$4 === null || markdownLineEnding(code$4) ? (effects.exit("htmlFlowData"), continuationAfter(code$4)) : (effects.consume(code$4), continuationClose);
	}
	function continuationAfter(code$4) {
		return effects.exit("htmlFlow"), ok$2(code$4);
	}
}
function tokenizeNonLazyContinuationStart(effects, ok$2, nok) {
	let self$1 = this;
	return start;
	function start(code$4) {
		return markdownLineEnding(code$4) ? (effects.enter("lineEnding"), effects.consume(code$4), effects.exit("lineEnding"), after) : nok(code$4);
	}
	function after(code$4) {
		return self$1.parser.lazy[self$1.now().line] ? nok(code$4) : ok$2(code$4);
	}
}
function tokenizeBlankLineBefore(effects, ok$2, nok) {
	return start;
	function start(code$4) {
		return effects.enter("lineEnding"), effects.consume(code$4), effects.exit("lineEnding"), effects.attempt(blankLine, ok$2, nok);
	}
}
const htmlText = {
	name: "htmlText",
	tokenize: tokenizeHtmlText
};
function tokenizeHtmlText(effects, ok$2, nok) {
	let self$1 = this, marker, index$2, returnState;
	return start;
	function start(code$4) {
		return effects.enter("htmlText"), effects.enter("htmlTextData"), effects.consume(code$4), open;
	}
	function open(code$4) {
		return code$4 === 33 ? (effects.consume(code$4), declarationOpen) : code$4 === 47 ? (effects.consume(code$4), tagCloseStart) : code$4 === 63 ? (effects.consume(code$4), instruction) : asciiAlpha(code$4) ? (effects.consume(code$4), tagOpen) : nok(code$4);
	}
	function declarationOpen(code$4) {
		return code$4 === 45 ? (effects.consume(code$4), commentOpenInside) : code$4 === 91 ? (effects.consume(code$4), index$2 = 0, cdataOpenInside) : asciiAlpha(code$4) ? (effects.consume(code$4), declaration) : nok(code$4);
	}
	function commentOpenInside(code$4) {
		return code$4 === 45 ? (effects.consume(code$4), commentEnd) : nok(code$4);
	}
	function comment(code$4) {
		return code$4 === null ? nok(code$4) : code$4 === 45 ? (effects.consume(code$4), commentClose) : markdownLineEnding(code$4) ? (returnState = comment, lineEndingBefore(code$4)) : (effects.consume(code$4), comment);
	}
	function commentClose(code$4) {
		return code$4 === 45 ? (effects.consume(code$4), commentEnd) : comment(code$4);
	}
	function commentEnd(code$4) {
		return code$4 === 62 ? end(code$4) : code$4 === 45 ? commentClose(code$4) : comment(code$4);
	}
	function cdataOpenInside(code$4) {
		return code$4 === "CDATA[".charCodeAt(index$2++) ? (effects.consume(code$4), index$2 === 6 ? cdata : cdataOpenInside) : nok(code$4);
	}
	function cdata(code$4) {
		return code$4 === null ? nok(code$4) : code$4 === 93 ? (effects.consume(code$4), cdataClose) : markdownLineEnding(code$4) ? (returnState = cdata, lineEndingBefore(code$4)) : (effects.consume(code$4), cdata);
	}
	function cdataClose(code$4) {
		return code$4 === 93 ? (effects.consume(code$4), cdataEnd) : cdata(code$4);
	}
	function cdataEnd(code$4) {
		return code$4 === 62 ? end(code$4) : code$4 === 93 ? (effects.consume(code$4), cdataEnd) : cdata(code$4);
	}
	function declaration(code$4) {
		return code$4 === null || code$4 === 62 ? end(code$4) : markdownLineEnding(code$4) ? (returnState = declaration, lineEndingBefore(code$4)) : (effects.consume(code$4), declaration);
	}
	function instruction(code$4) {
		return code$4 === null ? nok(code$4) : code$4 === 63 ? (effects.consume(code$4), instructionClose) : markdownLineEnding(code$4) ? (returnState = instruction, lineEndingBefore(code$4)) : (effects.consume(code$4), instruction);
	}
	function instructionClose(code$4) {
		return code$4 === 62 ? end(code$4) : instruction(code$4);
	}
	function tagCloseStart(code$4) {
		return asciiAlpha(code$4) ? (effects.consume(code$4), tagClose) : nok(code$4);
	}
	function tagClose(code$4) {
		return code$4 === 45 || asciiAlphanumeric(code$4) ? (effects.consume(code$4), tagClose) : tagCloseBetween(code$4);
	}
	function tagCloseBetween(code$4) {
		return markdownLineEnding(code$4) ? (returnState = tagCloseBetween, lineEndingBefore(code$4)) : markdownSpace(code$4) ? (effects.consume(code$4), tagCloseBetween) : end(code$4);
	}
	function tagOpen(code$4) {
		return code$4 === 45 || asciiAlphanumeric(code$4) ? (effects.consume(code$4), tagOpen) : code$4 === 47 || code$4 === 62 || markdownLineEndingOrSpace(code$4) ? tagOpenBetween(code$4) : nok(code$4);
	}
	function tagOpenBetween(code$4) {
		return code$4 === 47 ? (effects.consume(code$4), end) : code$4 === 58 || code$4 === 95 || asciiAlpha(code$4) ? (effects.consume(code$4), tagOpenAttributeName) : markdownLineEnding(code$4) ? (returnState = tagOpenBetween, lineEndingBefore(code$4)) : markdownSpace(code$4) ? (effects.consume(code$4), tagOpenBetween) : end(code$4);
	}
	function tagOpenAttributeName(code$4) {
		return code$4 === 45 || code$4 === 46 || code$4 === 58 || code$4 === 95 || asciiAlphanumeric(code$4) ? (effects.consume(code$4), tagOpenAttributeName) : tagOpenAttributeNameAfter(code$4);
	}
	function tagOpenAttributeNameAfter(code$4) {
		return code$4 === 61 ? (effects.consume(code$4), tagOpenAttributeValueBefore) : markdownLineEnding(code$4) ? (returnState = tagOpenAttributeNameAfter, lineEndingBefore(code$4)) : markdownSpace(code$4) ? (effects.consume(code$4), tagOpenAttributeNameAfter) : tagOpenBetween(code$4);
	}
	function tagOpenAttributeValueBefore(code$4) {
		return code$4 === null || code$4 === 60 || code$4 === 61 || code$4 === 62 || code$4 === 96 ? nok(code$4) : code$4 === 34 || code$4 === 39 ? (effects.consume(code$4), marker = code$4, tagOpenAttributeValueQuoted) : markdownLineEnding(code$4) ? (returnState = tagOpenAttributeValueBefore, lineEndingBefore(code$4)) : markdownSpace(code$4) ? (effects.consume(code$4), tagOpenAttributeValueBefore) : (effects.consume(code$4), tagOpenAttributeValueUnquoted);
	}
	function tagOpenAttributeValueQuoted(code$4) {
		return code$4 === marker ? (effects.consume(code$4), marker = void 0, tagOpenAttributeValueQuotedAfter) : code$4 === null ? nok(code$4) : markdownLineEnding(code$4) ? (returnState = tagOpenAttributeValueQuoted, lineEndingBefore(code$4)) : (effects.consume(code$4), tagOpenAttributeValueQuoted);
	}
	function tagOpenAttributeValueUnquoted(code$4) {
		return code$4 === null || code$4 === 34 || code$4 === 39 || code$4 === 60 || code$4 === 61 || code$4 === 96 ? nok(code$4) : code$4 === 47 || code$4 === 62 || markdownLineEndingOrSpace(code$4) ? tagOpenBetween(code$4) : (effects.consume(code$4), tagOpenAttributeValueUnquoted);
	}
	function tagOpenAttributeValueQuotedAfter(code$4) {
		return code$4 === 47 || code$4 === 62 || markdownLineEndingOrSpace(code$4) ? tagOpenBetween(code$4) : nok(code$4);
	}
	function end(code$4) {
		return code$4 === 62 ? (effects.consume(code$4), effects.exit("htmlTextData"), effects.exit("htmlText"), ok$2) : nok(code$4);
	}
	function lineEndingBefore(code$4) {
		return effects.exit("htmlTextData"), effects.enter("lineEnding"), effects.consume(code$4), effects.exit("lineEnding"), lineEndingAfter;
	}
	function lineEndingAfter(code$4) {
		return markdownSpace(code$4) ? factorySpace(effects, lineEndingAfterPrefix, "linePrefix", self$1.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code$4) : lineEndingAfterPrefix(code$4);
	}
	function lineEndingAfterPrefix(code$4) {
		return effects.enter("htmlTextData"), returnState(code$4);
	}
}
const labelEnd = {
	name: "labelEnd",
	resolveAll: resolveAllLabelEnd,
	resolveTo: resolveToLabelEnd,
	tokenize: tokenizeLabelEnd
};
var resourceConstruct = { tokenize: tokenizeResource }, referenceFullConstruct = { tokenize: tokenizeReferenceFull }, referenceCollapsedConstruct = { tokenize: tokenizeReferenceCollapsed };
function resolveAllLabelEnd(events) {
	let index$2 = -1, newEvents = [];
	for (; ++index$2 < events.length;) {
		let token = events[index$2][1];
		if (newEvents.push(events[index$2]), token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd") {
			let offset = token.type === "labelImage" ? 4 : 2;
			token.type = "data", index$2 += offset;
		}
	}
	return events.length !== newEvents.length && splice(events, 0, events.length, newEvents), events;
}
function resolveToLabelEnd(events, context) {
	let index$2 = events.length, offset = 0, token, open, close, media;
	for (; index$2--;) if (token = events[index$2][1], open) {
		if (token.type === "link" || token.type === "labelLink" && token._inactive) break;
		events[index$2][0] === "enter" && token.type === "labelLink" && (token._inactive = !0);
	} else if (close) {
		if (events[index$2][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced && (open = index$2, token.type !== "labelLink")) {
			offset = 2;
			break;
		}
	} else token.type === "labelEnd" && (close = index$2);
	let group = {
		type: events[open][1].type === "labelLink" ? "link" : "image",
		start: { ...events[open][1].start },
		end: { ...events[events.length - 1][1].end }
	}, label = {
		type: "label",
		start: { ...events[open][1].start },
		end: { ...events[close][1].end }
	}, text$6 = {
		type: "labelText",
		start: { ...events[open + offset + 2][1].end },
		end: { ...events[close - 2][1].start }
	};
	return media = [[
		"enter",
		group,
		context
	], [
		"enter",
		label,
		context
	]], media = push(media, events.slice(open + 1, open + offset + 3)), media = push(media, [[
		"enter",
		text$6,
		context
	]]), media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close - 3), context)), media = push(media, [
		[
			"exit",
			text$6,
			context
		],
		events[close - 2],
		events[close - 1],
		[
			"exit",
			label,
			context
		]
	]), media = push(media, events.slice(close + 1)), media = push(media, [[
		"exit",
		group,
		context
	]]), splice(events, open, events.length, media), events;
}
function tokenizeLabelEnd(effects, ok$2, nok) {
	let self$1 = this, index$2 = self$1.events.length, labelStart, defined;
	for (; index$2--;) if ((self$1.events[index$2][1].type === "labelImage" || self$1.events[index$2][1].type === "labelLink") && !self$1.events[index$2][1]._balanced) {
		labelStart = self$1.events[index$2][1];
		break;
	}
	return start;
	function start(code$4) {
		return labelStart ? labelStart._inactive ? labelEndNok(code$4) : (defined = self$1.parser.defined.includes(normalizeIdentifier(self$1.sliceSerialize({
			start: labelStart.end,
			end: self$1.now()
		}))), effects.enter("labelEnd"), effects.enter("labelMarker"), effects.consume(code$4), effects.exit("labelMarker"), effects.exit("labelEnd"), after) : nok(code$4);
	}
	function after(code$4) {
		return code$4 === 40 ? effects.attempt(resourceConstruct, labelEndOk, defined ? labelEndOk : labelEndNok)(code$4) : code$4 === 91 ? effects.attempt(referenceFullConstruct, labelEndOk, defined ? referenceNotFull : labelEndNok)(code$4) : defined ? labelEndOk(code$4) : labelEndNok(code$4);
	}
	function referenceNotFull(code$4) {
		return effects.attempt(referenceCollapsedConstruct, labelEndOk, labelEndNok)(code$4);
	}
	function labelEndOk(code$4) {
		return ok$2(code$4);
	}
	function labelEndNok(code$4) {
		return labelStart._balanced = !0, nok(code$4);
	}
}
function tokenizeResource(effects, ok$2, nok) {
	return resourceStart;
	function resourceStart(code$4) {
		return effects.enter("resource"), effects.enter("resourceMarker"), effects.consume(code$4), effects.exit("resourceMarker"), resourceBefore;
	}
	function resourceBefore(code$4) {
		return markdownLineEndingOrSpace(code$4) ? factoryWhitespace(effects, resourceOpen)(code$4) : resourceOpen(code$4);
	}
	function resourceOpen(code$4) {
		return code$4 === 41 ? resourceEnd(code$4) : factoryDestination(effects, resourceDestinationAfter, resourceDestinationMissing, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(code$4);
	}
	function resourceDestinationAfter(code$4) {
		return markdownLineEndingOrSpace(code$4) ? factoryWhitespace(effects, resourceBetween)(code$4) : resourceEnd(code$4);
	}
	function resourceDestinationMissing(code$4) {
		return nok(code$4);
	}
	function resourceBetween(code$4) {
		return code$4 === 34 || code$4 === 39 || code$4 === 40 ? factoryTitle(effects, resourceTitleAfter, nok, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(code$4) : resourceEnd(code$4);
	}
	function resourceTitleAfter(code$4) {
		return markdownLineEndingOrSpace(code$4) ? factoryWhitespace(effects, resourceEnd)(code$4) : resourceEnd(code$4);
	}
	function resourceEnd(code$4) {
		return code$4 === 41 ? (effects.enter("resourceMarker"), effects.consume(code$4), effects.exit("resourceMarker"), effects.exit("resource"), ok$2) : nok(code$4);
	}
}
function tokenizeReferenceFull(effects, ok$2, nok) {
	let self$1 = this;
	return referenceFull;
	function referenceFull(code$4) {
		return factoryLabel.call(self$1, effects, referenceFullAfter, referenceFullMissing, "reference", "referenceMarker", "referenceString")(code$4);
	}
	function referenceFullAfter(code$4) {
		return self$1.parser.defined.includes(normalizeIdentifier(self$1.sliceSerialize(self$1.events[self$1.events.length - 1][1]).slice(1, -1))) ? ok$2(code$4) : nok(code$4);
	}
	function referenceFullMissing(code$4) {
		return nok(code$4);
	}
}
function tokenizeReferenceCollapsed(effects, ok$2, nok) {
	return referenceCollapsedStart;
	function referenceCollapsedStart(code$4) {
		return effects.enter("reference"), effects.enter("referenceMarker"), effects.consume(code$4), effects.exit("referenceMarker"), referenceCollapsedOpen;
	}
	function referenceCollapsedOpen(code$4) {
		return code$4 === 93 ? (effects.enter("referenceMarker"), effects.consume(code$4), effects.exit("referenceMarker"), effects.exit("reference"), ok$2) : nok(code$4);
	}
}
const labelStartImage = {
	name: "labelStartImage",
	resolveAll: labelEnd.resolveAll,
	tokenize: tokenizeLabelStartImage
};
function tokenizeLabelStartImage(effects, ok$2, nok) {
	let self$1 = this;
	return start;
	function start(code$4) {
		return effects.enter("labelImage"), effects.enter("labelImageMarker"), effects.consume(code$4), effects.exit("labelImageMarker"), open;
	}
	function open(code$4) {
		return code$4 === 91 ? (effects.enter("labelMarker"), effects.consume(code$4), effects.exit("labelMarker"), effects.exit("labelImage"), after) : nok(code$4);
	}
	function after(code$4) {
		/* c8 ignore next 3 */
		return code$4 === 94 && "_hiddenFootnoteSupport" in self$1.parser.constructs ? nok(code$4) : ok$2(code$4);
	}
}
const labelStartLink = {
	name: "labelStartLink",
	resolveAll: labelEnd.resolveAll,
	tokenize: tokenizeLabelStartLink
};
function tokenizeLabelStartLink(effects, ok$2, nok) {
	let self$1 = this;
	return start;
	function start(code$4) {
		return effects.enter("labelLink"), effects.enter("labelMarker"), effects.consume(code$4), effects.exit("labelMarker"), effects.exit("labelLink"), after;
	}
	function after(code$4) {
		/* c8 ignore next 3 */
		return code$4 === 94 && "_hiddenFootnoteSupport" in self$1.parser.constructs ? nok(code$4) : ok$2(code$4);
	}
}
const lineEnding = {
	name: "lineEnding",
	tokenize: tokenizeLineEnding
};
function tokenizeLineEnding(effects, ok$2) {
	return start;
	function start(code$4) {
		return effects.enter("lineEnding"), effects.consume(code$4), effects.exit("lineEnding"), factorySpace(effects, ok$2, "linePrefix");
	}
}
const thematicBreak$2 = {
	name: "thematicBreak",
	tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok$2, nok) {
	let size = 0, marker;
	return start;
	function start(code$4) {
		return effects.enter("thematicBreak"), before(code$4);
	}
	function before(code$4) {
		return marker = code$4, atBreak(code$4);
	}
	function atBreak(code$4) {
		return code$4 === marker ? (effects.enter("thematicBreakSequence"), sequence(code$4)) : size >= 3 && (code$4 === null || markdownLineEnding(code$4)) ? (effects.exit("thematicBreak"), ok$2(code$4)) : nok(code$4);
	}
	function sequence(code$4) {
		return code$4 === marker ? (effects.consume(code$4), size++, sequence) : (effects.exit("thematicBreakSequence"), markdownSpace(code$4) ? factorySpace(effects, atBreak, "whitespace")(code$4) : atBreak(code$4));
	}
}
const list$2 = {
	continuation: { tokenize: tokenizeListContinuation },
	exit: tokenizeListEnd,
	name: "list",
	tokenize: tokenizeListStart
};
var listItemPrefixWhitespaceConstruct = {
	partial: !0,
	tokenize: tokenizeListItemPrefixWhitespace
}, indentConstruct = {
	partial: !0,
	tokenize: tokenizeIndent$1
};
function tokenizeListStart(effects, ok$2, nok) {
	let self$1 = this, tail = self$1.events[self$1.events.length - 1], initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], !0).length : 0, size = 0;
	return start;
	function start(code$4) {
		let kind = self$1.containerState.type || (code$4 === 42 || code$4 === 43 || code$4 === 45 ? "listUnordered" : "listOrdered");
		if (kind === "listUnordered" ? !self$1.containerState.marker || code$4 === self$1.containerState.marker : asciiDigit(code$4)) {
			if (self$1.containerState.type || (self$1.containerState.type = kind, effects.enter(kind, { _container: !0 })), kind === "listUnordered") return effects.enter("listItemPrefix"), code$4 === 42 || code$4 === 45 ? effects.check(thematicBreak$2, nok, atMarker)(code$4) : atMarker(code$4);
			if (!self$1.interrupt || code$4 === 49) return effects.enter("listItemPrefix"), effects.enter("listItemValue"), inside(code$4);
		}
		return nok(code$4);
	}
	function inside(code$4) {
		return asciiDigit(code$4) && ++size < 10 ? (effects.consume(code$4), inside) : (!self$1.interrupt || size < 2) && (self$1.containerState.marker ? code$4 === self$1.containerState.marker : code$4 === 41 || code$4 === 46) ? (effects.exit("listItemValue"), atMarker(code$4)) : nok(code$4);
	}
	function atMarker(code$4) {
		return effects.enter("listItemMarker"), effects.consume(code$4), effects.exit("listItemMarker"), self$1.containerState.marker = self$1.containerState.marker || code$4, effects.check(blankLine, self$1.interrupt ? nok : onBlank, effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix));
	}
	function onBlank(code$4) {
		return self$1.containerState.initialBlankLine = !0, initialSize++, endOfPrefix(code$4);
	}
	function otherPrefix(code$4) {
		return markdownSpace(code$4) ? (effects.enter("listItemPrefixWhitespace"), effects.consume(code$4), effects.exit("listItemPrefixWhitespace"), endOfPrefix) : nok(code$4);
	}
	function endOfPrefix(code$4) {
		return self$1.containerState.size = initialSize + self$1.sliceSerialize(effects.exit("listItemPrefix"), !0).length, ok$2(code$4);
	}
}
function tokenizeListContinuation(effects, ok$2, nok) {
	let self$1 = this;
	return self$1.containerState._closeFlow = void 0, effects.check(blankLine, onBlank, notBlank);
	function onBlank(code$4) {
		return self$1.containerState.furtherBlankLines = self$1.containerState.furtherBlankLines || self$1.containerState.initialBlankLine, factorySpace(effects, ok$2, "listItemIndent", self$1.containerState.size + 1)(code$4);
	}
	function notBlank(code$4) {
		return self$1.containerState.furtherBlankLines || !markdownSpace(code$4) ? (self$1.containerState.furtherBlankLines = void 0, self$1.containerState.initialBlankLine = void 0, notInCurrentItem(code$4)) : (self$1.containerState.furtherBlankLines = void 0, self$1.containerState.initialBlankLine = void 0, effects.attempt(indentConstruct, ok$2, notInCurrentItem)(code$4));
	}
	function notInCurrentItem(code$4) {
		return self$1.containerState._closeFlow = !0, self$1.interrupt = void 0, factorySpace(effects, effects.attempt(list$2, ok$2, nok), "linePrefix", self$1.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code$4);
	}
}
function tokenizeIndent$1(effects, ok$2, nok) {
	let self$1 = this;
	return factorySpace(effects, afterPrefix, "listItemIndent", self$1.containerState.size + 1);
	function afterPrefix(code$4) {
		let tail = self$1.events[self$1.events.length - 1];
		return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], !0).length === self$1.containerState.size ? ok$2(code$4) : nok(code$4);
	}
}
function tokenizeListEnd(effects) {
	effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok$2, nok) {
	let self$1 = this;
	return factorySpace(effects, afterPrefix, "listItemPrefixWhitespace", self$1.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
	function afterPrefix(code$4) {
		let tail = self$1.events[self$1.events.length - 1];
		return !markdownSpace(code$4) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok$2(code$4) : nok(code$4);
	}
}
const setextUnderline = {
	name: "setextUnderline",
	resolveTo: resolveToSetextUnderline,
	tokenize: tokenizeSetextUnderline
};
function resolveToSetextUnderline(events, context) {
	let index$2 = events.length, content$2, text$6, definition$2;
	for (; index$2--;) if (events[index$2][0] === "enter") {
		if (events[index$2][1].type === "content") {
			content$2 = index$2;
			break;
		}
		events[index$2][1].type === "paragraph" && (text$6 = index$2);
	} else events[index$2][1].type === "content" && events.splice(index$2, 1), !definition$2 && events[index$2][1].type === "definition" && (definition$2 = index$2);
	let heading$2 = {
		type: "setextHeading",
		start: { ...events[content$2][1].start },
		end: { ...events[events.length - 1][1].end }
	};
	return events[text$6][1].type = "setextHeadingText", definition$2 ? (events.splice(text$6, 0, [
		"enter",
		heading$2,
		context
	]), events.splice(definition$2 + 1, 0, [
		"exit",
		events[content$2][1],
		context
	]), events[content$2][1].end = { ...events[definition$2][1].end }) : events[content$2][1] = heading$2, events.push([
		"exit",
		heading$2,
		context
	]), events;
}
function tokenizeSetextUnderline(effects, ok$2, nok) {
	let self$1 = this, marker;
	return start;
	function start(code$4) {
		let index$2 = self$1.events.length, paragraph$2;
		for (; index$2--;) if (self$1.events[index$2][1].type !== "lineEnding" && self$1.events[index$2][1].type !== "linePrefix" && self$1.events[index$2][1].type !== "content") {
			paragraph$2 = self$1.events[index$2][1].type === "paragraph";
			break;
		}
		return !self$1.parser.lazy[self$1.now().line] && (self$1.interrupt || paragraph$2) ? (effects.enter("setextHeadingLine"), marker = code$4, before(code$4)) : nok(code$4);
	}
	function before(code$4) {
		return effects.enter("setextHeadingLineSequence"), inside(code$4);
	}
	function inside(code$4) {
		return code$4 === marker ? (effects.consume(code$4), inside) : (effects.exit("setextHeadingLineSequence"), markdownSpace(code$4) ? factorySpace(effects, after, "lineSuffix")(code$4) : after(code$4));
	}
	function after(code$4) {
		return code$4 === null || markdownLineEnding(code$4) ? (effects.exit("setextHeadingLine"), ok$2(code$4)) : nok(code$4);
	}
}
const flow = { tokenize: initializeFlow };
function initializeFlow(effects) {
	let self$1 = this, initial = effects.attempt(blankLine, atBlankEnding, effects.attempt(this.parser.constructs.flowInitial, afterConstruct, factorySpace(effects, effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt(content$1, afterConstruct)), "linePrefix")));
	return initial;
	function atBlankEnding(code$4) {
		if (code$4 === null) {
			effects.consume(code$4);
			return;
		}
		return effects.enter("lineEndingBlank"), effects.consume(code$4), effects.exit("lineEndingBlank"), self$1.currentConstruct = void 0, initial;
	}
	function afterConstruct(code$4) {
		if (code$4 === null) {
			effects.consume(code$4);
			return;
		}
		return effects.enter("lineEnding"), effects.consume(code$4), effects.exit("lineEnding"), self$1.currentConstruct = void 0, initial;
	}
}
const resolver = { resolveAll: createResolver() }, string = initializeFactory("string"), text$3 = initializeFactory("text");
function initializeFactory(field) {
	return {
		resolveAll: createResolver(field === "text" ? resolveAllLineSuffixes : void 0),
		tokenize: initializeText
	};
	function initializeText(effects) {
		let self$1 = this, constructs$1 = this.parser.constructs[field], text$6 = effects.attempt(constructs$1, start, notText);
		return start;
		function start(code$4) {
			return atBreak(code$4) ? text$6(code$4) : notText(code$4);
		}
		function notText(code$4) {
			if (code$4 === null) {
				effects.consume(code$4);
				return;
			}
			return effects.enter("data"), effects.consume(code$4), data;
		}
		function data(code$4) {
			return atBreak(code$4) ? (effects.exit("data"), text$6(code$4)) : (effects.consume(code$4), data);
		}
		function atBreak(code$4) {
			if (code$4 === null) return !0;
			let list$3 = constructs$1[code$4], index$2 = -1;
			if (list$3) for (; ++index$2 < list$3.length;) {
				let item = list$3[index$2];
				if (!item.previous || item.previous.call(self$1, self$1.previous)) return !0;
			}
			return !1;
		}
	}
}
function createResolver(extraResolver) {
	return resolveAllText;
	function resolveAllText(events, context) {
		let index$2 = -1, enter;
		for (; ++index$2 <= events.length;) enter === void 0 ? events[index$2] && events[index$2][1].type === "data" && (enter = index$2, index$2++) : (!events[index$2] || events[index$2][1].type !== "data") && (index$2 !== enter + 2 && (events[enter][1].end = events[index$2 - 1][1].end, events.splice(enter + 2, index$2 - enter - 2), index$2 = enter + 2), enter = void 0);
		return extraResolver ? extraResolver(events, context) : events;
	}
}
function resolveAllLineSuffixes(events, context) {
	let eventIndex = 0;
	for (; ++eventIndex <= events.length;) if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
		let data = events[eventIndex - 1][1], chunks = context.sliceStream(data), index$2 = chunks.length, bufferIndex = -1, size = 0, tabs;
		for (; index$2--;) {
			let chunk = chunks[index$2];
			if (typeof chunk == "string") {
				for (bufferIndex = chunk.length; chunk.charCodeAt(bufferIndex - 1) === 32;) size++, bufferIndex--;
				if (bufferIndex) break;
				bufferIndex = -1;
			} else if (chunk === -2) tabs = !0, size++;
			else if (chunk !== -1) {
				index$2++;
				break;
			}
		}
		if (context._contentTypeTextTrailing && eventIndex === events.length && (size = 0), size) {
			let token = {
				type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
				start: {
					_bufferIndex: index$2 ? bufferIndex : data.start._bufferIndex + bufferIndex,
					_index: data.start._index + index$2,
					line: data.end.line,
					column: data.end.column - size,
					offset: data.end.offset - size
				},
				end: { ...data.end }
			};
			data.end = { ...token.start }, data.start.offset === data.end.offset ? Object.assign(data, token) : (events.splice(eventIndex, 0, [
				"enter",
				token,
				context
			], [
				"exit",
				token,
				context
			]), eventIndex += 2);
		}
		eventIndex++;
	}
	return events;
}
var constructs_exports = /* @__PURE__ */ __export({
	attentionMarkers: () => attentionMarkers,
	contentInitial: () => contentInitial,
	disable: () => disable,
	document: () => document$2,
	flow: () => flow$1,
	flowInitial: () => flowInitial,
	insideSpan: () => insideSpan,
	string: () => string$1,
	text: () => text$4
});
const document$2 = {
	42: list$2,
	43: list$2,
	45: list$2,
	48: list$2,
	49: list$2,
	50: list$2,
	51: list$2,
	52: list$2,
	53: list$2,
	54: list$2,
	55: list$2,
	56: list$2,
	57: list$2,
	62: blockQuote
}, contentInitial = { 91: definition$1 }, flowInitial = {
	[-2]: codeIndented,
	[-1]: codeIndented,
	32: codeIndented
}, flow$1 = {
	35: headingAtx,
	42: thematicBreak$2,
	45: [setextUnderline, thematicBreak$2],
	60: htmlFlow,
	61: setextUnderline,
	95: thematicBreak$2,
	96: codeFenced,
	126: codeFenced
}, string$1 = {
	38: characterReference,
	92: characterEscape
}, text$4 = {
	[-5]: lineEnding,
	[-4]: lineEnding,
	[-3]: lineEnding,
	33: labelStartImage,
	38: characterReference,
	42: attention,
	60: [autolink, htmlText],
	91: labelStartLink,
	92: [hardBreakEscape, characterEscape],
	93: labelEnd,
	95: attention,
	96: codeText
}, insideSpan = { null: [attention, resolver] }, attentionMarkers = { null: [42, 95] }, disable = { null: [] };
function createTokenizer(parser, initialize, from$1) {
	let point$3 = {
		_bufferIndex: -1,
		_index: 0,
		line: from$1 && from$1.line || 1,
		column: from$1 && from$1.column || 1,
		offset: from$1 && from$1.offset || 0
	}, columnStart = {}, resolveAllConstructs = [], chunks = [], stack = [], effects = {
		attempt: constructFactory(onsuccessfulconstruct),
		check: constructFactory(onsuccessfulcheck),
		consume,
		enter,
		exit: exit$2,
		interrupt: constructFactory(onsuccessfulcheck, { interrupt: !0 })
	}, context = {
		code: null,
		containerState: {},
		defineSkip,
		events: [],
		now,
		parser,
		previous: null,
		sliceSerialize,
		sliceStream,
		write
	}, state = initialize.tokenize.call(context, effects);
	return initialize.resolveAll && resolveAllConstructs.push(initialize), context;
	function write(slice) {
		return chunks = push(chunks, slice), main(), chunks[chunks.length - 1] === null ? (addResult(initialize, 0), context.events = resolveAll(resolveAllConstructs, context.events, context), context.events) : [];
	}
	function sliceSerialize(token, expandTabs) {
		return serializeChunks(sliceStream(token), expandTabs);
	}
	function sliceStream(token) {
		return sliceChunks(chunks, token);
	}
	function now() {
		let { _bufferIndex, _index, line, column, offset } = point$3;
		return {
			_bufferIndex,
			_index,
			line,
			column,
			offset
		};
	}
	function defineSkip(value) {
		columnStart[value.line] = value.column, accountForPotentialSkip();
	}
	function main() {
		let chunkIndex;
		for (; point$3._index < chunks.length;) {
			let chunk = chunks[point$3._index];
			if (typeof chunk == "string") for (chunkIndex = point$3._index, point$3._bufferIndex < 0 && (point$3._bufferIndex = 0); point$3._index === chunkIndex && point$3._bufferIndex < chunk.length;) go$1(chunk.charCodeAt(point$3._bufferIndex));
			else go$1(chunk);
		}
	}
	function go$1(code$4) {
		state = state(code$4);
	}
	function consume(code$4) {
		markdownLineEnding(code$4) ? (point$3.line++, point$3.column = 1, point$3.offset += code$4 === -3 ? 2 : 1, accountForPotentialSkip()) : code$4 !== -1 && (point$3.column++, point$3.offset++), point$3._bufferIndex < 0 ? point$3._index++ : (point$3._bufferIndex++, point$3._bufferIndex === chunks[point$3._index].length && (point$3._bufferIndex = -1, point$3._index++)), context.previous = code$4;
	}
	function enter(type, fields) {
		let token = fields || {};
		return token.type = type, token.start = now(), context.events.push([
			"enter",
			token,
			context
		]), stack.push(token), token;
	}
	function exit$2(type) {
		let token = stack.pop();
		return token.end = now(), context.events.push([
			"exit",
			token,
			context
		]), token;
	}
	function onsuccessfulconstruct(construct, info) {
		addResult(construct, info.from);
	}
	function onsuccessfulcheck(_, info) {
		info.restore();
	}
	function constructFactory(onreturn, fields) {
		return hook;
		function hook(constructs$1, returnState, bogusState) {
			let listOfConstructs, constructIndex, currentConstruct, info;
			return Array.isArray(constructs$1) ? handleListOfConstructs(constructs$1) : "tokenize" in constructs$1 ? handleListOfConstructs([constructs$1]) : handleMapOfConstructs(constructs$1);
			function handleMapOfConstructs(map$2) {
				return start;
				function start(code$4) {
					let left = code$4 !== null && map$2[code$4], all$2 = code$4 !== null && map$2.null;
					return handleListOfConstructs([...Array.isArray(left) ? left : left ? [left] : [], ...Array.isArray(all$2) ? all$2 : all$2 ? [all$2] : []])(code$4);
				}
			}
			function handleListOfConstructs(list$3) {
				return listOfConstructs = list$3, constructIndex = 0, list$3.length === 0 ? bogusState : handleConstruct(list$3[constructIndex]);
			}
			function handleConstruct(construct) {
				return start;
				function start(code$4) {
					return info = store(), currentConstruct = construct, construct.partial || (context.currentConstruct = construct), construct.name && context.parser.constructs.disable.null.includes(construct.name) ? nok(code$4) : construct.tokenize.call(fields ? Object.assign(Object.create(context), fields) : context, effects, ok$2, nok)(code$4);
				}
			}
			function ok$2(code$4) {
				return onreturn(currentConstruct, info), returnState;
			}
			function nok(code$4) {
				return info.restore(), ++constructIndex < listOfConstructs.length ? handleConstruct(listOfConstructs[constructIndex]) : bogusState;
			}
		}
	}
	function addResult(construct, from$2) {
		construct.resolveAll && !resolveAllConstructs.includes(construct) && resolveAllConstructs.push(construct), construct.resolve && splice(context.events, from$2, context.events.length - from$2, construct.resolve(context.events.slice(from$2), context)), construct.resolveTo && (context.events = construct.resolveTo(context.events, context));
	}
	function store() {
		let startPoint = now(), startPrevious = context.previous, startCurrentConstruct = context.currentConstruct, startEventsIndex = context.events.length, startStack = Array.from(stack);
		return {
			from: startEventsIndex,
			restore
		};
		function restore() {
			point$3 = startPoint, context.previous = startPrevious, context.currentConstruct = startCurrentConstruct, context.events.length = startEventsIndex, stack = startStack, accountForPotentialSkip();
		}
	}
	function accountForPotentialSkip() {
		point$3.line in columnStart && point$3.column < 2 && (point$3.column = columnStart[point$3.line], point$3.offset += columnStart[point$3.line] - 1);
	}
}
function sliceChunks(chunks, token) {
	let startIndex = token.start._index, startBufferIndex = token.start._bufferIndex, endIndex = token.end._index, endBufferIndex = token.end._bufferIndex, view;
	if (startIndex === endIndex) view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
	else {
		if (view = chunks.slice(startIndex, endIndex), startBufferIndex > -1) {
			let head = view[0];
			typeof head == "string" ? view[0] = head.slice(startBufferIndex) : view.shift();
		}
		endBufferIndex > 0 && view.push(chunks[endIndex].slice(0, endBufferIndex));
	}
	return view;
}
function serializeChunks(chunks, expandTabs) {
	let index$2 = -1, result = [], atTab;
	for (; ++index$2 < chunks.length;) {
		let chunk = chunks[index$2], value;
		if (typeof chunk == "string") value = chunk;
		else switch (chunk) {
			case -5:
				value = "\r";
				break;
			case -4:
				value = "\n";
				break;
			case -3:
				value = "\r\n";
				break;
			case -2:
				value = expandTabs ? " " : "	";
				break;
			case -1:
				if (!expandTabs && atTab) continue;
				value = " ";
				break;
			default: value = String.fromCharCode(chunk);
		}
		atTab = chunk === -2, result.push(value);
	}
	return result.join("");
}
function parse$1(options) {
	let parser = {
		constructs: combineExtensions([constructs_exports, ...(options || {}).extensions || []]),
		content: create$1(content),
		defined: [],
		document: create$1(document$1),
		flow: create$1(flow),
		lazy: {},
		string: create$1(string),
		text: create$1(text$3)
	};
	return parser;
	function create$1(initial) {
		return creator;
		function creator(from$1) {
			return createTokenizer(parser, initial, from$1);
		}
	}
}
function postprocess(events) {
	for (; !subtokenize(events););
	return events;
}
var search = /[\0\t\n\r]/g;
function preprocess() {
	let column = 1, buffer = "", start = !0, atCarriageReturn;
	return preprocessor;
	function preprocessor(value, encoding, end) {
		let chunks = [], match, next, startPosition, endPosition, code$4;
		for (value = buffer + (typeof value == "string" ? value.toString() : new TextDecoder(encoding || void 0).decode(value)), startPosition = 0, buffer = "", start &&= (value.charCodeAt(0) === 65279 && startPosition++, void 0); startPosition < value.length;) {
			if (search.lastIndex = startPosition, match = search.exec(value), endPosition = match && match.index !== void 0 ? match.index : value.length, code$4 = value.charCodeAt(endPosition), !match) {
				buffer = value.slice(startPosition);
				break;
			}
			if (code$4 === 10 && startPosition === endPosition && atCarriageReturn) chunks.push(-3), atCarriageReturn = void 0;
			else switch (atCarriageReturn &&= (chunks.push(-5), void 0), startPosition < endPosition && (chunks.push(value.slice(startPosition, endPosition)), column += endPosition - startPosition), code$4) {
				case 0:
					chunks.push(65533), column++;
					break;
				case 9:
					for (next = Math.ceil(column / 4) * 4, chunks.push(-2); column++ < next;) chunks.push(-1);
					break;
				case 10:
					chunks.push(-4), column = 1;
					break;
				default: atCarriageReturn = !0, column = 1;
			}
			startPosition = endPosition + 1;
		}
		return end && (atCarriageReturn && chunks.push(-5), buffer && chunks.push(buffer), chunks.push(null)), chunks;
	}
}
var characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value) {
	return value.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $2) {
	if ($1) return $1;
	if ($2.charCodeAt(0) === 35) {
		let head = $2.charCodeAt(1), hex = head === 120 || head === 88;
		return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);
	}
	return decodeNamedCharacterReference($2) || $0;
}
var own$3 = {}.hasOwnProperty;
function fromMarkdown(value, encoding, options) {
	return typeof encoding != "string" && (options = encoding, encoding = void 0), compiler(options)(postprocess(parse$1(options).document().write(preprocess()(value, encoding, !0))));
}
function compiler(options) {
	let config = {
		transforms: [],
		canContainEols: [
			"emphasis",
			"fragment",
			"heading",
			"paragraph",
			"strong"
		],
		enter: {
			autolink: opener(link$2),
			autolinkProtocol: onenterdata,
			autolinkEmail: onenterdata,
			atxHeading: opener(heading$2),
			blockQuote: opener(blockQuote$1),
			characterEscape: onenterdata,
			characterReference: onenterdata,
			codeFenced: opener(codeFlow),
			codeFencedFenceInfo: buffer,
			codeFencedFenceMeta: buffer,
			codeIndented: opener(codeFlow, buffer),
			codeText: opener(codeText$1, buffer),
			codeTextData: onenterdata,
			data: onenterdata,
			codeFlowValue: onenterdata,
			definition: opener(definition$2),
			definitionDestinationString: buffer,
			definitionLabelString: buffer,
			definitionTitleString: buffer,
			emphasis: opener(emphasis$2),
			hardBreakEscape: opener(hardBreak$2),
			hardBreakTrailing: opener(hardBreak$2),
			htmlFlow: opener(html$4, buffer),
			htmlFlowData: onenterdata,
			htmlText: opener(html$4, buffer),
			htmlTextData: onenterdata,
			image: opener(image$2),
			label: buffer,
			link: opener(link$2),
			listItem: opener(listItem$2),
			listItemValue: onenterlistitemvalue,
			listOrdered: opener(list$3, onenterlistordered),
			listUnordered: opener(list$3),
			paragraph: opener(paragraph$2),
			reference: onenterreference,
			referenceString: buffer,
			resourceDestinationString: buffer,
			resourceTitleString: buffer,
			setextHeading: opener(heading$2),
			strong: opener(strong$2),
			thematicBreak: opener(thematicBreak$3)
		},
		exit: {
			atxHeading: closer(),
			atxHeadingSequence: onexitatxheadingsequence,
			autolink: closer(),
			autolinkEmail: onexitautolinkemail,
			autolinkProtocol: onexitautolinkprotocol,
			blockQuote: closer(),
			characterEscapeValue: onexitdata,
			characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
			characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
			characterReferenceValue: onexitcharacterreferencevalue,
			characterReference: onexitcharacterreference,
			codeFenced: closer(onexitcodefenced),
			codeFencedFence: onexitcodefencedfence,
			codeFencedFenceInfo: onexitcodefencedfenceinfo,
			codeFencedFenceMeta: onexitcodefencedfencemeta,
			codeFlowValue: onexitdata,
			codeIndented: closer(onexitcodeindented),
			codeText: closer(onexitcodetext),
			codeTextData: onexitdata,
			data: onexitdata,
			definition: closer(),
			definitionDestinationString: onexitdefinitiondestinationstring,
			definitionLabelString: onexitdefinitionlabelstring,
			definitionTitleString: onexitdefinitiontitlestring,
			emphasis: closer(),
			hardBreakEscape: closer(onexithardbreak),
			hardBreakTrailing: closer(onexithardbreak),
			htmlFlow: closer(onexithtmlflow),
			htmlFlowData: onexitdata,
			htmlText: closer(onexithtmltext),
			htmlTextData: onexitdata,
			image: closer(onexitimage),
			label: onexitlabel,
			labelText: onexitlabeltext,
			lineEnding: onexitlineending,
			link: closer(onexitlink),
			listItem: closer(),
			listOrdered: closer(),
			listUnordered: closer(),
			paragraph: closer(),
			referenceString: onexitreferencestring,
			resourceDestinationString: onexitresourcedestinationstring,
			resourceTitleString: onexitresourcetitlestring,
			resource: onexitresource,
			setextHeading: closer(onexitsetextheading),
			setextHeadingLineSequence: onexitsetextheadinglinesequence,
			setextHeadingText: onexitsetextheadingtext,
			strong: closer(),
			thematicBreak: closer()
		}
	};
	configure(config, (options || {}).mdastExtensions || []);
	let data = {};
	return compile;
	function compile(events) {
		let tree = {
			type: "root",
			children: []
		}, context = {
			stack: [tree],
			tokenStack: [],
			config,
			enter,
			exit: exit$2,
			buffer,
			resume,
			data
		}, listStack = [], index$2 = -1;
		for (; ++index$2 < events.length;) (events[index$2][1].type === "listOrdered" || events[index$2][1].type === "listUnordered") && (events[index$2][0] === "enter" ? listStack.push(index$2) : index$2 = prepareList(events, listStack.pop(), index$2));
		for (index$2 = -1; ++index$2 < events.length;) {
			let handler = config[events[index$2][0]];
			own$3.call(handler, events[index$2][1].type) && handler[events[index$2][1].type].call(Object.assign({ sliceSerialize: events[index$2][2].sliceSerialize }, context), events[index$2][1]);
		}
		if (context.tokenStack.length > 0) {
			let tail = context.tokenStack[context.tokenStack.length - 1];
			(tail[1] || defaultOnError).call(context, void 0, tail[0]);
		}
		for (tree.position = {
			start: point(events.length > 0 ? events[0][1].start : {
				line: 1,
				column: 1,
				offset: 0
			}),
			end: point(events.length > 0 ? events[events.length - 2][1].end : {
				line: 1,
				column: 1,
				offset: 0
			})
		}, index$2 = -1; ++index$2 < config.transforms.length;) tree = config.transforms[index$2](tree) || tree;
		return tree;
	}
	function prepareList(events, start, length) {
		let index$2 = start - 1, containerBalance = -1, listSpread = !1, listItem$3, lineIndex, firstBlankLineIndex, atMarker;
		for (; ++index$2 <= length;) {
			let event = events[index$2];
			switch (event[1].type) {
				case "listUnordered":
				case "listOrdered":
				case "blockQuote":
					event[0] === "enter" ? containerBalance++ : containerBalance--, atMarker = void 0;
					break;
				case "lineEndingBlank":
					event[0] === "enter" && (listItem$3 && !atMarker && !containerBalance && !firstBlankLineIndex && (firstBlankLineIndex = index$2), atMarker = void 0);
					break;
				case "linePrefix":
				case "listItemValue":
				case "listItemMarker":
				case "listItemPrefix":
				case "listItemPrefixWhitespace": break;
				default: atMarker = void 0;
			}
			if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
				if (listItem$3) {
					let tailIndex = index$2;
					for (lineIndex = void 0; tailIndex--;) {
						let tailEvent = events[tailIndex];
						if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
							if (tailEvent[0] === "exit") continue;
							lineIndex && (events[lineIndex][1].type = "lineEndingBlank", listSpread = !0), tailEvent[1].type = "lineEnding", lineIndex = tailIndex;
						} else if (!(tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent")) break;
					}
					firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex) && (listItem$3._spread = !0), listItem$3.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end), events.splice(lineIndex || index$2, 0, [
						"exit",
						listItem$3,
						event[2]
					]), index$2++, length++;
				}
				if (event[1].type === "listItemPrefix") {
					let item = {
						type: "listItem",
						_spread: !1,
						start: Object.assign({}, event[1].start),
						end: void 0
					};
					listItem$3 = item, events.splice(index$2, 0, [
						"enter",
						item,
						event[2]
					]), index$2++, length++, firstBlankLineIndex = void 0, atMarker = !0;
				}
			}
		}
		return events[start][1]._spread = listSpread, length;
	}
	function opener(create$1, and) {
		return open;
		function open(token) {
			enter.call(this, create$1(token), token), and && and.call(this, token);
		}
	}
	function buffer() {
		this.stack.push({
			type: "fragment",
			children: []
		});
	}
	function enter(node$1, token, errorHandler) {
		this.stack[this.stack.length - 1].children.push(node$1), this.stack.push(node$1), this.tokenStack.push([token, errorHandler || void 0]), node$1.position = {
			start: point(token.start),
			end: void 0
		};
	}
	function closer(and) {
		return close;
		function close(token) {
			and && and.call(this, token), exit$2.call(this, token);
		}
	}
	function exit$2(token, onExitError) {
		let node$1 = this.stack.pop(), open = this.tokenStack.pop();
		if (open) open[0].type !== token.type && (onExitError ? onExitError.call(this, token, open[0]) : (open[1] || defaultOnError).call(this, token, open[0]));
		else throw Error("Cannot close `" + token.type + "` (" + stringifyPosition({
			start: token.start,
			end: token.end
		}) + "): itâ€™s not open");
		node$1.position.end = point(token.end);
	}
	function resume() {
		return toString$2(this.stack.pop());
	}
	function onenterlistordered() {
		this.data.expectingFirstListItemValue = !0;
	}
	function onenterlistitemvalue(token) {
		if (this.data.expectingFirstListItemValue) {
			let ancestor = this.stack[this.stack.length - 2];
			ancestor.start = Number.parseInt(this.sliceSerialize(token), 10), this.data.expectingFirstListItemValue = void 0;
		}
	}
	function onexitcodefencedfenceinfo() {
		let data$1 = this.resume(), node$1 = this.stack[this.stack.length - 1];
		node$1.lang = data$1;
	}
	function onexitcodefencedfencemeta() {
		let data$1 = this.resume(), node$1 = this.stack[this.stack.length - 1];
		node$1.meta = data$1;
	}
	function onexitcodefencedfence() {
		this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
	}
	function onexitcodefenced() {
		let data$1 = this.resume(), node$1 = this.stack[this.stack.length - 1];
		node$1.value = data$1.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
	}
	function onexitcodeindented() {
		let data$1 = this.resume(), node$1 = this.stack[this.stack.length - 1];
		node$1.value = data$1.replace(/(\r?\n|\r)$/g, "");
	}
	function onexitdefinitionlabelstring(token) {
		let label = this.resume(), node$1 = this.stack[this.stack.length - 1];
		node$1.label = label, node$1.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
	}
	function onexitdefinitiontitlestring() {
		let data$1 = this.resume(), node$1 = this.stack[this.stack.length - 1];
		node$1.title = data$1;
	}
	function onexitdefinitiondestinationstring() {
		let data$1 = this.resume(), node$1 = this.stack[this.stack.length - 1];
		node$1.url = data$1;
	}
	function onexitatxheadingsequence(token) {
		let node$1 = this.stack[this.stack.length - 1];
		node$1.depth ||= this.sliceSerialize(token).length;
	}
	function onexitsetextheadingtext() {
		this.data.setextHeadingSlurpLineEnding = !0;
	}
	function onexitsetextheadinglinesequence(token) {
		let node$1 = this.stack[this.stack.length - 1];
		node$1.depth = this.sliceSerialize(token).codePointAt(0) === 61 ? 1 : 2;
	}
	function onexitsetextheading() {
		this.data.setextHeadingSlurpLineEnding = void 0;
	}
	function onenterdata(token) {
		let siblings = this.stack[this.stack.length - 1].children, tail = siblings[siblings.length - 1];
		(!tail || tail.type !== "text") && (tail = text$6(), tail.position = {
			start: point(token.start),
			end: void 0
		}, siblings.push(tail)), this.stack.push(tail);
	}
	function onexitdata(token) {
		let tail = this.stack.pop();
		tail.value += this.sliceSerialize(token), tail.position.end = point(token.end);
	}
	function onexitlineending(token) {
		let context = this.stack[this.stack.length - 1];
		if (this.data.atHardBreak) {
			let tail = context.children[context.children.length - 1];
			tail.position.end = point(token.end), this.data.atHardBreak = void 0;
			return;
		}
		!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type) && (onenterdata.call(this, token), onexitdata.call(this, token));
	}
	function onexithardbreak() {
		this.data.atHardBreak = !0;
	}
	function onexithtmlflow() {
		let data$1 = this.resume(), node$1 = this.stack[this.stack.length - 1];
		node$1.value = data$1;
	}
	function onexithtmltext() {
		let data$1 = this.resume(), node$1 = this.stack[this.stack.length - 1];
		node$1.value = data$1;
	}
	function onexitcodetext() {
		let data$1 = this.resume(), node$1 = this.stack[this.stack.length - 1];
		node$1.value = data$1;
	}
	function onexitlink() {
		let node$1 = this.stack[this.stack.length - 1];
		if (this.data.inReference) {
			let referenceType = this.data.referenceType || "shortcut";
			node$1.type += "Reference", node$1.referenceType = referenceType, delete node$1.url, delete node$1.title;
		} else delete node$1.identifier, delete node$1.label;
		this.data.referenceType = void 0;
	}
	function onexitimage() {
		let node$1 = this.stack[this.stack.length - 1];
		if (this.data.inReference) {
			let referenceType = this.data.referenceType || "shortcut";
			node$1.type += "Reference", node$1.referenceType = referenceType, delete node$1.url, delete node$1.title;
		} else delete node$1.identifier, delete node$1.label;
		this.data.referenceType = void 0;
	}
	function onexitlabeltext(token) {
		let string$2 = this.sliceSerialize(token), ancestor = this.stack[this.stack.length - 2];
		ancestor.label = decodeString(string$2), ancestor.identifier = normalizeIdentifier(string$2).toLowerCase();
	}
	function onexitlabel() {
		let fragment = this.stack[this.stack.length - 1], value = this.resume(), node$1 = this.stack[this.stack.length - 1];
		this.data.inReference = !0, node$1.type === "link" ? node$1.children = fragment.children : node$1.alt = value;
	}
	function onexitresourcedestinationstring() {
		let data$1 = this.resume(), node$1 = this.stack[this.stack.length - 1];
		node$1.url = data$1;
	}
	function onexitresourcetitlestring() {
		let data$1 = this.resume(), node$1 = this.stack[this.stack.length - 1];
		node$1.title = data$1;
	}
	function onexitresource() {
		this.data.inReference = void 0;
	}
	function onenterreference() {
		this.data.referenceType = "collapsed";
	}
	function onexitreferencestring(token) {
		let label = this.resume(), node$1 = this.stack[this.stack.length - 1];
		node$1.label = label, node$1.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase(), this.data.referenceType = "full";
	}
	function onexitcharacterreferencemarker(token) {
		this.data.characterReferenceType = token.type;
	}
	function onexitcharacterreferencevalue(token) {
		let data$1 = this.sliceSerialize(token), type = this.data.characterReferenceType, value;
		type ? (value = decodeNumericCharacterReference(data$1, type === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : value = decodeNamedCharacterReference(data$1);
		let tail = this.stack[this.stack.length - 1];
		tail.value += value;
	}
	function onexitcharacterreference(token) {
		let tail = this.stack.pop();
		tail.position.end = point(token.end);
	}
	function onexitautolinkprotocol(token) {
		onexitdata.call(this, token);
		let node$1 = this.stack[this.stack.length - 1];
		node$1.url = this.sliceSerialize(token);
	}
	function onexitautolinkemail(token) {
		onexitdata.call(this, token);
		let node$1 = this.stack[this.stack.length - 1];
		node$1.url = "mailto:" + this.sliceSerialize(token);
	}
	function blockQuote$1() {
		return {
			type: "blockquote",
			children: []
		};
	}
	function codeFlow() {
		return {
			type: "code",
			lang: null,
			meta: null,
			value: ""
		};
	}
	function codeText$1() {
		return {
			type: "inlineCode",
			value: ""
		};
	}
	function definition$2() {
		return {
			type: "definition",
			identifier: "",
			label: null,
			title: null,
			url: ""
		};
	}
	function emphasis$2() {
		return {
			type: "emphasis",
			children: []
		};
	}
	function heading$2() {
		return {
			type: "heading",
			depth: 0,
			children: []
		};
	}
	function hardBreak$2() {
		return { type: "break" };
	}
	function html$4() {
		return {
			type: "html",
			value: ""
		};
	}
	function image$2() {
		return {
			type: "image",
			title: null,
			url: "",
			alt: null
		};
	}
	function link$2() {
		return {
			type: "link",
			title: null,
			url: "",
			children: []
		};
	}
	function list$3(token) {
		return {
			type: "list",
			ordered: token.type === "listOrdered",
			start: null,
			spread: token._spread,
			children: []
		};
	}
	function listItem$2(token) {
		return {
			type: "listItem",
			spread: token._spread,
			checked: null,
			children: []
		};
	}
	function paragraph$2() {
		return {
			type: "paragraph",
			children: []
		};
	}
	function strong$2() {
		return {
			type: "strong",
			children: []
		};
	}
	function text$6() {
		return {
			type: "text",
			value: ""
		};
	}
	function thematicBreak$3() {
		return { type: "thematicBreak" };
	}
}
function point(d) {
	return {
		line: d.line,
		column: d.column,
		offset: d.offset
	};
}
function configure(combined, extensions) {
	let index$2 = -1;
	for (; ++index$2 < extensions.length;) {
		let value = extensions[index$2];
		Array.isArray(value) ? configure(combined, value) : extension(combined, value);
	}
}
function extension(combined, extension$1) {
	let key;
	for (key in extension$1) if (own$3.call(extension$1, key)) switch (key) {
		case "canContainEols": {
			let right = extension$1[key];
			right && combined[key].push(...right);
			break;
		}
		case "transforms": {
			let right = extension$1[key];
			right && combined[key].push(...right);
			break;
		}
		case "enter":
		case "exit": {
			let right = extension$1[key];
			right && Object.assign(combined[key], right);
			break;
		}
	}
}
function defaultOnError(left, right) {
	throw left ? Error("Cannot close `" + left.type + "` (" + stringifyPosition({
		start: left.start,
		end: left.end
	}) + "): a different token (`" + right.type + "`, " + stringifyPosition({
		start: right.start,
		end: right.end
	}) + ") is open") : Error("Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({
		start: right.start,
		end: right.end
	}) + ") is still open");
}
function remarkParse(options) {
	let self$1 = this;
	self$1.parser = parser;
	function parser(doc) {
		return fromMarkdown(doc, {
			...self$1.data("settings"),
			...options,
			extensions: self$1.data("micromarkExtensions") || [],
			mdastExtensions: self$1.data("fromMarkdownExtensions") || []
		});
	}
}
function blockquote$1(state, node$1) {
	let result = {
		type: "element",
		tagName: "blockquote",
		properties: {},
		children: state.wrap(state.all(node$1), !0)
	};
	return state.patch(node$1, result), state.applyData(node$1, result);
}
function hardBreak$1(state, node$1) {
	let result = {
		type: "element",
		tagName: "br",
		properties: {},
		children: []
	};
	return state.patch(node$1, result), [state.applyData(node$1, result), {
		type: "text",
		value: "\n"
	}];
}
function code$3(state, node$1) {
	let value = node$1.value ? node$1.value + "\n" : "", properties = {}, language$1 = node$1.lang ? node$1.lang.split(/\s+/) : [];
	language$1.length > 0 && (properties.className = ["language-" + language$1[0]]);
	let result = {
		type: "element",
		tagName: "code",
		properties,
		children: [{
			type: "text",
			value
		}]
	};
	return node$1.meta && (result.data = { meta: node$1.meta }), state.patch(node$1, result), result = state.applyData(node$1, result), result = {
		type: "element",
		tagName: "pre",
		properties: {},
		children: [result]
	}, state.patch(node$1, result), result;
}
function strikethrough(state, node$1) {
	let result = {
		type: "element",
		tagName: "del",
		properties: {},
		children: state.all(node$1)
	};
	return state.patch(node$1, result), state.applyData(node$1, result);
}
function emphasis$1(state, node$1) {
	let result = {
		type: "element",
		tagName: "em",
		properties: {},
		children: state.all(node$1)
	};
	return state.patch(node$1, result), state.applyData(node$1, result);
}
function footnoteReference$1(state, node$1) {
	let clobberPrefix = typeof state.options.clobberPrefix == "string" ? state.options.clobberPrefix : "user-content-", id = String(node$1.identifier).toUpperCase(), safeId = normalizeUri(id.toLowerCase()), index$2 = state.footnoteOrder.indexOf(id), counter, reuseCounter = state.footnoteCounts.get(id);
	reuseCounter === void 0 ? (reuseCounter = 0, state.footnoteOrder.push(id), counter = state.footnoteOrder.length) : counter = index$2 + 1, reuseCounter += 1, state.footnoteCounts.set(id, reuseCounter);
	let link$2 = {
		type: "element",
		tagName: "a",
		properties: {
			href: "#" + clobberPrefix + "fn-" + safeId,
			id: clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
			dataFootnoteRef: !0,
			ariaDescribedBy: ["footnote-label"]
		},
		children: [{
			type: "text",
			value: String(counter)
		}]
	};
	state.patch(node$1, link$2);
	let sup = {
		type: "element",
		tagName: "sup",
		properties: {},
		children: [link$2]
	};
	return state.patch(node$1, sup), state.applyData(node$1, sup);
}
function heading$1(state, node$1) {
	let result = {
		type: "element",
		tagName: "h" + node$1.depth,
		properties: {},
		children: state.all(node$1)
	};
	return state.patch(node$1, result), state.applyData(node$1, result);
}
function html$1(state, node$1) {
	if (state.options.allowDangerousHtml) {
		let result = {
			type: "raw",
			value: node$1.value
		};
		return state.patch(node$1, result), state.applyData(node$1, result);
	}
}
function revert(state, node$1) {
	let subtype = node$1.referenceType, suffix = "]";
	if (subtype === "collapsed" ? suffix += "[]" : subtype === "full" && (suffix += "[" + (node$1.label || node$1.identifier) + "]"), node$1.type === "imageReference") return [{
		type: "text",
		value: "![" + node$1.alt + suffix
	}];
	let contents = state.all(node$1), head = contents[0];
	head && head.type === "text" ? head.value = "[" + head.value : contents.unshift({
		type: "text",
		value: "["
	});
	let tail = contents[contents.length - 1];
	return tail && tail.type === "text" ? tail.value += suffix : contents.push({
		type: "text",
		value: suffix
	}), contents;
}
function imageReference$1(state, node$1) {
	let id = String(node$1.identifier).toUpperCase(), definition$2 = state.definitionById.get(id);
	if (!definition$2) return revert(state, node$1);
	let properties = {
		src: normalizeUri(definition$2.url || ""),
		alt: node$1.alt
	};
	definition$2.title !== null && definition$2.title !== void 0 && (properties.title = definition$2.title);
	let result = {
		type: "element",
		tagName: "img",
		properties,
		children: []
	};
	return state.patch(node$1, result), state.applyData(node$1, result);
}
function image$1(state, node$1) {
	let properties = { src: normalizeUri(node$1.url) };
	node$1.alt !== null && node$1.alt !== void 0 && (properties.alt = node$1.alt), node$1.title !== null && node$1.title !== void 0 && (properties.title = node$1.title);
	let result = {
		type: "element",
		tagName: "img",
		properties,
		children: []
	};
	return state.patch(node$1, result), state.applyData(node$1, result);
}
function inlineCode$1(state, node$1) {
	let text$6 = {
		type: "text",
		value: node$1.value.replace(/\r?\n|\r/g, " ")
	};
	state.patch(node$1, text$6);
	let result = {
		type: "element",
		tagName: "code",
		properties: {},
		children: [text$6]
	};
	return state.patch(node$1, result), state.applyData(node$1, result);
}
function linkReference$1(state, node$1) {
	let id = String(node$1.identifier).toUpperCase(), definition$2 = state.definitionById.get(id);
	if (!definition$2) return revert(state, node$1);
	let properties = { href: normalizeUri(definition$2.url || "") };
	definition$2.title !== null && definition$2.title !== void 0 && (properties.title = definition$2.title);
	let result = {
		type: "element",
		tagName: "a",
		properties,
		children: state.all(node$1)
	};
	return state.patch(node$1, result), state.applyData(node$1, result);
}
function link$1(state, node$1) {
	let properties = { href: normalizeUri(node$1.url) };
	node$1.title !== null && node$1.title !== void 0 && (properties.title = node$1.title);
	let result = {
		type: "element",
		tagName: "a",
		properties,
		children: state.all(node$1)
	};
	return state.patch(node$1, result), state.applyData(node$1, result);
}
function listItem$1(state, node$1, parent) {
	let results = state.all(node$1), loose = parent ? listLoose(parent) : listItemLoose(node$1), properties = {}, children = [];
	if (typeof node$1.checked == "boolean") {
		let head = results[0], paragraph$2;
		head && head.type === "element" && head.tagName === "p" ? paragraph$2 = head : (paragraph$2 = {
			type: "element",
			tagName: "p",
			properties: {},
			children: []
		}, results.unshift(paragraph$2)), paragraph$2.children.length > 0 && paragraph$2.children.unshift({
			type: "text",
			value: " "
		}), paragraph$2.children.unshift({
			type: "element",
			tagName: "input",
			properties: {
				type: "checkbox",
				checked: node$1.checked,
				disabled: !0
			},
			children: []
		}), properties.className = ["task-list-item"];
	}
	let index$2 = -1;
	for (; ++index$2 < results.length;) {
		let child = results[index$2];
		(loose || index$2 !== 0 || child.type !== "element" || child.tagName !== "p") && children.push({
			type: "text",
			value: "\n"
		}), child.type === "element" && child.tagName === "p" && !loose ? children.push(...child.children) : children.push(child);
	}
	let tail = results[results.length - 1];
	tail && (loose || tail.type !== "element" || tail.tagName !== "p") && children.push({
		type: "text",
		value: "\n"
	});
	let result = {
		type: "element",
		tagName: "li",
		properties,
		children
	};
	return state.patch(node$1, result), state.applyData(node$1, result);
}
function listLoose(node$1) {
	let loose = !1;
	if (node$1.type === "list") {
		loose = node$1.spread || !1;
		let children = node$1.children, index$2 = -1;
		for (; !loose && ++index$2 < children.length;) loose = listItemLoose(children[index$2]);
	}
	return loose;
}
function listItemLoose(node$1) {
	return node$1.spread ?? node$1.children.length > 1;
}
function list$1(state, node$1) {
	let properties = {}, results = state.all(node$1), index$2 = -1;
	for (typeof node$1.start == "number" && node$1.start !== 1 && (properties.start = node$1.start); ++index$2 < results.length;) {
		let child = results[index$2];
		if (child.type === "element" && child.tagName === "li" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes("task-list-item")) {
			properties.className = ["contains-task-list"];
			break;
		}
	}
	let result = {
		type: "element",
		tagName: node$1.ordered ? "ol" : "ul",
		properties,
		children: state.wrap(results, !0)
	};
	return state.patch(node$1, result), state.applyData(node$1, result);
}
function paragraph$1(state, node$1) {
	let result = {
		type: "element",
		tagName: "p",
		properties: {},
		children: state.all(node$1)
	};
	return state.patch(node$1, result), state.applyData(node$1, result);
}
function root$1(state, node$1) {
	let result = {
		type: "root",
		children: state.wrap(state.all(node$1))
	};
	return state.patch(node$1, result), state.applyData(node$1, result);
}
function strong$1(state, node$1) {
	let result = {
		type: "element",
		tagName: "strong",
		properties: {},
		children: state.all(node$1)
	};
	return state.patch(node$1, result), state.applyData(node$1, result);
}
function table(state, node$1) {
	let rows = state.all(node$1), firstRow = rows.shift(), tableContent = [];
	if (firstRow) {
		let head = {
			type: "element",
			tagName: "thead",
			properties: {},
			children: state.wrap([firstRow], !0)
		};
		state.patch(node$1.children[0], head), tableContent.push(head);
	}
	if (rows.length > 0) {
		let body = {
			type: "element",
			tagName: "tbody",
			properties: {},
			children: state.wrap(rows, !0)
		}, start = pointStart(node$1.children[1]), end = pointEnd(node$1.children[node$1.children.length - 1]);
		start && end && (body.position = {
			start,
			end
		}), tableContent.push(body);
	}
	let result = {
		type: "element",
		tagName: "table",
		properties: {},
		children: state.wrap(tableContent, !0)
	};
	return state.patch(node$1, result), state.applyData(node$1, result);
}
function tableRow(state, node$1, parent) {
	let siblings = parent ? parent.children : void 0, tagName = (siblings ? siblings.indexOf(node$1) : 1) === 0 ? "th" : "td", align = parent && parent.type === "table" ? parent.align : void 0, length = align ? align.length : node$1.children.length, cellIndex = -1, cells = [];
	for (; ++cellIndex < length;) {
		let cell$1 = node$1.children[cellIndex], properties = {}, alignValue = align ? align[cellIndex] : void 0;
		alignValue && (properties.align = alignValue);
		let result$1 = {
			type: "element",
			tagName,
			properties,
			children: []
		};
		cell$1 && (result$1.children = state.all(cell$1), state.patch(cell$1, result$1), result$1 = state.applyData(cell$1, result$1)), cells.push(result$1);
	}
	let result = {
		type: "element",
		tagName: "tr",
		properties: {},
		children: state.wrap(cells, !0)
	};
	return state.patch(node$1, result), state.applyData(node$1, result);
}
function tableCell(state, node$1) {
	let result = {
		type: "element",
		tagName: "td",
		properties: {},
		children: state.all(node$1)
	};
	return state.patch(node$1, result), state.applyData(node$1, result);
}
var tab = 9, space = 32;
function trimLines(value) {
	let source$2 = String(value), search$1 = /\r?\n|\r/g, match = search$1.exec(source$2), last = 0, lines = [];
	for (; match;) lines.push(trimLine(source$2.slice(last, match.index), last > 0, !0), match[0]), last = match.index + match[0].length, match = search$1.exec(source$2);
	return lines.push(trimLine(source$2.slice(last), last > 0, !1)), lines.join("");
}
function trimLine(value, start, end) {
	let startIndex = 0, endIndex = value.length;
	if (start) {
		let code$4 = value.codePointAt(startIndex);
		for (; code$4 === tab || code$4 === space;) startIndex++, code$4 = value.codePointAt(startIndex);
	}
	if (end) {
		let code$4 = value.codePointAt(endIndex - 1);
		for (; code$4 === tab || code$4 === space;) endIndex--, code$4 = value.codePointAt(endIndex - 1);
	}
	return endIndex > startIndex ? value.slice(startIndex, endIndex) : "";
}
function text$2(state, node$1) {
	let result = {
		type: "text",
		value: trimLines(String(node$1.value))
	};
	return state.patch(node$1, result), state.applyData(node$1, result);
}
function thematicBreak$1(state, node$1) {
	let result = {
		type: "element",
		tagName: "hr",
		properties: {},
		children: []
	};
	return state.patch(node$1, result), state.applyData(node$1, result);
}
const handlers = {
	blockquote: blockquote$1,
	break: hardBreak$1,
	code: code$3,
	delete: strikethrough,
	emphasis: emphasis$1,
	footnoteReference: footnoteReference$1,
	heading: heading$1,
	html: html$1,
	imageReference: imageReference$1,
	image: image$1,
	inlineCode: inlineCode$1,
	linkReference: linkReference$1,
	link: link$1,
	listItem: listItem$1,
	list: list$1,
	paragraph: paragraph$1,
	root: root$1,
	strong: strong$1,
	table,
	tableCell,
	tableRow,
	text: text$2,
	thematicBreak: thematicBreak$1,
	toml: ignore,
	yaml: ignore,
	definition: ignore,
	footnoteDefinition: ignore
};
function ignore() {}
const VOID = -1, PRIMITIVE = 0, ARRAY = 1, OBJECT = 2, DATE = 3, REGEXP = 4, MAP = 5, SET = 6, ERROR = 7, BIGINT = 8;
var env = typeof self == "object" ? self : globalThis, deserializer = ($, _) => {
	let as = (out, index$2) => ($.set(index$2, out), out), unpair = (index$2) => {
		if ($.has(index$2)) return $.get(index$2);
		let [type, value] = _[index$2];
		switch (type) {
			case 0:
			case -1: return as(value, index$2);
			case 1: {
				let arr = as([], index$2);
				for (let index$3 of value) arr.push(unpair(index$3));
				return arr;
			}
			case 2: {
				let object = as({}, index$2);
				for (let [key, index$3] of value) object[unpair(key)] = unpair(index$3);
				return object;
			}
			case 3: return as(new Date(value), index$2);
			case 4: {
				let { source: source$2, flags } = value;
				return as(new RegExp(source$2, flags), index$2);
			}
			case 5: {
				let map$2 = as(/* @__PURE__ */ new Map(), index$2);
				for (let [key, index$3] of value) map$2.set(unpair(key), unpair(index$3));
				return map$2;
			}
			case 6: {
				let set = as(/* @__PURE__ */ new Set(), index$2);
				for (let index$3 of value) set.add(unpair(index$3));
				return set;
			}
			case 7: {
				let { name: name$1, message } = value;
				return as(new env[name$1](message), index$2);
			}
			case 8: return as(BigInt(value), index$2);
			case "BigInt": return as(Object(BigInt(value)), index$2);
			case "ArrayBuffer": return as(new Uint8Array(value).buffer, value);
			case "DataView": {
				let { buffer } = new Uint8Array(value);
				return as(new DataView(buffer), value);
			}
		}
		return as(new env[type](value), index$2);
	};
	return unpair;
};
const deserialize = (serialized) => deserializer(/* @__PURE__ */ new Map(), serialized)(0);
var EMPTY = "", { toString: toString$3 } = {}, { keys } = Object, typeOf$4 = (value) => {
	let type = typeof value;
	if (type !== "object" || !value) return [0, type];
	let asString = toString$3.call(value).slice(8, -1);
	switch (asString) {
		case "Array": return [1, EMPTY];
		case "Object": return [2, EMPTY];
		case "Date": return [3, EMPTY];
		case "RegExp": return [4, EMPTY];
		case "Map": return [5, EMPTY];
		case "Set": return [6, EMPTY];
		case "DataView": return [1, asString];
	}
	return asString.includes("Array") ? [1, asString] : asString.includes("Error") ? [7, asString] : [2, asString];
}, shouldSkip = ([TYPE, type]) => TYPE === 0 && (type === "function" || type === "symbol"), serializer = (strict, json$1, $, _) => {
	let as = (out, value) => {
		let index$2 = _.push(out) - 1;
		return $.set(value, index$2), index$2;
	}, pair = (value) => {
		if ($.has(value)) return $.get(value);
		let [TYPE, type] = typeOf$4(value);
		switch (TYPE) {
			case 0: {
				let entry = value;
				switch (type) {
					case "bigint":
						TYPE = 8, entry = value.toString();
						break;
					case "function":
					case "symbol":
						if (strict) throw TypeError("unable to serialize " + type);
						entry = null;
						break;
					case "undefined": return as([-1], value);
				}
				return as([TYPE, entry], value);
			}
			case 1: {
				if (type) {
					let spread = value;
					return type === "DataView" ? spread = new Uint8Array(value.buffer) : type === "ArrayBuffer" && (spread = new Uint8Array(value)), as([type, [...spread]], value);
				}
				let arr = [], index$2 = as([TYPE, arr], value);
				for (let entry of value) arr.push(pair(entry));
				return index$2;
			}
			case 2: {
				if (type) switch (type) {
					case "BigInt": return as([type, value.toString()], value);
					case "Boolean":
					case "Number":
					case "String": return as([type, value.valueOf()], value);
				}
				if (json$1 && "toJSON" in value) return pair(value.toJSON());
				let entries = [], index$2 = as([TYPE, entries], value);
				for (let key of keys(value)) (strict || !shouldSkip(typeOf$4(value[key]))) && entries.push([pair(key), pair(value[key])]);
				return index$2;
			}
			case 3: return as([TYPE, value.toISOString()], value);
			case 4: {
				let { source: source$2, flags } = value;
				return as([TYPE, {
					source: source$2,
					flags
				}], value);
			}
			case 5: {
				let entries = [], index$2 = as([TYPE, entries], value);
				for (let [key, entry] of value) (strict || !(shouldSkip(typeOf$4(key)) || shouldSkip(typeOf$4(entry)))) && entries.push([pair(key), pair(entry)]);
				return index$2;
			}
			case 6: {
				let entries = [], index$2 = as([TYPE, entries], value);
				for (let entry of value) (strict || !shouldSkip(typeOf$4(entry))) && entries.push(pair(entry));
				return index$2;
			}
		}
		let { message } = value;
		return as([TYPE, {
			name: type,
			message
		}], value);
	};
	return pair;
};
const serialize$1 = (value, { json: json$1, lossy } = {}) => {
	let _ = [];
	return serializer(!(json$1 || lossy), !!json$1, /* @__PURE__ */ new Map(), _)(value), _;
};
var esm_default = typeof structuredClone == "function" ? (any, options) => options && ("json" in options || "lossy" in options) ? deserialize(serialize$1(any, options)) : structuredClone(any) : (any, options) => deserialize(serialize$1(any, options));
function defaultFootnoteBackContent(_, rereferenceIndex) {
	let result = [{
		type: "text",
		value: "â†©"
	}];
	return rereferenceIndex > 1 && result.push({
		type: "element",
		tagName: "sup",
		properties: {},
		children: [{
			type: "text",
			value: String(rereferenceIndex)
		}]
	}), result;
}
function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {
	return "Back to reference " + (referenceIndex + 1) + (rereferenceIndex > 1 ? "-" + rereferenceIndex : "");
}
function footer(state) {
	let clobberPrefix = typeof state.options.clobberPrefix == "string" ? state.options.clobberPrefix : "user-content-", footnoteBackContent = state.options.footnoteBackContent || defaultFootnoteBackContent, footnoteBackLabel = state.options.footnoteBackLabel || defaultFootnoteBackLabel, footnoteLabel = state.options.footnoteLabel || "Footnotes", footnoteLabelTagName = state.options.footnoteLabelTagName || "h2", footnoteLabelProperties = state.options.footnoteLabelProperties || { className: ["sr-only"] }, listItems = [], referenceIndex = -1;
	for (; ++referenceIndex < state.footnoteOrder.length;) {
		let definition$2 = state.footnoteById.get(state.footnoteOrder[referenceIndex]);
		if (!definition$2) continue;
		let content$2 = state.all(definition$2), id = String(definition$2.identifier).toUpperCase(), safeId = normalizeUri(id.toLowerCase()), rereferenceIndex = 0, backReferences = [], counts = state.footnoteCounts.get(id);
		for (; counts !== void 0 && ++rereferenceIndex <= counts;) {
			backReferences.length > 0 && backReferences.push({
				type: "text",
				value: " "
			});
			let children = typeof footnoteBackContent == "string" ? footnoteBackContent : footnoteBackContent(referenceIndex, rereferenceIndex);
			typeof children == "string" && (children = {
				type: "text",
				value: children
			}), backReferences.push({
				type: "element",
				tagName: "a",
				properties: {
					href: "#" + clobberPrefix + "fnref-" + safeId + (rereferenceIndex > 1 ? "-" + rereferenceIndex : ""),
					dataFootnoteBackref: "",
					ariaLabel: typeof footnoteBackLabel == "string" ? footnoteBackLabel : footnoteBackLabel(referenceIndex, rereferenceIndex),
					className: ["data-footnote-backref"]
				},
				children: Array.isArray(children) ? children : [children]
			});
		}
		let tail = content$2[content$2.length - 1];
		if (tail && tail.type === "element" && tail.tagName === "p") {
			let tailTail = tail.children[tail.children.length - 1];
			tailTail && tailTail.type === "text" ? tailTail.value += " " : tail.children.push({
				type: "text",
				value: " "
			}), tail.children.push(...backReferences);
		} else content$2.push(...backReferences);
		let listItem$2 = {
			type: "element",
			tagName: "li",
			properties: { id: clobberPrefix + "fn-" + safeId },
			children: state.wrap(content$2, !0)
		};
		state.patch(definition$2, listItem$2), listItems.push(listItem$2);
	}
	if (listItems.length !== 0) return {
		type: "element",
		tagName: "section",
		properties: {
			dataFootnotes: !0,
			className: ["footnotes"]
		},
		children: [
			{
				type: "element",
				tagName: footnoteLabelTagName,
				properties: {
					...esm_default(footnoteLabelProperties),
					id: "footnote-label"
				},
				children: [{
					type: "text",
					value: footnoteLabel
				}]
			},
			{
				type: "text",
				value: "\n"
			},
			{
				type: "element",
				tagName: "ol",
				properties: {},
				children: state.wrap(listItems, !0)
			},
			{
				type: "text",
				value: "\n"
			}
		]
	};
}
const convert = (function(test) {
	if (test == null) return ok$1;
	if (typeof test == "function") return castFactory$1(test);
	if (typeof test == "object") return Array.isArray(test) ? anyFactory$1(test) : propertiesFactory(test);
	if (typeof test == "string") return typeFactory(test);
	throw Error("Expected function, string, or object as test");
});
function anyFactory$1(tests) {
	let checks$1 = [], index$2 = -1;
	for (; ++index$2 < tests.length;) checks$1[index$2] = convert(tests[index$2]);
	return castFactory$1(any);
	function any(...parameters) {
		let index$3 = -1;
		for (; ++index$3 < checks$1.length;) if (checks$1[index$3].apply(this, parameters)) return !0;
		return !1;
	}
}
function propertiesFactory(check) {
	let checkAsRecord = check;
	return castFactory$1(all$2);
	function all$2(node$1) {
		let nodeAsRecord = node$1, key;
		for (key in check) if (nodeAsRecord[key] !== checkAsRecord[key]) return !1;
		return !0;
	}
}
function typeFactory(check) {
	return castFactory$1(type);
	function type(node$1) {
		return node$1 && node$1.type === check;
	}
}
function castFactory$1(testFunction) {
	return check;
	function check(value, index$2, parent) {
		return !!(looksLikeANode(value) && testFunction.call(this, value, typeof index$2 == "number" ? index$2 : void 0, parent || void 0));
	}
}
function ok$1() {
	return !0;
}
function looksLikeANode(value) {
	return typeof value == "object" && !!value && "type" in value;
}
function color(d) {
	return d;
}
var empty = [];
const CONTINUE = !0, EXIT = !1, SKIP = "skip";
function visitParents(tree, test, visitor, reverse) {
	let check;
	typeof test == "function" && typeof visitor != "function" ? (reverse = visitor, visitor = test) : check = test;
	let is = convert(check), step = reverse ? -1 : 1;
	factory(tree, void 0, [])();
	function factory(node$1, index$2, parents) {
		let value = node$1 && typeof node$1 == "object" ? node$1 : {};
		if (typeof value.type == "string") {
			let name$1 = typeof value.tagName == "string" ? value.tagName : typeof value.name == "string" ? value.name : void 0;
			Object.defineProperty(visit$1, "name", { value: "node (" + color(node$1.type + (name$1 ? "<" + name$1 + ">" : "")) + ")" });
		}
		return visit$1;
		function visit$1() {
			let result = empty, subresult, offset, grandparents;
			if ((!test || is(node$1, index$2, parents[parents.length - 1] || void 0)) && (result = toResult(visitor(node$1, parents)), result[0] === !1)) return result;
			if ("children" in node$1 && node$1.children) {
				let nodeAsParent = node$1;
				if (nodeAsParent.children && result[0] !== "skip") for (offset = (reverse ? nodeAsParent.children.length : -1) + step, grandparents = parents.concat(nodeAsParent); offset > -1 && offset < nodeAsParent.children.length;) {
					let child = nodeAsParent.children[offset];
					if (subresult = factory(child, offset, grandparents)(), subresult[0] === !1) return subresult;
					offset = typeof subresult[1] == "number" ? subresult[1] : offset + step;
				}
			}
			return result;
		}
	}
}
function toResult(value) {
	return Array.isArray(value) ? value : typeof value == "number" ? [!0, value] : value == null ? empty : [value];
}
function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
	let reverse, test, visitor;
	typeof testOrVisitor == "function" && typeof visitorOrReverse != "function" ? (test = void 0, visitor = testOrVisitor, reverse = visitorOrReverse) : (test = testOrVisitor, visitor = visitorOrReverse, reverse = maybeReverse), visitParents(tree, test, overload, reverse);
	function overload(node$1, parents) {
		let parent = parents[parents.length - 1], index$2 = parent ? parent.children.indexOf(node$1) : void 0;
		return visitor(node$1, index$2, parent);
	}
}
var own$2 = {}.hasOwnProperty, emptyOptions$4 = {};
function createState(tree, options) {
	let settings = options || emptyOptions$4, definitionById = /* @__PURE__ */ new Map(), footnoteById = /* @__PURE__ */ new Map(), state = {
		all: all$2,
		applyData,
		definitionById,
		footnoteById,
		footnoteCounts: /* @__PURE__ */ new Map(),
		footnoteOrder: [],
		handlers: {
			...handlers,
			...settings.handlers
		},
		one: one$3,
		options: settings,
		patch,
		wrap: wrap$1
	};
	return visit(tree, function(node$1) {
		if (node$1.type === "definition" || node$1.type === "footnoteDefinition") {
			let map$2 = node$1.type === "definition" ? definitionById : footnoteById, id = String(node$1.identifier).toUpperCase();
			map$2.has(id) || map$2.set(id, node$1);
		}
	}), state;
	function one$3(node$1, parent) {
		let type = node$1.type, handle$1 = state.handlers[type];
		if (own$2.call(state.handlers, type) && handle$1) return handle$1(state, node$1, parent);
		if (state.options.passThrough && state.options.passThrough.includes(type)) {
			if ("children" in node$1) {
				let { children, ...shallow } = node$1, result = esm_default(shallow);
				return result.children = state.all(node$1), result;
			}
			return esm_default(node$1);
		}
		return (state.options.unknownHandler || defaultUnknownHandler)(state, node$1, parent);
	}
	function all$2(parent) {
		let values = [];
		if ("children" in parent) {
			let nodes = parent.children, index$2 = -1;
			for (; ++index$2 < nodes.length;) {
				let result = state.one(nodes[index$2], parent);
				if (result) {
					if (index$2 && nodes[index$2 - 1].type === "break" && (!Array.isArray(result) && result.type === "text" && (result.value = trimMarkdownSpaceStart(result.value)), !Array.isArray(result) && result.type === "element")) {
						let head = result.children[0];
						head && head.type === "text" && (head.value = trimMarkdownSpaceStart(head.value));
					}
					Array.isArray(result) ? values.push(...result) : values.push(result);
				}
			}
		}
		return values;
	}
}
function patch(from$1, to) {
	from$1.position && (to.position = position(from$1));
}
function applyData(from$1, to) {
	let result = to;
	if (from$1 && from$1.data) {
		let hName = from$1.data.hName, hChildren = from$1.data.hChildren, hProperties = from$1.data.hProperties;
		typeof hName == "string" && (result.type === "element" ? result.tagName = hName : result = {
			type: "element",
			tagName: hName,
			properties: {},
			children: "children" in result ? result.children : [result]
		}), result.type === "element" && hProperties && Object.assign(result.properties, esm_default(hProperties)), "children" in result && result.children && hChildren != null && (result.children = hChildren);
	}
	return result;
}
function defaultUnknownHandler(state, node$1) {
	let data = node$1.data || {}, result = "value" in node$1 && !(own$2.call(data, "hProperties") || own$2.call(data, "hChildren")) ? {
		type: "text",
		value: node$1.value
	} : {
		type: "element",
		tagName: "div",
		properties: {},
		children: state.all(node$1)
	};
	return state.patch(node$1, result), state.applyData(node$1, result);
}
function wrap$1(nodes, loose) {
	let result = [], index$2 = -1;
	for (loose && result.push({
		type: "text",
		value: "\n"
	}); ++index$2 < nodes.length;) index$2 && result.push({
		type: "text",
		value: "\n"
	}), result.push(nodes[index$2]);
	return loose && nodes.length > 0 && result.push({
		type: "text",
		value: "\n"
	}), result;
}
function trimMarkdownSpaceStart(value) {
	let index$2 = 0, code$4 = value.charCodeAt(index$2);
	for (; code$4 === 9 || code$4 === 32;) index$2++, code$4 = value.charCodeAt(index$2);
	return value.slice(index$2);
}
function toHast(tree, options) {
	let state = createState(tree, options), node$1 = state.one(tree, void 0), foot = footer(state), result = Array.isArray(node$1) ? {
		type: "root",
		children: node$1
	} : node$1 || {
		type: "root",
		children: []
	};
	return foot && ("children" in result, result.children.push({
		type: "text",
		value: "\n"
	}, foot)), result;
}
function remarkRehype(destination, options) {
	return destination && "run" in destination ? async function(tree, file) {
		let hastTree = toHast(tree, {
			file,
			...options
		});
		await destination.run(hastTree, file);
	} : function(tree, file) {
		return toHast(tree, {
			file,
			...destination || options
		});
	};
}
function bail(error$1) {
	if (error$1) throw error$1;
}
var require_extend = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var hasOwn$1 = Object.prototype.hasOwnProperty, toStr = Object.prototype.toString, defineProperty = Object.defineProperty, gOPD = Object.getOwnPropertyDescriptor, isArray$1 = function(arr) {
		return typeof Array.isArray == "function" ? Array.isArray(arr) : toStr.call(arr) === "[object Array]";
	}, isPlainObject$1 = function(obj) {
		if (!obj || toStr.call(obj) !== "[object Object]") return !1;
		var hasOwnConstructor = hasOwn$1.call(obj, "constructor"), hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn$1.call(obj.constructor.prototype, "isPrototypeOf");
		if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) return !1;
		for (var key in obj);
		return key === void 0 || hasOwn$1.call(obj, key);
	}, setProperty$1 = function(target, options) {
		defineProperty && options.name === "__proto__" ? defineProperty(target, options.name, {
			enumerable: !0,
			configurable: !0,
			value: options.newValue,
			writable: !0
		}) : target[options.name] = options.newValue;
	}, getProperty = function(obj, name$1) {
		if (name$1 === "__proto__") if (hasOwn$1.call(obj, name$1)) {
			if (gOPD) return gOPD(obj, name$1).value;
		} else return;
		return obj[name$1];
	};
	module.exports = function extend$3() {
		var options, name$1, src, copy, copyIsArray, clone, target = arguments[0], i$2 = 1, length = arguments.length, deep = !1;
		for (typeof target == "boolean" && (deep = target, target = arguments[1] || {}, i$2 = 2), (target == null || typeof target != "object" && typeof target != "function") && (target = {}); i$2 < length; ++i$2) if (options = arguments[i$2], options != null) for (name$1 in options) src = getProperty(target, name$1), copy = getProperty(options, name$1), target !== copy && (deep && copy && (isPlainObject$1(copy) || (copyIsArray = isArray$1(copy))) ? (copyIsArray ? (copyIsArray = !1, clone = src && isArray$1(src) ? src : []) : clone = src && isPlainObject$1(src) ? src : {}, setProperty$1(target, {
			name: name$1,
			newValue: extend$3(deep, clone, copy)
		})) : copy !== void 0 && setProperty$1(target, {
			name: name$1,
			newValue: copy
		}));
		return target;
	};
}));
function isPlainObject(value) {
	if (typeof value != "object" || !value) return !1;
	let prototype = Object.getPrototypeOf(value);
	return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}
function trough() {
	let fns = [], pipeline = {
		run,
		use
	};
	return pipeline;
	function run(...values) {
		let middlewareIndex = -1, callback = values.pop();
		if (typeof callback != "function") throw TypeError("Expected function as last argument, not " + callback);
		next(null, ...values);
		function next(error$1, ...output) {
			let fn = fns[++middlewareIndex], index$2 = -1;
			if (error$1) {
				callback(error$1);
				return;
			}
			for (; ++index$2 < values.length;) (output[index$2] === null || output[index$2] === void 0) && (output[index$2] = values[index$2]);
			values = output, fn ? wrap(fn, next)(...output) : callback(null, ...output);
		}
	}
	function use(middelware) {
		if (typeof middelware != "function") throw TypeError("Expected `middelware` to be a function, not " + middelware);
		return fns.push(middelware), pipeline;
	}
}
function wrap(middleware, callback) {
	let called;
	return wrapped;
	function wrapped(...parameters) {
		let fnExpectsCallback = middleware.length > parameters.length, result;
		fnExpectsCallback && parameters.push(done);
		try {
			result = middleware.apply(this, parameters);
		} catch (error$1) {
			let exception = error$1;
			if (fnExpectsCallback && called) throw exception;
			return done(exception);
		}
		fnExpectsCallback || (result && result.then && typeof result.then == "function" ? result.then(then, done) : result instanceof Error ? done(result) : then(result));
	}
	function done(error$1, ...output) {
		called || (called = !0, callback(error$1, ...output));
	}
	function then(value) {
		done(null, value);
	}
}
const minpath = {
	basename,
	dirname,
	extname,
	join,
	sep: "/"
};
function basename(path$1, extname$1) {
	if (extname$1 !== void 0 && typeof extname$1 != "string") throw TypeError("\"ext\" argument must be a string");
	assertPath$1(path$1);
	let start = 0, end = -1, index$2 = path$1.length, seenNonSlash;
	if (extname$1 === void 0 || extname$1.length === 0 || extname$1.length > path$1.length) {
		for (; index$2--;) if (path$1.codePointAt(index$2) === 47) {
			if (seenNonSlash) {
				start = index$2 + 1;
				break;
			}
		} else end < 0 && (seenNonSlash = !0, end = index$2 + 1);
		return end < 0 ? "" : path$1.slice(start, end);
	}
	if (extname$1 === path$1) return "";
	let firstNonSlashEnd = -1, extnameIndex = extname$1.length - 1;
	for (; index$2--;) if (path$1.codePointAt(index$2) === 47) {
		if (seenNonSlash) {
			start = index$2 + 1;
			break;
		}
	} else firstNonSlashEnd < 0 && (seenNonSlash = !0, firstNonSlashEnd = index$2 + 1), extnameIndex > -1 && (path$1.codePointAt(index$2) === extname$1.codePointAt(extnameIndex--) ? extnameIndex < 0 && (end = index$2) : (extnameIndex = -1, end = firstNonSlashEnd));
	return start === end ? end = firstNonSlashEnd : end < 0 && (end = path$1.length), path$1.slice(start, end);
}
function dirname(path$1) {
	if (assertPath$1(path$1), path$1.length === 0) return ".";
	let end = -1, index$2 = path$1.length, unmatchedSlash;
	for (; --index$2;) if (path$1.codePointAt(index$2) === 47) {
		if (unmatchedSlash) {
			end = index$2;
			break;
		}
	} else unmatchedSlash ||= !0;
	return end < 0 ? path$1.codePointAt(0) === 47 ? "/" : "." : end === 1 && path$1.codePointAt(0) === 47 ? "//" : path$1.slice(0, end);
}
function extname(path$1) {
	assertPath$1(path$1);
	let index$2 = path$1.length, end = -1, startPart = 0, startDot = -1, preDotState = 0, unmatchedSlash;
	for (; index$2--;) {
		let code$4 = path$1.codePointAt(index$2);
		if (code$4 === 47) {
			if (unmatchedSlash) {
				startPart = index$2 + 1;
				break;
			}
			continue;
		}
		end < 0 && (unmatchedSlash = !0, end = index$2 + 1), code$4 === 46 ? startDot < 0 ? startDot = index$2 : preDotState !== 1 && (preDotState = 1) : startDot > -1 && (preDotState = -1);
	}
	return startDot < 0 || end < 0 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1 ? "" : path$1.slice(startDot, end);
}
function join(...segments) {
	let index$2 = -1, joined;
	for (; ++index$2 < segments.length;) assertPath$1(segments[index$2]), segments[index$2] && (joined = joined === void 0 ? segments[index$2] : joined + "/" + segments[index$2]);
	return joined === void 0 ? "." : normalize(joined);
}
function normalize(path$1) {
	assertPath$1(path$1);
	let absolute = path$1.codePointAt(0) === 47, value = normalizeString(path$1, !absolute);
	return value.length === 0 && !absolute && (value = "."), value.length > 0 && path$1.codePointAt(path$1.length - 1) === 47 && (value += "/"), absolute ? "/" + value : value;
}
function normalizeString(path$1, allowAboveRoot) {
	let result = "", lastSegmentLength = 0, lastSlash = -1, dots = 0, index$2 = -1, code$4, lastSlashIndex;
	for (; ++index$2 <= path$1.length;) {
		if (index$2 < path$1.length) code$4 = path$1.codePointAt(index$2);
		else if (code$4 === 47) break;
		else code$4 = 47;
		if (code$4 === 47) {
			if (!(lastSlash === index$2 - 1 || dots === 1)) if (lastSlash !== index$2 - 1 && dots === 2) {
				if (result.length < 2 || lastSegmentLength !== 2 || result.codePointAt(result.length - 1) !== 46 || result.codePointAt(result.length - 2) !== 46) {
					if (result.length > 2) {
						if (lastSlashIndex = result.lastIndexOf("/"), lastSlashIndex !== result.length - 1) {
							lastSlashIndex < 0 ? (result = "", lastSegmentLength = 0) : (result = result.slice(0, lastSlashIndex), lastSegmentLength = result.length - 1 - result.lastIndexOf("/")), lastSlash = index$2, dots = 0;
							continue;
						}
					} else if (result.length > 0) {
						result = "", lastSegmentLength = 0, lastSlash = index$2, dots = 0;
						continue;
					}
				}
				allowAboveRoot && (result = result.length > 0 ? result + "/.." : "..", lastSegmentLength = 2);
			} else result.length > 0 ? result += "/" + path$1.slice(lastSlash + 1, index$2) : result = path$1.slice(lastSlash + 1, index$2), lastSegmentLength = index$2 - lastSlash - 1;
			lastSlash = index$2, dots = 0;
		} else code$4 === 46 && dots > -1 ? dots++ : dots = -1;
	}
	return result;
}
function assertPath$1(path$1) {
	if (typeof path$1 != "string") throw TypeError("Path must be a string. Received " + JSON.stringify(path$1));
}
const minproc = { cwd };
function cwd() {
	return "/";
}
function isUrl(fileUrlOrPath) {
	return !!(typeof fileUrlOrPath == "object" && fileUrlOrPath && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && fileUrlOrPath.auth === void 0);
}
function urlToPath(path$1) {
	if (typeof path$1 == "string") path$1 = new URL(path$1);
	else if (!isUrl(path$1)) {
		let error$1 = /* @__PURE__ */ TypeError("The \"path\" argument must be of type string or an instance of URL. Received `" + path$1 + "`");
		throw error$1.code = "ERR_INVALID_ARG_TYPE", error$1;
	}
	if (path$1.protocol !== "file:") {
		let error$1 = /* @__PURE__ */ TypeError("The URL must be of scheme file");
		throw error$1.code = "ERR_INVALID_URL_SCHEME", error$1;
	}
	return getPathFromURLPosix(path$1);
}
function getPathFromURLPosix(url) {
	if (url.hostname !== "") {
		let error$1 = /* @__PURE__ */ TypeError("File URL host must be \"localhost\" or empty on darwin");
		throw error$1.code = "ERR_INVALID_FILE_URL_HOST", error$1;
	}
	let pathname = url.pathname, index$2 = -1;
	for (; ++index$2 < pathname.length;) if (pathname.codePointAt(index$2) === 37 && pathname.codePointAt(index$2 + 1) === 50) {
		let third = pathname.codePointAt(index$2 + 2);
		if (third === 70 || third === 102) {
			let error$1 = /* @__PURE__ */ TypeError("File URL path must not include encoded / characters");
			throw error$1.code = "ERR_INVALID_FILE_URL_PATH", error$1;
		}
	}
	return decodeURIComponent(pathname);
}
var order = [
	"history",
	"path",
	"basename",
	"stem",
	"extname",
	"dirname"
], VFile = class {
	constructor(value) {
		let options;
		options = value ? isUrl(value) ? { path: value } : typeof value == "string" || isUint8Array$1(value) ? { value } : value : {}, this.cwd = "cwd" in options ? "" : minproc.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
		let index$2 = -1;
		for (; ++index$2 < order.length;) {
			let field$1 = order[index$2];
			field$1 in options && options[field$1] !== void 0 && options[field$1] !== null && (this[field$1] = field$1 === "history" ? [...options[field$1]] : options[field$1]);
		}
		let field;
		for (field in options) order.includes(field) || (this[field] = options[field]);
	}
	get basename() {
		return typeof this.path == "string" ? minpath.basename(this.path) : void 0;
	}
	set basename(basename$1) {
		assertNonEmpty(basename$1, "basename"), assertPart(basename$1, "basename"), this.path = minpath.join(this.dirname || "", basename$1);
	}
	get dirname() {
		return typeof this.path == "string" ? minpath.dirname(this.path) : void 0;
	}
	set dirname(dirname$1) {
		assertPath(this.basename, "dirname"), this.path = minpath.join(dirname$1 || "", this.basename);
	}
	get extname() {
		return typeof this.path == "string" ? minpath.extname(this.path) : void 0;
	}
	set extname(extname$1) {
		if (assertPart(extname$1, "extname"), assertPath(this.dirname, "extname"), extname$1) {
			if (extname$1.codePointAt(0) !== 46) throw Error("`extname` must start with `.`");
			if (extname$1.includes(".", 1)) throw Error("`extname` cannot contain multiple dots");
		}
		this.path = minpath.join(this.dirname, this.stem + (extname$1 || ""));
	}
	get path() {
		return this.history[this.history.length - 1];
	}
	set path(path$1) {
		isUrl(path$1) && (path$1 = urlToPath(path$1)), assertNonEmpty(path$1, "path"), this.path !== path$1 && this.history.push(path$1);
	}
	get stem() {
		return typeof this.path == "string" ? minpath.basename(this.path, this.extname) : void 0;
	}
	set stem(stem) {
		assertNonEmpty(stem, "stem"), assertPart(stem, "stem"), this.path = minpath.join(this.dirname || "", stem + (this.extname || ""));
	}
	fail(causeOrReason, optionsOrParentOrPlace, origin) {
		let message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
		throw message.fatal = !0, message;
	}
	info(causeOrReason, optionsOrParentOrPlace, origin) {
		let message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
		return message.fatal = void 0, message;
	}
	message(causeOrReason, optionsOrParentOrPlace, origin) {
		let message = new VFileMessage(causeOrReason, optionsOrParentOrPlace, origin);
		return this.path && (message.name = this.path + ":" + message.name, message.file = this.path), message.fatal = !1, this.messages.push(message), message;
	}
	toString(encoding) {
		return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(encoding || void 0).decode(this.value);
	}
};
function assertPart(part, name$1) {
	if (part && part.includes(minpath.sep)) throw Error("`" + name$1 + "` cannot be a path: did not expect `" + minpath.sep + "`");
}
function assertNonEmpty(part, name$1) {
	if (!part) throw Error("`" + name$1 + "` cannot be empty");
}
function assertPath(path$1, name$1) {
	if (!path$1) throw Error("Setting `" + name$1 + "` requires `path` to be set too");
}
function isUint8Array$1(value) {
	return !!(value && typeof value == "object" && "byteLength" in value && "byteOffset" in value);
}
const CallableInstance = (function(property) {
	let proto = this.constructor.prototype, value = proto[property], apply = function() {
		return value.apply(apply, arguments);
	};
	return Object.setPrototypeOf(apply, proto), apply;
});
var import_extend = /* @__PURE__ */ __toESM(require_extend(), 1), own$1 = {}.hasOwnProperty, Processor = class Processor extends CallableInstance {
	constructor() {
		super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = trough();
	}
	copy() {
		let destination = new Processor(), index$2 = -1;
		for (; ++index$2 < this.attachers.length;) {
			let attacher = this.attachers[index$2];
			destination.use(...attacher);
		}
		return destination.data((0, import_extend.default)(!0, {}, this.namespace)), destination;
	}
	data(key, value) {
		return typeof key == "string" ? arguments.length === 2 ? (assertUnfrozen("data", this.frozen), this.namespace[key] = value, this) : own$1.call(this.namespace, key) && this.namespace[key] || void 0 : key ? (assertUnfrozen("data", this.frozen), this.namespace = key, this) : this.namespace;
	}
	freeze() {
		if (this.frozen) return this;
		let self$1 = this;
		for (; ++this.freezeIndex < this.attachers.length;) {
			let [attacher, ...options] = this.attachers[this.freezeIndex];
			if (options[0] === !1) continue;
			options[0] === !0 && (options[0] = void 0);
			let transformer = attacher.call(self$1, ...options);
			typeof transformer == "function" && this.transformers.use(transformer);
		}
		return this.frozen = !0, this.freezeIndex = Infinity, this;
	}
	parse(file) {
		this.freeze();
		let realFile = vfile(file), parser = this.parser || this.Parser;
		return assertParser("parse", parser), parser(String(realFile), realFile);
	}
	process(file, done) {
		let self$1 = this;
		return this.freeze(), assertParser("process", this.parser || this.Parser), assertCompiler("process", this.compiler || this.Compiler), done ? executor(void 0, done) : new Promise(executor);
		function executor(resolve, reject) {
			let realFile = vfile(file), parseTree = self$1.parse(realFile);
			self$1.run(parseTree, realFile, function(error$1, tree, file$1) {
				if (error$1 || !tree || !file$1) return realDone(error$1);
				let compileTree = tree, compileResult = self$1.stringify(compileTree, file$1);
				looksLikeAValue(compileResult) ? file$1.value = compileResult : file$1.result = compileResult, realDone(error$1, file$1);
			});
			function realDone(error$1, file$1) {
				error$1 || !file$1 ? reject(error$1) : resolve ? resolve(file$1) : done(void 0, file$1);
			}
		}
	}
	processSync(file) {
		let complete = !1, result;
		return this.freeze(), assertParser("processSync", this.parser || this.Parser), assertCompiler("processSync", this.compiler || this.Compiler), this.process(file, realDone), assertDone("processSync", "process", complete), result;
		function realDone(error$1, file$1) {
			complete = !0, bail(error$1), result = file$1;
		}
	}
	run(tree, file, done) {
		assertNode(tree), this.freeze();
		let transformers = this.transformers;
		return !done && typeof file == "function" && (done = file, file = void 0), done ? executor(void 0, done) : new Promise(executor);
		function executor(resolve, reject) {
			let realFile = vfile(file);
			transformers.run(tree, realFile, realDone);
			function realDone(error$1, outputTree, file$1) {
				let resultingTree = outputTree || tree;
				error$1 ? reject(error$1) : resolve ? resolve(resultingTree) : done(void 0, resultingTree, file$1);
			}
		}
	}
	runSync(tree, file) {
		let complete = !1, result;
		return this.run(tree, file, realDone), assertDone("runSync", "run", complete), result;
		function realDone(error$1, tree$1) {
			bail(error$1), result = tree$1, complete = !0;
		}
	}
	stringify(tree, file) {
		this.freeze();
		let realFile = vfile(file), compiler$1 = this.compiler || this.Compiler;
		return assertCompiler("stringify", compiler$1), assertNode(tree), compiler$1(tree, realFile);
	}
	use(value, ...parameters) {
		let attachers = this.attachers, namespace = this.namespace;
		if (assertUnfrozen("use", this.frozen), value != null) if (typeof value == "function") addPlugin(value, parameters);
		else if (typeof value == "object") Array.isArray(value) ? addList(value) : addPreset(value);
		else throw TypeError("Expected usable value, not `" + value + "`");
		return this;
		function add(value$1) {
			if (typeof value$1 == "function") addPlugin(value$1, []);
			else if (typeof value$1 == "object") if (Array.isArray(value$1)) {
				let [plugin, ...parameters$1] = value$1;
				addPlugin(plugin, parameters$1);
			} else addPreset(value$1);
			else throw TypeError("Expected usable value, not `" + value$1 + "`");
		}
		function addPreset(result) {
			if (!("plugins" in result) && !("settings" in result)) throw Error("Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither");
			addList(result.plugins), result.settings && (namespace.settings = (0, import_extend.default)(!0, namespace.settings, result.settings));
		}
		function addList(plugins) {
			let index$2 = -1;
			if (plugins != null) if (Array.isArray(plugins)) for (; ++index$2 < plugins.length;) {
				let thing = plugins[index$2];
				add(thing);
			}
			else throw TypeError("Expected a list of plugins, not `" + plugins + "`");
		}
		function addPlugin(plugin, parameters$1) {
			let index$2 = -1, entryIndex = -1;
			for (; ++index$2 < attachers.length;) if (attachers[index$2][0] === plugin) {
				entryIndex = index$2;
				break;
			}
			if (entryIndex === -1) attachers.push([plugin, ...parameters$1]);
			else if (parameters$1.length > 0) {
				let [primary, ...rest] = parameters$1, currentPrimary = attachers[entryIndex][1];
				isPlainObject(currentPrimary) && isPlainObject(primary) && (primary = (0, import_extend.default)(!0, currentPrimary, primary)), attachers[entryIndex] = [
					plugin,
					primary,
					...rest
				];
			}
		}
	}
};
const unified = new Processor().freeze();
function assertParser(name$1, value) {
	if (typeof value != "function") throw TypeError("Cannot `" + name$1 + "` without `parser`");
}
function assertCompiler(name$1, value) {
	if (typeof value != "function") throw TypeError("Cannot `" + name$1 + "` without `compiler`");
}
function assertUnfrozen(name$1, frozen) {
	if (frozen) throw Error("Cannot call `" + name$1 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.");
}
function assertNode(node$1) {
	if (!isPlainObject(node$1) || typeof node$1.type != "string") throw TypeError("Expected node, got `" + node$1 + "`");
}
function assertDone(name$1, asyncName, complete) {
	if (!complete) throw Error("`" + name$1 + "` finished async. Use `" + asyncName + "` instead");
}
function vfile(value) {
	return looksLikeAVFile(value) ? value : new VFile(value);
}
function looksLikeAVFile(value) {
	return !!(value && typeof value == "object" && "message" in value && "messages" in value);
}
function looksLikeAValue(value) {
	return typeof value == "string" || isUint8Array(value);
}
function isUint8Array(value) {
	return !!(value && typeof value == "object" && "byteLength" in value && "byteOffset" in value);
}
var emptyPlugins = [], emptyRemarkRehypeOptions = { allowDangerousHtml: !0 }, safeProtocol = /^(https?|ircs?|mailto|xmpp)$/i, deprecations = [
	{
		from: "astPlugins",
		id: "remove-buggy-html-in-markdown-parser"
	},
	{
		from: "allowDangerousHtml",
		id: "remove-buggy-html-in-markdown-parser"
	},
	{
		from: "allowNode",
		id: "replace-allownode-allowedtypes-and-disallowedtypes",
		to: "allowElement"
	},
	{
		from: "allowedTypes",
		id: "replace-allownode-allowedtypes-and-disallowedtypes",
		to: "allowedElements"
	},
	{
		from: "className",
		id: "remove-classname"
	},
	{
		from: "disallowedTypes",
		id: "replace-allownode-allowedtypes-and-disallowedtypes",
		to: "disallowedElements"
	},
	{
		from: "escapeHtml",
		id: "remove-buggy-html-in-markdown-parser"
	},
	{
		from: "includeElementIndex",
		id: "#remove-includeelementindex"
	},
	{
		from: "includeNodeIndex",
		id: "change-includenodeindex-to-includeelementindex"
	},
	{
		from: "linkTarget",
		id: "remove-linktarget"
	},
	{
		from: "plugins",
		id: "change-plugins-to-remarkplugins",
		to: "remarkPlugins"
	},
	{
		from: "rawSourcePos",
		id: "#remove-rawsourcepos"
	},
	{
		from: "renderers",
		id: "change-renderers-to-components",
		to: "components"
	},
	{
		from: "source",
		id: "change-source-to-children",
		to: "children"
	},
	{
		from: "sourcePos",
		id: "#remove-sourcepos"
	},
	{
		from: "transformImageUri",
		id: "#add-urltransform",
		to: "urlTransform"
	},
	{
		from: "transformLinkUri",
		id: "#add-urltransform",
		to: "urlTransform"
	}
];
function Markdown(options) {
	let processor = createProcessor(options), file = createFile(options);
	return post(processor.runSync(processor.parse(file), file), options);
}
function createProcessor(options) {
	let rehypePlugins = options.rehypePlugins || emptyPlugins, remarkPlugins = options.remarkPlugins || emptyPlugins, remarkRehypeOptions = options.remarkRehypeOptions ? {
		...options.remarkRehypeOptions,
		...emptyRemarkRehypeOptions
	} : emptyRemarkRehypeOptions;
	return unified().use(remarkParse).use(remarkPlugins).use(remarkRehype, remarkRehypeOptions).use(rehypePlugins);
}
function createFile(options) {
	let children = options.children || "", file = new VFile();
	return typeof children == "string" ? file.value = children : "" + children, file;
}
function post(tree, options) {
	let allowedElements = options.allowedElements, allowElement = options.allowElement, components = options.components, disallowedElements = options.disallowedElements, skipHtml = options.skipHtml, unwrapDisallowed = options.unwrapDisallowed, urlTransform = options.urlTransform || defaultUrlTransform;
	for (let deprecation of deprecations) Object.hasOwn(options, deprecation.from) && "" + deprecation.from + (deprecation.to ? "use `" + deprecation.to + "` instead" : "remove it") + deprecation.id;
	return visit(tree, transform), toJsxRuntime(tree, {
		Fragment: import_jsx_runtime.Fragment,
		components,
		ignoreInvalidStyle: !0,
		jsx: import_jsx_runtime.jsx,
		jsxs: import_jsx_runtime.jsxs,
		passKeys: !0,
		passNode: !0
	});
	function transform(node$1, index$2, parent) {
		if (node$1.type === "raw" && parent && typeof index$2 == "number") return skipHtml ? parent.children.splice(index$2, 1) : parent.children[index$2] = {
			type: "text",
			value: node$1.value
		}, index$2;
		if (node$1.type === "element") {
			let key;
			for (key in urlAttributes) if (Object.hasOwn(urlAttributes, key) && Object.hasOwn(node$1.properties, key)) {
				let value = node$1.properties[key], test = urlAttributes[key];
				(test === null || test.includes(node$1.tagName)) && (node$1.properties[key] = urlTransform(String(value || ""), key, node$1));
			}
		}
		if (node$1.type === "element") {
			let remove = allowedElements ? !allowedElements.includes(node$1.tagName) : disallowedElements ? disallowedElements.includes(node$1.tagName) : !1;
			if (!remove && allowElement && typeof index$2 == "number" && (remove = !allowElement(node$1, index$2, parent)), remove && parent && typeof index$2 == "number") return unwrapDisallowed && node$1.children ? parent.children.splice(index$2, 1, ...node$1.children) : parent.children.splice(index$2, 1), index$2;
		}
	}
}
function defaultUrlTransform(value) {
	let colon = value.indexOf(":"), questionMark = value.indexOf("?"), numberSign = value.indexOf("#"), slash = value.indexOf("/");
	return colon === -1 || slash !== -1 && colon > slash || questionMark !== -1 && colon > questionMark || numberSign !== -1 && colon > numberSign || safeProtocol.test(value.slice(0, colon)) ? value : "";
}
function ccount(value, character) {
	let source$2 = String(value);
	if (typeof character != "string") throw TypeError("Expected character");
	let count = 0, index$2 = source$2.indexOf(character);
	for (; index$2 !== -1;) count++, index$2 = source$2.indexOf(character, index$2 + character.length);
	return count;
}
function escapeStringRegexp(string$2) {
	if (typeof string$2 != "string") throw TypeError("Expected a string");
	return string$2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function findAndReplace(tree, list$3, options) {
	let ignored = convert((options || {}).ignore || []), pairs = toPairs(list$3), pairIndex = -1;
	for (; ++pairIndex < pairs.length;) visitParents(tree, "text", visitor);
	function visitor(node$1, parents) {
		let index$2 = -1, grandparent;
		for (; ++index$2 < parents.length;) {
			let parent = parents[index$2], siblings = grandparent ? grandparent.children : void 0;
			if (ignored(parent, siblings ? siblings.indexOf(parent) : void 0, grandparent)) return;
			grandparent = parent;
		}
		if (grandparent) return handler(node$1, parents);
	}
	function handler(node$1, parents) {
		let parent = parents[parents.length - 1], find$1 = pairs[pairIndex][0], replace$1 = pairs[pairIndex][1], start = 0, index$2 = parent.children.indexOf(node$1), change = !1, nodes = [];
		find$1.lastIndex = 0;
		let match = find$1.exec(node$1.value);
		for (; match;) {
			let position$2 = match.index, matchObject = {
				index: match.index,
				input: match.input,
				stack: [...parents, node$1]
			}, value = replace$1(...match, matchObject);
			if (typeof value == "string" && (value = value.length > 0 ? {
				type: "text",
				value
			} : void 0), value === !1 ? find$1.lastIndex = position$2 + 1 : (start !== position$2 && nodes.push({
				type: "text",
				value: node$1.value.slice(start, position$2)
			}), Array.isArray(value) ? nodes.push(...value) : value && nodes.push(value), start = position$2 + match[0].length, change = !0), !find$1.global) break;
			match = find$1.exec(node$1.value);
		}
		return change ? (start < node$1.value.length && nodes.push({
			type: "text",
			value: node$1.value.slice(start)
		}), parent.children.splice(index$2, 1, ...nodes)) : nodes = [node$1], index$2 + nodes.length;
	}
}
function toPairs(tupleOrList) {
	let result = [];
	if (!Array.isArray(tupleOrList)) throw TypeError("Expected find and replace tuple or list of tuples");
	let list$3 = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList], index$2 = -1;
	for (; ++index$2 < list$3.length;) {
		let tuple = list$3[index$2];
		result.push([toExpression(tuple[0]), toFunction(tuple[1])]);
	}
	return result;
}
function toExpression(find$1) {
	return typeof find$1 == "string" ? new RegExp(escapeStringRegexp(find$1), "g") : find$1;
}
function toFunction(replace$1) {
	return typeof replace$1 == "function" ? replace$1 : function() {
		return replace$1;
	};
}
var inConstruct = "phrasing", notInConstruct = [
	"autolink",
	"link",
	"image",
	"label"
];
function gfmAutolinkLiteralFromMarkdown() {
	return {
		transforms: [transformGfmAutolinkLiterals],
		enter: {
			literalAutolink: enterLiteralAutolink,
			literalAutolinkEmail: enterLiteralAutolinkValue,
			literalAutolinkHttp: enterLiteralAutolinkValue,
			literalAutolinkWww: enterLiteralAutolinkValue
		},
		exit: {
			literalAutolink: exitLiteralAutolink,
			literalAutolinkEmail: exitLiteralAutolinkEmail,
			literalAutolinkHttp: exitLiteralAutolinkHttp,
			literalAutolinkWww: exitLiteralAutolinkWww
		}
	};
}
function gfmAutolinkLiteralToMarkdown() {
	return { unsafe: [
		{
			character: "@",
			before: "[+\\-.\\w]",
			after: "[\\-.\\w]",
			inConstruct,
			notInConstruct
		},
		{
			character: ".",
			before: "[Ww]",
			after: "[\\-.\\w]",
			inConstruct,
			notInConstruct
		},
		{
			character: ":",
			before: "[ps]",
			after: "\\/",
			inConstruct,
			notInConstruct
		}
	] };
}
function enterLiteralAutolink(token) {
	this.enter({
		type: "link",
		title: null,
		url: "",
		children: []
	}, token);
}
function enterLiteralAutolinkValue(token) {
	this.config.enter.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkHttp(token) {
	this.config.exit.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkWww(token) {
	this.config.exit.data.call(this, token);
	let node$1 = this.stack[this.stack.length - 1];
	node$1.type, node$1.url = "http://" + this.sliceSerialize(token);
}
function exitLiteralAutolinkEmail(token) {
	this.config.exit.autolinkEmail.call(this, token);
}
function exitLiteralAutolink(token) {
	this.exit(token);
}
function transformGfmAutolinkLiterals(tree) {
	findAndReplace(tree, [[/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl], [RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), findEmail]], { ignore: ["link", "linkReference"] });
}
function findUrl(_, protocol, domain$1, path$1, match) {
	let prefix = "";
	if (!previous(match) || (/^w/i.test(protocol) && (domain$1 = protocol + domain$1, protocol = "", prefix = "http://"), !isCorrectDomain(domain$1))) return !1;
	let parts = splitUrl(domain$1 + path$1);
	if (!parts[0]) return !1;
	let result = {
		type: "link",
		title: null,
		url: prefix + protocol + parts[0],
		children: [{
			type: "text",
			value: protocol + parts[0]
		}]
	};
	return parts[1] ? [result, {
		type: "text",
		value: parts[1]
	}] : result;
}
function findEmail(_, atext, label, match) {
	return !previous(match, !0) || /[-\d_]$/.test(label) ? !1 : {
		type: "link",
		title: null,
		url: "mailto:" + atext + "@" + label,
		children: [{
			type: "text",
			value: atext + "@" + label
		}]
	};
}
function isCorrectDomain(domain$1) {
	let parts = domain$1.split(".");
	return !(parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2])));
}
function splitUrl(url) {
	let trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
	if (!trailExec) return [url, void 0];
	url = url.slice(0, trailExec.index);
	let trail$1 = trailExec[0], closingParenIndex = trail$1.indexOf(")"), openingParens = ccount(url, "("), closingParens = ccount(url, ")");
	for (; closingParenIndex !== -1 && openingParens > closingParens;) url += trail$1.slice(0, closingParenIndex + 1), trail$1 = trail$1.slice(closingParenIndex + 1), closingParenIndex = trail$1.indexOf(")"), closingParens++;
	return [url, trail$1];
}
function previous(match, email) {
	let code$4 = match.input.charCodeAt(match.index - 1);
	return (match.index === 0 || unicodeWhitespace(code$4) || unicodePunctuation(code$4)) && (!email || code$4 !== 47);
}
footnoteReference.peek = footnoteReferencePeek;
function enterFootnoteCallString() {
	this.buffer();
}
function enterFootnoteCall(token) {
	this.enter({
		type: "footnoteReference",
		identifier: "",
		label: ""
	}, token);
}
function enterFootnoteDefinitionLabelString() {
	this.buffer();
}
function enterFootnoteDefinition(token) {
	this.enter({
		type: "footnoteDefinition",
		identifier: "",
		label: "",
		children: []
	}, token);
}
function exitFootnoteCallString(token) {
	let label = this.resume(), node$1 = this.stack[this.stack.length - 1];
	node$1.type, node$1.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase(), node$1.label = label;
}
function exitFootnoteCall(token) {
	this.exit(token);
}
function exitFootnoteDefinitionLabelString(token) {
	let label = this.resume(), node$1 = this.stack[this.stack.length - 1];
	node$1.type, node$1.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase(), node$1.label = label;
}
function exitFootnoteDefinition(token) {
	this.exit(token);
}
function footnoteReferencePeek() {
	return "[";
}
function footnoteReference(node$1, _, state, info) {
	let tracker = state.createTracker(info), value = tracker.move("[^"), exit$2 = state.enter("footnoteReference"), subexit = state.enter("reference");
	return value += tracker.move(state.safe(state.associationId(node$1), {
		after: "]",
		before: value
	})), subexit(), exit$2(), value += tracker.move("]"), value;
}
function gfmFootnoteFromMarkdown() {
	return {
		enter: {
			gfmFootnoteCallString: enterFootnoteCallString,
			gfmFootnoteCall: enterFootnoteCall,
			gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
			gfmFootnoteDefinition: enterFootnoteDefinition
		},
		exit: {
			gfmFootnoteCallString: exitFootnoteCallString,
			gfmFootnoteCall: exitFootnoteCall,
			gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
			gfmFootnoteDefinition: exitFootnoteDefinition
		}
	};
}
function gfmFootnoteToMarkdown(options) {
	let firstLineBlank = !1;
	return options && options.firstLineBlank && (firstLineBlank = !0), {
		handlers: {
			footnoteDefinition,
			footnoteReference
		},
		unsafe: [{
			character: "[",
			inConstruct: [
				"label",
				"phrasing",
				"reference"
			]
		}]
	};
	function footnoteDefinition(node$1, _, state, info) {
		let tracker = state.createTracker(info), value = tracker.move("[^"), exit$2 = state.enter("footnoteDefinition"), subexit = state.enter("label");
		return value += tracker.move(state.safe(state.associationId(node$1), {
			before: value,
			after: "]"
		})), subexit(), value += tracker.move("]:"), node$1.children && node$1.children.length > 0 && (tracker.shift(4), value += tracker.move((firstLineBlank ? "\n" : " ") + state.indentLines(state.containerFlow(node$1, tracker.current()), firstLineBlank ? mapAll : mapExceptFirst))), exit$2(), value;
	}
}
function mapExceptFirst(line, index$2, blank) {
	return index$2 === 0 ? line : mapAll(line, index$2, blank);
}
function mapAll(line, index$2, blank) {
	return (blank ? "" : "    ") + line;
}
var constructsWithoutStrikethrough = [
	"autolink",
	"destinationLiteral",
	"destinationRaw",
	"reference",
	"titleQuote",
	"titleApostrophe"
];
handleDelete.peek = peekDelete;
function gfmStrikethroughFromMarkdown() {
	return {
		canContainEols: ["delete"],
		enter: { strikethrough: enterStrikethrough },
		exit: { strikethrough: exitStrikethrough }
	};
}
function gfmStrikethroughToMarkdown() {
	return {
		unsafe: [{
			character: "~",
			inConstruct: "phrasing",
			notInConstruct: constructsWithoutStrikethrough
		}],
		handlers: { delete: handleDelete }
	};
}
function enterStrikethrough(token) {
	this.enter({
		type: "delete",
		children: []
	}, token);
}
function exitStrikethrough(token) {
	this.exit(token);
}
function handleDelete(node$1, _, state, info) {
	let tracker = state.createTracker(info), exit$2 = state.enter("strikethrough"), value = tracker.move("~~");
	return value += state.containerPhrasing(node$1, {
		...tracker.current(),
		before: value,
		after: "~"
	}), value += tracker.move("~~"), exit$2(), value;
}
function peekDelete() {
	return "~";
}
function defaultStringLength(value) {
	return value.length;
}
function markdownTable(table$1, options) {
	let settings = options || {}, align = (settings.align || []).concat(), stringLength = settings.stringLength || defaultStringLength, alignments = [], cellMatrix = [], sizeMatrix = [], longestCellByColumn = [], mostCellsPerRow = 0, rowIndex = -1;
	for (; ++rowIndex < table$1.length;) {
		let row$2 = [], sizes$1 = [], columnIndex$1 = -1;
		for (table$1[rowIndex].length > mostCellsPerRow && (mostCellsPerRow = table$1[rowIndex].length); ++columnIndex$1 < table$1[rowIndex].length;) {
			let cell$1 = serialize(table$1[rowIndex][columnIndex$1]);
			if (settings.alignDelimiters !== !1) {
				let size = stringLength(cell$1);
				sizes$1[columnIndex$1] = size, (longestCellByColumn[columnIndex$1] === void 0 || size > longestCellByColumn[columnIndex$1]) && (longestCellByColumn[columnIndex$1] = size);
			}
			row$2.push(cell$1);
		}
		cellMatrix[rowIndex] = row$2, sizeMatrix[rowIndex] = sizes$1;
	}
	let columnIndex = -1;
	if (typeof align == "object" && "length" in align) for (; ++columnIndex < mostCellsPerRow;) alignments[columnIndex] = toAlignment(align[columnIndex]);
	else {
		let code$4 = toAlignment(align);
		for (; ++columnIndex < mostCellsPerRow;) alignments[columnIndex] = code$4;
	}
	columnIndex = -1;
	let row$1 = [], sizes = [];
	for (; ++columnIndex < mostCellsPerRow;) {
		let code$4 = alignments[columnIndex], before = "", after = "";
		code$4 === 99 ? (before = ":", after = ":") : code$4 === 108 ? before = ":" : code$4 === 114 && (after = ":");
		let size = settings.alignDelimiters === !1 ? 1 : Math.max(1, longestCellByColumn[columnIndex] - before.length - after.length), cell$1 = before + "-".repeat(size) + after;
		settings.alignDelimiters !== !1 && (size = before.length + size + after.length, size > longestCellByColumn[columnIndex] && (longestCellByColumn[columnIndex] = size), sizes[columnIndex] = size), row$1[columnIndex] = cell$1;
	}
	cellMatrix.splice(1, 0, row$1), sizeMatrix.splice(1, 0, sizes), rowIndex = -1;
	let lines = [];
	for (; ++rowIndex < cellMatrix.length;) {
		let row$2 = cellMatrix[rowIndex], sizes$1 = sizeMatrix[rowIndex];
		columnIndex = -1;
		let line = [];
		for (; ++columnIndex < mostCellsPerRow;) {
			let cell$1 = row$2[columnIndex] || "", before = "", after = "";
			if (settings.alignDelimiters !== !1) {
				let size = longestCellByColumn[columnIndex] - (sizes$1[columnIndex] || 0), code$4 = alignments[columnIndex];
				code$4 === 114 ? before = " ".repeat(size) : code$4 === 99 ? size % 2 ? (before = " ".repeat(size / 2 + .5), after = " ".repeat(size / 2 - .5)) : (before = " ".repeat(size / 2), after = before) : after = " ".repeat(size);
			}
			settings.delimiterStart !== !1 && !columnIndex && line.push("|"), settings.padding !== !1 && !(settings.alignDelimiters === !1 && cell$1 === "") && (settings.delimiterStart !== !1 || columnIndex) && line.push(" "), settings.alignDelimiters !== !1 && line.push(before), line.push(cell$1), settings.alignDelimiters !== !1 && line.push(after), settings.padding !== !1 && line.push(" "), (settings.delimiterEnd !== !1 || columnIndex !== mostCellsPerRow - 1) && line.push("|");
		}
		lines.push(settings.delimiterEnd === !1 ? line.join("").replace(/ +$/, "") : line.join(""));
	}
	return lines.join("\n");
}
function serialize(value) {
	return value == null ? "" : String(value);
}
function toAlignment(value) {
	let code$4 = typeof value == "string" ? value.codePointAt(0) : 0;
	return code$4 === 67 || code$4 === 99 ? 99 : code$4 === 76 || code$4 === 108 ? 108 : code$4 === 82 || code$4 === 114 ? 114 : 0;
}
function blockquote(node$1, _, state, info) {
	let exit$2 = state.enter("blockquote"), tracker = state.createTracker(info);
	tracker.move("> "), tracker.shift(2);
	let value = state.indentLines(state.containerFlow(node$1, tracker.current()), map$1);
	return exit$2(), value;
}
function map$1(line, _, blank) {
	return ">" + (blank ? "" : " ") + line;
}
function patternInScope(stack, pattern) {
	return listInScope(stack, pattern.inConstruct, !0) && !listInScope(stack, pattern.notInConstruct, !1);
}
function listInScope(stack, list$3, none) {
	if (typeof list$3 == "string" && (list$3 = [list$3]), !list$3 || list$3.length === 0) return none;
	let index$2 = -1;
	for (; ++index$2 < list$3.length;) if (stack.includes(list$3[index$2])) return !0;
	return !1;
}
function hardBreak(_, _1, state, info) {
	let index$2 = -1;
	for (; ++index$2 < state.unsafe.length;) if (state.unsafe[index$2].character === "\n" && patternInScope(state.stack, state.unsafe[index$2])) return /[ \t]/.test(info.before) ? "" : " ";
	return "\\\n";
}
function longestStreak(value, substring) {
	let source$2 = String(value), index$2 = source$2.indexOf(substring), expected = index$2, count = 0, max = 0;
	if (typeof substring != "string") throw TypeError("Expected substring");
	for (; index$2 !== -1;) index$2 === expected ? ++count > max && (max = count) : count = 1, expected = index$2 + substring.length, index$2 = source$2.indexOf(substring, expected);
	return max;
}
function formatCodeAsIndented(node$1, state) {
	return !!(state.options.fences === !1 && node$1.value && !node$1.lang && /[^ \r\n]/.test(node$1.value) && !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node$1.value));
}
function checkFence(state) {
	let marker = state.options.fence || "`";
	if (marker !== "`" && marker !== "~") throw Error("Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`");
	return marker;
}
function code$2(node$1, _, state, info) {
	let marker = checkFence(state), raw = node$1.value || "", suffix = marker === "`" ? "GraveAccent" : "Tilde";
	if (formatCodeAsIndented(node$1, state)) {
		let exit$3 = state.enter("codeIndented"), value$1 = state.indentLines(raw, map);
		return exit$3(), value$1;
	}
	let tracker = state.createTracker(info), sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3)), exit$2 = state.enter("codeFenced"), value = tracker.move(sequence);
	if (node$1.lang) {
		let subexit = state.enter(`codeFencedLang${suffix}`);
		value += tracker.move(state.safe(node$1.lang, {
			before: value,
			after: " ",
			encode: ["`"],
			...tracker.current()
		})), subexit();
	}
	if (node$1.lang && node$1.meta) {
		let subexit = state.enter(`codeFencedMeta${suffix}`);
		value += tracker.move(" "), value += tracker.move(state.safe(node$1.meta, {
			before: value,
			after: "\n",
			encode: ["`"],
			...tracker.current()
		})), subexit();
	}
	return value += tracker.move("\n"), raw && (value += tracker.move(raw + "\n")), value += tracker.move(sequence), exit$2(), value;
}
function map(line, _, blank) {
	return (blank ? "" : "    ") + line;
}
function checkQuote(state) {
	let marker = state.options.quote || "\"";
	if (marker !== "\"" && marker !== "'") throw Error("Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`");
	return marker;
}
function definition(node$1, _, state, info) {
	let quote = checkQuote(state), suffix = quote === "\"" ? "Quote" : "Apostrophe", exit$2 = state.enter("definition"), subexit = state.enter("label"), tracker = state.createTracker(info), value = tracker.move("[");
	return value += tracker.move(state.safe(state.associationId(node$1), {
		before: value,
		after: "]",
		...tracker.current()
	})), value += tracker.move("]: "), subexit(), !node$1.url || /[\0- \u007F]/.test(node$1.url) ? (subexit = state.enter("destinationLiteral"), value += tracker.move("<"), value += tracker.move(state.safe(node$1.url, {
		before: value,
		after: ">",
		...tracker.current()
	})), value += tracker.move(">")) : (subexit = state.enter("destinationRaw"), value += tracker.move(state.safe(node$1.url, {
		before: value,
		after: node$1.title ? " " : "\n",
		...tracker.current()
	}))), subexit(), node$1.title && (subexit = state.enter(`title${suffix}`), value += tracker.move(" " + quote), value += tracker.move(state.safe(node$1.title, {
		before: value,
		after: quote,
		...tracker.current()
	})), value += tracker.move(quote), subexit()), exit$2(), value;
}
function checkEmphasis(state) {
	let marker = state.options.emphasis || "*";
	if (marker !== "*" && marker !== "_") throw Error("Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`");
	return marker;
}
function encodeCharacterReference(code$4) {
	return "&#x" + code$4.toString(16).toUpperCase() + ";";
}
function encodeInfo(outside, inside, marker) {
	let outsideKind = classifyCharacter(outside), insideKind = classifyCharacter(inside);
	return outsideKind === void 0 ? insideKind === void 0 ? marker === "_" ? {
		inside: !0,
		outside: !0
	} : {
		inside: !1,
		outside: !1
	} : insideKind === 1 ? {
		inside: !0,
		outside: !0
	} : {
		inside: !1,
		outside: !0
	} : outsideKind === 1 ? insideKind === void 0 ? {
		inside: !1,
		outside: !1
	} : insideKind === 1 ? {
		inside: !0,
		outside: !0
	} : {
		inside: !1,
		outside: !1
	} : insideKind === void 0 ? {
		inside: !1,
		outside: !1
	} : insideKind === 1 ? {
		inside: !0,
		outside: !1
	} : {
		inside: !1,
		outside: !1
	};
}
emphasis.peek = emphasisPeek;
function emphasis(node$1, _, state, info) {
	let marker = checkEmphasis(state), exit$2 = state.enter("emphasis"), tracker = state.createTracker(info), before = tracker.move(marker), between = tracker.move(state.containerPhrasing(node$1, {
		after: marker,
		before,
		...tracker.current()
	})), betweenHead = between.charCodeAt(0), open = encodeInfo(info.before.charCodeAt(info.before.length - 1), betweenHead, marker);
	open.inside && (between = encodeCharacterReference(betweenHead) + between.slice(1));
	let betweenTail = between.charCodeAt(between.length - 1), close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker);
	close.inside && (between = between.slice(0, -1) + encodeCharacterReference(betweenTail));
	let after = tracker.move(marker);
	return exit$2(), state.attentionEncodeSurroundingInfo = {
		after: close.outside,
		before: open.outside
	}, before + between + after;
}
function emphasisPeek(_, _1, state) {
	return state.options.emphasis || "*";
}
function formatHeadingAsSetext(node$1, state) {
	let literalWithBreak = !1;
	return visit(node$1, function(node$2) {
		if ("value" in node$2 && /\r?\n|\r/.test(node$2.value) || node$2.type === "break") return literalWithBreak = !0, !1;
	}), !!((!node$1.depth || node$1.depth < 3) && toString$2(node$1) && (state.options.setext || literalWithBreak));
}
function heading(node$1, _, state, info) {
	let rank = Math.max(Math.min(6, node$1.depth || 1), 1), tracker = state.createTracker(info);
	if (formatHeadingAsSetext(node$1, state)) {
		let exit$3 = state.enter("headingSetext"), subexit$1 = state.enter("phrasing"), value$1 = state.containerPhrasing(node$1, {
			...tracker.current(),
			before: "\n",
			after: "\n"
		});
		return subexit$1(), exit$3(), value$1 + "\n" + (rank === 1 ? "=" : "-").repeat(value$1.length - (Math.max(value$1.lastIndexOf("\r"), value$1.lastIndexOf("\n")) + 1));
	}
	let sequence = "#".repeat(rank), exit$2 = state.enter("headingAtx"), subexit = state.enter("phrasing");
	tracker.move(sequence + " ");
	let value = state.containerPhrasing(node$1, {
		before: "# ",
		after: "\n",
		...tracker.current()
	});
	return /^[\t ]/.test(value) && (value = encodeCharacterReference(value.charCodeAt(0)) + value.slice(1)), value = value ? sequence + " " + value : sequence, state.options.closeAtx && (value += " " + sequence), subexit(), exit$2(), value;
}
html.peek = htmlPeek;
function html(node$1) {
	return node$1.value || "";
}
function htmlPeek() {
	return "<";
}
image.peek = imagePeek;
function image(node$1, _, state, info) {
	let quote = checkQuote(state), suffix = quote === "\"" ? "Quote" : "Apostrophe", exit$2 = state.enter("image"), subexit = state.enter("label"), tracker = state.createTracker(info), value = tracker.move("![");
	return value += tracker.move(state.safe(node$1.alt, {
		before: value,
		after: "]",
		...tracker.current()
	})), value += tracker.move("]("), subexit(), !node$1.url && node$1.title || /[\0- \u007F]/.test(node$1.url) ? (subexit = state.enter("destinationLiteral"), value += tracker.move("<"), value += tracker.move(state.safe(node$1.url, {
		before: value,
		after: ">",
		...tracker.current()
	})), value += tracker.move(">")) : (subexit = state.enter("destinationRaw"), value += tracker.move(state.safe(node$1.url, {
		before: value,
		after: node$1.title ? " " : ")",
		...tracker.current()
	}))), subexit(), node$1.title && (subexit = state.enter(`title${suffix}`), value += tracker.move(" " + quote), value += tracker.move(state.safe(node$1.title, {
		before: value,
		after: quote,
		...tracker.current()
	})), value += tracker.move(quote), subexit()), value += tracker.move(")"), exit$2(), value;
}
function imagePeek() {
	return "!";
}
imageReference.peek = imageReferencePeek;
function imageReference(node$1, _, state, info) {
	let type = node$1.referenceType, exit$2 = state.enter("imageReference"), subexit = state.enter("label"), tracker = state.createTracker(info), value = tracker.move("!["), alt = state.safe(node$1.alt, {
		before: value,
		after: "]",
		...tracker.current()
	});
	value += tracker.move(alt + "]["), subexit();
	let stack = state.stack;
	state.stack = [], subexit = state.enter("reference");
	let reference = state.safe(state.associationId(node$1), {
		before: value,
		after: "]",
		...tracker.current()
	});
	return subexit(), state.stack = stack, exit$2(), type === "full" || !alt || alt !== reference ? value += tracker.move(reference + "]") : type === "shortcut" ? value = value.slice(0, -1) : value += tracker.move("]"), value;
}
function imageReferencePeek() {
	return "!";
}
inlineCode.peek = inlineCodePeek;
function inlineCode(node$1, _, state) {
	let value = node$1.value || "", sequence = "`", index$2 = -1;
	for (; (/* @__PURE__ */ RegExp("(^|[^`])" + sequence + "([^`]|$)")).test(value);) sequence += "`";
	for (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value)) && (value = " " + value + " "); ++index$2 < state.unsafe.length;) {
		let pattern = state.unsafe[index$2], expression = state.compilePattern(pattern), match;
		if (pattern.atBreak) for (; match = expression.exec(value);) {
			let position$2 = match.index;
			value.charCodeAt(position$2) === 10 && value.charCodeAt(position$2 - 1) === 13 && position$2--, value = value.slice(0, position$2) + " " + value.slice(match.index + 1);
		}
	}
	return sequence + value + sequence;
}
function inlineCodePeek() {
	return "`";
}
function formatLinkAsAutolink(node$1, state) {
	let raw = toString$2(node$1);
	return !!(!state.options.resourceLink && node$1.url && !node$1.title && node$1.children && node$1.children.length === 1 && node$1.children[0].type === "text" && (raw === node$1.url || "mailto:" + raw === node$1.url) && /^[a-z][a-z+.-]+:/i.test(node$1.url) && !/[\0- <>\u007F]/.test(node$1.url));
}
link.peek = linkPeek;
function link(node$1, _, state, info) {
	let quote = checkQuote(state), suffix = quote === "\"" ? "Quote" : "Apostrophe", tracker = state.createTracker(info), exit$2, subexit;
	if (formatLinkAsAutolink(node$1, state)) {
		let stack = state.stack;
		state.stack = [], exit$2 = state.enter("autolink");
		let value$1 = tracker.move("<");
		return value$1 += tracker.move(state.containerPhrasing(node$1, {
			before: value$1,
			after: ">",
			...tracker.current()
		})), value$1 += tracker.move(">"), exit$2(), state.stack = stack, value$1;
	}
	exit$2 = state.enter("link"), subexit = state.enter("label");
	let value = tracker.move("[");
	return value += tracker.move(state.containerPhrasing(node$1, {
		before: value,
		after: "](",
		...tracker.current()
	})), value += tracker.move("]("), subexit(), !node$1.url && node$1.title || /[\0- \u007F]/.test(node$1.url) ? (subexit = state.enter("destinationLiteral"), value += tracker.move("<"), value += tracker.move(state.safe(node$1.url, {
		before: value,
		after: ">",
		...tracker.current()
	})), value += tracker.move(">")) : (subexit = state.enter("destinationRaw"), value += tracker.move(state.safe(node$1.url, {
		before: value,
		after: node$1.title ? " " : ")",
		...tracker.current()
	}))), subexit(), node$1.title && (subexit = state.enter(`title${suffix}`), value += tracker.move(" " + quote), value += tracker.move(state.safe(node$1.title, {
		before: value,
		after: quote,
		...tracker.current()
	})), value += tracker.move(quote), subexit()), value += tracker.move(")"), exit$2(), value;
}
function linkPeek(node$1, _, state) {
	return formatLinkAsAutolink(node$1, state) ? "<" : "[";
}
linkReference.peek = linkReferencePeek;
function linkReference(node$1, _, state, info) {
	let type = node$1.referenceType, exit$2 = state.enter("linkReference"), subexit = state.enter("label"), tracker = state.createTracker(info), value = tracker.move("["), text$6 = state.containerPhrasing(node$1, {
		before: value,
		after: "]",
		...tracker.current()
	});
	value += tracker.move(text$6 + "]["), subexit();
	let stack = state.stack;
	state.stack = [], subexit = state.enter("reference");
	let reference = state.safe(state.associationId(node$1), {
		before: value,
		after: "]",
		...tracker.current()
	});
	return subexit(), state.stack = stack, exit$2(), type === "full" || !text$6 || text$6 !== reference ? value += tracker.move(reference + "]") : type === "shortcut" ? value = value.slice(0, -1) : value += tracker.move("]"), value;
}
function linkReferencePeek() {
	return "[";
}
function checkBullet(state) {
	let marker = state.options.bullet || "*";
	if (marker !== "*" && marker !== "+" && marker !== "-") throw Error("Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`");
	return marker;
}
function checkBulletOther(state) {
	let bullet = checkBullet(state), bulletOther = state.options.bulletOther;
	if (!bulletOther) return bullet === "*" ? "-" : "*";
	if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") throw Error("Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`");
	if (bulletOther === bullet) throw Error("Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different");
	return bulletOther;
}
function checkBulletOrdered(state) {
	let marker = state.options.bulletOrdered || ".";
	if (marker !== "." && marker !== ")") throw Error("Cannot serialize items with `" + marker + "` for `options.bulletOrdered`, expected `.` or `)`");
	return marker;
}
function checkRule(state) {
	let marker = state.options.rule || "*";
	if (marker !== "*" && marker !== "-" && marker !== "_") throw Error("Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`");
	return marker;
}
function list(node$1, parent, state, info) {
	let exit$2 = state.enter("list"), bulletCurrent = state.bulletCurrent, bullet = node$1.ordered ? checkBulletOrdered(state) : checkBullet(state), bulletOther = node$1.ordered ? bullet === "." ? ")" : "." : checkBulletOther(state), useDifferentMarker = parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : !1;
	if (!node$1.ordered) {
		let firstListItem = node$1.children ? node$1.children[0] : void 0;
		if ((bullet === "*" || bullet === "-") && firstListItem && (!firstListItem.children || !firstListItem.children[0]) && state.stack[state.stack.length - 1] === "list" && state.stack[state.stack.length - 2] === "listItem" && state.stack[state.stack.length - 3] === "list" && state.stack[state.stack.length - 4] === "listItem" && state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0 && (useDifferentMarker = !0), checkRule(state) === bullet && firstListItem) {
			let index$2 = -1;
			for (; ++index$2 < node$1.children.length;) {
				let item = node$1.children[index$2];
				if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
					useDifferentMarker = !0;
					break;
				}
			}
		}
	}
	useDifferentMarker && (bullet = bulletOther), state.bulletCurrent = bullet;
	let value = state.containerFlow(node$1, info);
	return state.bulletLastUsed = bullet, state.bulletCurrent = bulletCurrent, exit$2(), value;
}
function checkListItemIndent(state) {
	let style = state.options.listItemIndent || "one";
	if (style !== "tab" && style !== "one" && style !== "mixed") throw Error("Cannot serialize items with `" + style + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`");
	return style;
}
function listItem(node$1, parent, state, info) {
	let listItemIndent = checkListItemIndent(state), bullet = state.bulletCurrent || checkBullet(state);
	parent && parent.type === "list" && parent.ordered && (bullet = (typeof parent.start == "number" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === !1 ? 0 : parent.children.indexOf(node$1)) + bullet);
	let size = bullet.length + 1;
	(listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node$1.spread)) && (size = Math.ceil(size / 4) * 4);
	let tracker = state.createTracker(info);
	tracker.move(bullet + " ".repeat(size - bullet.length)), tracker.shift(size);
	let exit$2 = state.enter("listItem"), value = state.indentLines(state.containerFlow(node$1, tracker.current()), map$2);
	return exit$2(), value;
	function map$2(line, index$2, blank) {
		return index$2 ? (blank ? "" : " ".repeat(size)) + line : (blank ? bullet : bullet + " ".repeat(size - bullet.length)) + line;
	}
}
function paragraph(node$1, _, state, info) {
	let exit$2 = state.enter("paragraph"), subexit = state.enter("phrasing"), value = state.containerPhrasing(node$1, info);
	return subexit(), exit$2(), value;
}
const phrasing = convert([
	"break",
	"delete",
	"emphasis",
	"footnote",
	"footnoteReference",
	"image",
	"imageReference",
	"inlineCode",
	"inlineMath",
	"link",
	"linkReference",
	"mdxJsxTextElement",
	"mdxTextExpression",
	"strong",
	"text",
	"textDirective"
]);
function root(node$1, _, state, info) {
	return (node$1.children.some(function(d) {
		return phrasing(d);
	}) ? state.containerPhrasing : state.containerFlow).call(state, node$1, info);
}
function checkStrong(state) {
	let marker = state.options.strong || "*";
	if (marker !== "*" && marker !== "_") throw Error("Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`");
	return marker;
}
strong.peek = strongPeek;
function strong(node$1, _, state, info) {
	let marker = checkStrong(state), exit$2 = state.enter("strong"), tracker = state.createTracker(info), before = tracker.move(marker + marker), between = tracker.move(state.containerPhrasing(node$1, {
		after: marker,
		before,
		...tracker.current()
	})), betweenHead = between.charCodeAt(0), open = encodeInfo(info.before.charCodeAt(info.before.length - 1), betweenHead, marker);
	open.inside && (between = encodeCharacterReference(betweenHead) + between.slice(1));
	let betweenTail = between.charCodeAt(between.length - 1), close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker);
	close.inside && (between = between.slice(0, -1) + encodeCharacterReference(betweenTail));
	let after = tracker.move(marker + marker);
	return exit$2(), state.attentionEncodeSurroundingInfo = {
		after: close.outside,
		before: open.outside
	}, before + between + after;
}
function strongPeek(_, _1, state) {
	return state.options.strong || "*";
}
function text$1(node$1, _, state, info) {
	return state.safe(node$1.value, info);
}
function checkRuleRepetition(state) {
	let repetition = state.options.ruleRepetition || 3;
	if (repetition < 3) throw Error("Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more");
	return repetition;
}
function thematicBreak(_, _1, state) {
	let value = (checkRule(state) + (state.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(state));
	return state.options.ruleSpaces ? value.slice(0, -1) : value;
}
const handle = {
	blockquote,
	break: hardBreak,
	code: code$2,
	definition,
	emphasis,
	hardBreak,
	heading,
	html,
	image,
	imageReference,
	inlineCode,
	link,
	linkReference,
	list,
	listItem,
	paragraph,
	root,
	strong,
	text: text$1,
	thematicBreak
};
function gfmTableFromMarkdown() {
	return {
		enter: {
			table: enterTable,
			tableData: enterCell,
			tableHeader: enterCell,
			tableRow: enterRow
		},
		exit: {
			codeText: exitCodeText,
			table: exitTable,
			tableData: exit,
			tableHeader: exit,
			tableRow: exit
		}
	};
}
function enterTable(token) {
	let align = token._align;
	this.enter({
		type: "table",
		align: align.map(function(d) {
			return d === "none" ? null : d;
		}),
		children: []
	}, token), this.data.inTable = !0;
}
function exitTable(token) {
	this.exit(token), this.data.inTable = void 0;
}
function enterRow(token) {
	this.enter({
		type: "tableRow",
		children: []
	}, token);
}
function exit(token) {
	this.exit(token);
}
function enterCell(token) {
	this.enter({
		type: "tableCell",
		children: []
	}, token);
}
function exitCodeText(token) {
	let value = this.resume();
	this.data.inTable && (value = value.replace(/\\([\\|])/g, replace));
	let node$1 = this.stack[this.stack.length - 1];
	node$1.type, node$1.value = value, this.exit(token);
}
function replace($0, $1) {
	return $1 === "|" ? $1 : $0;
}
function gfmTableToMarkdown(options) {
	let settings = options || {}, padding = settings.tableCellPadding, alignDelimiters = settings.tablePipeAlign, stringLength = settings.stringLength, around = padding ? " " : "|";
	return {
		unsafe: [
			{
				character: "\r",
				inConstruct: "tableCell"
			},
			{
				character: "\n",
				inConstruct: "tableCell"
			},
			{
				atBreak: !0,
				character: "|",
				after: "[	 :-]"
			},
			{
				character: "|",
				inConstruct: "tableCell"
			},
			{
				atBreak: !0,
				character: ":",
				after: "-"
			},
			{
				atBreak: !0,
				character: "-",
				after: "[:|-]"
			}
		],
		handlers: {
			inlineCode: inlineCodeWithTable,
			table: handleTable,
			tableCell: handleTableCell,
			tableRow: handleTableRow
		}
	};
	function handleTable(node$1, _, state, info) {
		return serializeData(handleTableAsData(node$1, state, info), node$1.align);
	}
	function handleTableRow(node$1, _, state, info) {
		let value = serializeData([handleTableRowAsData(node$1, state, info)]);
		return value.slice(0, value.indexOf("\n"));
	}
	function handleTableCell(node$1, _, state, info) {
		let exit$2 = state.enter("tableCell"), subexit = state.enter("phrasing"), value = state.containerPhrasing(node$1, {
			...info,
			before: around,
			after: around
		});
		return subexit(), exit$2(), value;
	}
	function serializeData(matrix, align) {
		return markdownTable(matrix, {
			align,
			alignDelimiters,
			padding,
			stringLength
		});
	}
	function handleTableAsData(node$1, state, info) {
		let children = node$1.children, index$2 = -1, result = [], subexit = state.enter("table");
		for (; ++index$2 < children.length;) result[index$2] = handleTableRowAsData(children[index$2], state, info);
		return subexit(), result;
	}
	function handleTableRowAsData(node$1, state, info) {
		let children = node$1.children, index$2 = -1, result = [], subexit = state.enter("tableRow");
		for (; ++index$2 < children.length;) result[index$2] = handleTableCell(children[index$2], node$1, state, info);
		return subexit(), result;
	}
	function inlineCodeWithTable(node$1, parent, state) {
		let value = handle.inlineCode(node$1, parent, state);
		return state.stack.includes("tableCell") && (value = value.replace(/\|/g, "\\$&")), value;
	}
}
function gfmTaskListItemFromMarkdown() {
	return { exit: {
		taskListCheckValueChecked: exitCheck,
		taskListCheckValueUnchecked: exitCheck,
		paragraph: exitParagraphWithTaskListItem
	} };
}
function gfmTaskListItemToMarkdown() {
	return {
		unsafe: [{
			atBreak: !0,
			character: "-",
			after: "[:|-]"
		}],
		handlers: { listItem: listItemWithTaskListItem }
	};
}
function exitCheck(token) {
	let node$1 = this.stack[this.stack.length - 2];
	node$1.type, node$1.checked = token.type === "taskListCheckValueChecked";
}
function exitParagraphWithTaskListItem(token) {
	let parent = this.stack[this.stack.length - 2];
	if (parent && parent.type === "listItem" && typeof parent.checked == "boolean") {
		let node$1 = this.stack[this.stack.length - 1];
		node$1.type;
		let head = node$1.children[0];
		if (head && head.type === "text") {
			let siblings = parent.children, index$2 = -1, firstParaghraph;
			for (; ++index$2 < siblings.length;) {
				let sibling = siblings[index$2];
				if (sibling.type === "paragraph") {
					firstParaghraph = sibling;
					break;
				}
			}
			firstParaghraph === node$1 && (head.value = head.value.slice(1), head.value.length === 0 ? node$1.children.shift() : node$1.position && head.position && typeof head.position.start.offset == "number" && (head.position.start.column++, head.position.start.offset++, node$1.position.start = Object.assign({}, head.position.start)));
		}
	}
	this.exit(token);
}
function listItemWithTaskListItem(node$1, parent, state, info) {
	let head = node$1.children[0], checkable = typeof node$1.checked == "boolean" && head && head.type === "paragraph", checkbox = "[" + (node$1.checked ? "x" : " ") + "] ", tracker = state.createTracker(info);
	checkable && tracker.move(checkbox);
	let value = handle.listItem(node$1, parent, state, {
		...info,
		...tracker.current()
	});
	return checkable && (value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check)), value;
	function check($0) {
		return $0 + checkbox;
	}
}
function gfmFromMarkdown() {
	return [
		gfmAutolinkLiteralFromMarkdown(),
		gfmFootnoteFromMarkdown(),
		gfmStrikethroughFromMarkdown(),
		gfmTableFromMarkdown(),
		gfmTaskListItemFromMarkdown()
	];
}
function gfmToMarkdown(options) {
	return { extensions: [
		gfmAutolinkLiteralToMarkdown(),
		gfmFootnoteToMarkdown(options),
		gfmStrikethroughToMarkdown(),
		gfmTableToMarkdown(options),
		gfmTaskListItemToMarkdown()
	] };
}
var wwwPrefix = {
	tokenize: tokenizeWwwPrefix,
	partial: !0
}, domain = {
	tokenize: tokenizeDomain,
	partial: !0
}, path = {
	tokenize: tokenizePath,
	partial: !0
}, trail = {
	tokenize: tokenizeTrail,
	partial: !0
}, emailDomainDotTrail = {
	tokenize: tokenizeEmailDomainDotTrail,
	partial: !0
}, wwwAutolink = {
	name: "wwwAutolink",
	tokenize: tokenizeWwwAutolink,
	previous: previousWww
}, protocolAutolink = {
	name: "protocolAutolink",
	tokenize: tokenizeProtocolAutolink,
	previous: previousProtocol
}, emailAutolink = {
	name: "emailAutolink",
	tokenize: tokenizeEmailAutolink,
	previous: previousEmail
}, text = {};
function gfmAutolinkLiteral() {
	return { text };
}
for (var code$1 = 48; code$1 < 123;) text[code$1] = emailAutolink, code$1++, code$1 === 58 ? code$1 = 65 : code$1 === 91 && (code$1 = 97);
text[43] = emailAutolink, text[45] = emailAutolink, text[46] = emailAutolink, text[95] = emailAutolink, text[72] = [emailAutolink, protocolAutolink], text[104] = [emailAutolink, protocolAutolink], text[87] = [emailAutolink, wwwAutolink], text[119] = [emailAutolink, wwwAutolink];
function tokenizeEmailAutolink(effects, ok$2, nok) {
	let self$1 = this, dot, data;
	return start;
	function start(code$4) {
		return !gfmAtext(code$4) || !previousEmail.call(self$1, self$1.previous) || previousUnbalanced(self$1.events) ? nok(code$4) : (effects.enter("literalAutolink"), effects.enter("literalAutolinkEmail"), atext(code$4));
	}
	function atext(code$4) {
		return gfmAtext(code$4) ? (effects.consume(code$4), atext) : code$4 === 64 ? (effects.consume(code$4), emailDomain) : nok(code$4);
	}
	function emailDomain(code$4) {
		return code$4 === 46 ? effects.check(emailDomainDotTrail, emailDomainAfter, emailDomainDot)(code$4) : code$4 === 45 || code$4 === 95 || asciiAlphanumeric(code$4) ? (data = !0, effects.consume(code$4), emailDomain) : emailDomainAfter(code$4);
	}
	function emailDomainDot(code$4) {
		return effects.consume(code$4), dot = !0, emailDomain;
	}
	function emailDomainAfter(code$4) {
		return data && dot && asciiAlpha(self$1.previous) ? (effects.exit("literalAutolinkEmail"), effects.exit("literalAutolink"), ok$2(code$4)) : nok(code$4);
	}
}
function tokenizeWwwAutolink(effects, ok$2, nok) {
	let self$1 = this;
	return wwwStart;
	function wwwStart(code$4) {
		return code$4 !== 87 && code$4 !== 119 || !previousWww.call(self$1, self$1.previous) || previousUnbalanced(self$1.events) ? nok(code$4) : (effects.enter("literalAutolink"), effects.enter("literalAutolinkWww"), effects.check(wwwPrefix, effects.attempt(domain, effects.attempt(path, wwwAfter), nok), nok)(code$4));
	}
	function wwwAfter(code$4) {
		return effects.exit("literalAutolinkWww"), effects.exit("literalAutolink"), ok$2(code$4);
	}
}
function tokenizeProtocolAutolink(effects, ok$2, nok) {
	let self$1 = this, buffer = "", seen = !1;
	return protocolStart;
	function protocolStart(code$4) {
		return (code$4 === 72 || code$4 === 104) && previousProtocol.call(self$1, self$1.previous) && !previousUnbalanced(self$1.events) ? (effects.enter("literalAutolink"), effects.enter("literalAutolinkHttp"), buffer += String.fromCodePoint(code$4), effects.consume(code$4), protocolPrefixInside) : nok(code$4);
	}
	function protocolPrefixInside(code$4) {
		if (asciiAlpha(code$4) && buffer.length < 5) return buffer += String.fromCodePoint(code$4), effects.consume(code$4), protocolPrefixInside;
		if (code$4 === 58) {
			let protocol = buffer.toLowerCase();
			if (protocol === "http" || protocol === "https") return effects.consume(code$4), protocolSlashesInside;
		}
		return nok(code$4);
	}
	function protocolSlashesInside(code$4) {
		return code$4 === 47 ? (effects.consume(code$4), seen ? afterProtocol : (seen = !0, protocolSlashesInside)) : nok(code$4);
	}
	function afterProtocol(code$4) {
		return code$4 === null || asciiControl(code$4) || markdownLineEndingOrSpace(code$4) || unicodeWhitespace(code$4) || unicodePunctuation(code$4) ? nok(code$4) : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code$4);
	}
	function protocolAfter(code$4) {
		return effects.exit("literalAutolinkHttp"), effects.exit("literalAutolink"), ok$2(code$4);
	}
}
function tokenizeWwwPrefix(effects, ok$2, nok) {
	let size = 0;
	return wwwPrefixInside;
	function wwwPrefixInside(code$4) {
		return (code$4 === 87 || code$4 === 119) && size < 3 ? (size++, effects.consume(code$4), wwwPrefixInside) : code$4 === 46 && size === 3 ? (effects.consume(code$4), wwwPrefixAfter) : nok(code$4);
	}
	function wwwPrefixAfter(code$4) {
		return code$4 === null ? nok(code$4) : ok$2(code$4);
	}
}
function tokenizeDomain(effects, ok$2, nok) {
	let underscoreInLastSegment, underscoreInLastLastSegment, seen;
	return domainInside;
	function domainInside(code$4) {
		return code$4 === 46 || code$4 === 95 ? effects.check(trail, domainAfter, domainAtPunctuation)(code$4) : code$4 === null || markdownLineEndingOrSpace(code$4) || unicodeWhitespace(code$4) || code$4 !== 45 && unicodePunctuation(code$4) ? domainAfter(code$4) : (seen = !0, effects.consume(code$4), domainInside);
	}
	function domainAtPunctuation(code$4) {
		return code$4 === 95 ? underscoreInLastSegment = !0 : (underscoreInLastLastSegment = underscoreInLastSegment, underscoreInLastSegment = void 0), effects.consume(code$4), domainInside;
	}
	function domainAfter(code$4) {
		return underscoreInLastLastSegment || underscoreInLastSegment || !seen ? nok(code$4) : ok$2(code$4);
	}
}
function tokenizePath(effects, ok$2) {
	let sizeOpen = 0, sizeClose = 0;
	return pathInside;
	function pathInside(code$4) {
		return code$4 === 40 ? (sizeOpen++, effects.consume(code$4), pathInside) : code$4 === 41 && sizeClose < sizeOpen ? pathAtPunctuation(code$4) : code$4 === 33 || code$4 === 34 || code$4 === 38 || code$4 === 39 || code$4 === 41 || code$4 === 42 || code$4 === 44 || code$4 === 46 || code$4 === 58 || code$4 === 59 || code$4 === 60 || code$4 === 63 || code$4 === 93 || code$4 === 95 || code$4 === 126 ? effects.check(trail, ok$2, pathAtPunctuation)(code$4) : code$4 === null || markdownLineEndingOrSpace(code$4) || unicodeWhitespace(code$4) ? ok$2(code$4) : (effects.consume(code$4), pathInside);
	}
	function pathAtPunctuation(code$4) {
		return code$4 === 41 && sizeClose++, effects.consume(code$4), pathInside;
	}
}
function tokenizeTrail(effects, ok$2, nok) {
	return trail$1;
	function trail$1(code$4) {
		return code$4 === 33 || code$4 === 34 || code$4 === 39 || code$4 === 41 || code$4 === 42 || code$4 === 44 || code$4 === 46 || code$4 === 58 || code$4 === 59 || code$4 === 63 || code$4 === 95 || code$4 === 126 ? (effects.consume(code$4), trail$1) : code$4 === 38 ? (effects.consume(code$4), trailCharacterReferenceStart) : code$4 === 93 ? (effects.consume(code$4), trailBracketAfter) : code$4 === 60 || code$4 === null || markdownLineEndingOrSpace(code$4) || unicodeWhitespace(code$4) ? ok$2(code$4) : nok(code$4);
	}
	function trailBracketAfter(code$4) {
		return code$4 === null || code$4 === 40 || code$4 === 91 || markdownLineEndingOrSpace(code$4) || unicodeWhitespace(code$4) ? ok$2(code$4) : trail$1(code$4);
	}
	function trailCharacterReferenceStart(code$4) {
		return asciiAlpha(code$4) ? trailCharacterReferenceInside(code$4) : nok(code$4);
	}
	function trailCharacterReferenceInside(code$4) {
		return code$4 === 59 ? (effects.consume(code$4), trail$1) : asciiAlpha(code$4) ? (effects.consume(code$4), trailCharacterReferenceInside) : nok(code$4);
	}
}
function tokenizeEmailDomainDotTrail(effects, ok$2, nok) {
	return start;
	function start(code$4) {
		return effects.consume(code$4), after;
	}
	function after(code$4) {
		return asciiAlphanumeric(code$4) ? nok(code$4) : ok$2(code$4);
	}
}
function previousWww(code$4) {
	return code$4 === null || code$4 === 40 || code$4 === 42 || code$4 === 95 || code$4 === 91 || code$4 === 93 || code$4 === 126 || markdownLineEndingOrSpace(code$4);
}
function previousProtocol(code$4) {
	return !asciiAlpha(code$4);
}
function previousEmail(code$4) {
	return !(code$4 === 47 || gfmAtext(code$4));
}
function gfmAtext(code$4) {
	return code$4 === 43 || code$4 === 45 || code$4 === 46 || code$4 === 95 || asciiAlphanumeric(code$4);
}
function previousUnbalanced(events) {
	let index$2 = events.length, result = !1;
	for (; index$2--;) {
		let token = events[index$2][1];
		if ((token.type === "labelLink" || token.type === "labelImage") && !token._balanced) {
			result = !0;
			break;
		}
		if (token._gfmAutolinkLiteralWalkedInto) {
			result = !1;
			break;
		}
	}
	return events.length > 0 && !result && (events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), result;
}
var indent = {
	tokenize: tokenizeIndent,
	partial: !0
};
function gfmFootnote() {
	return {
		document: { 91: {
			name: "gfmFootnoteDefinition",
			tokenize: tokenizeDefinitionStart,
			continuation: { tokenize: tokenizeDefinitionContinuation },
			exit: gfmFootnoteDefinitionEnd
		} },
		text: {
			91: {
				name: "gfmFootnoteCall",
				tokenize: tokenizeGfmFootnoteCall
			},
			93: {
				name: "gfmPotentialFootnoteCall",
				add: "after",
				tokenize: tokenizePotentialGfmFootnoteCall,
				resolveTo: resolveToPotentialGfmFootnoteCall
			}
		}
	};
}
function tokenizePotentialGfmFootnoteCall(effects, ok$2, nok) {
	let self$1 = this, index$2 = self$1.events.length, defined = self$1.parser.gfmFootnotes || (self$1.parser.gfmFootnotes = []), labelStart;
	for (; index$2--;) {
		let token = self$1.events[index$2][1];
		if (token.type === "labelImage") {
			labelStart = token;
			break;
		}
		if (token.type === "gfmFootnoteCall" || token.type === "labelLink" || token.type === "label" || token.type === "image" || token.type === "link") break;
	}
	return start;
	function start(code$4) {
		if (!labelStart || !labelStart._balanced) return nok(code$4);
		let id = normalizeIdentifier(self$1.sliceSerialize({
			start: labelStart.end,
			end: self$1.now()
		}));
		return id.codePointAt(0) !== 94 || !defined.includes(id.slice(1)) ? nok(code$4) : (effects.enter("gfmFootnoteCallLabelMarker"), effects.consume(code$4), effects.exit("gfmFootnoteCallLabelMarker"), ok$2(code$4));
	}
}
function resolveToPotentialGfmFootnoteCall(events, context) {
	let index$2 = events.length;
	for (; index$2--;) if (events[index$2][1].type === "labelImage" && events[index$2][0] === "enter") {
		events[index$2][1];
		break;
	}
	events[index$2 + 1][1].type = "data", events[index$2 + 3][1].type = "gfmFootnoteCallLabelMarker";
	let call = {
		type: "gfmFootnoteCall",
		start: Object.assign({}, events[index$2 + 3][1].start),
		end: Object.assign({}, events[events.length - 1][1].end)
	}, marker = {
		type: "gfmFootnoteCallMarker",
		start: Object.assign({}, events[index$2 + 3][1].end),
		end: Object.assign({}, events[index$2 + 3][1].end)
	};
	marker.end.column++, marker.end.offset++, marker.end._bufferIndex++;
	let string$2 = {
		type: "gfmFootnoteCallString",
		start: Object.assign({}, marker.end),
		end: Object.assign({}, events[events.length - 1][1].start)
	}, chunk = {
		type: "chunkString",
		contentType: "string",
		start: Object.assign({}, string$2.start),
		end: Object.assign({}, string$2.end)
	}, replacement = [
		events[index$2 + 1],
		events[index$2 + 2],
		[
			"enter",
			call,
			context
		],
		events[index$2 + 3],
		events[index$2 + 4],
		[
			"enter",
			marker,
			context
		],
		[
			"exit",
			marker,
			context
		],
		[
			"enter",
			string$2,
			context
		],
		[
			"enter",
			chunk,
			context
		],
		[
			"exit",
			chunk,
			context
		],
		[
			"exit",
			string$2,
			context
		],
		events[events.length - 2],
		events[events.length - 1],
		[
			"exit",
			call,
			context
		]
	];
	return events.splice(index$2, events.length - index$2 + 1, ...replacement), events;
}
function tokenizeGfmFootnoteCall(effects, ok$2, nok) {
	let self$1 = this, defined = self$1.parser.gfmFootnotes || (self$1.parser.gfmFootnotes = []), size = 0, data;
	return start;
	function start(code$4) {
		return effects.enter("gfmFootnoteCall"), effects.enter("gfmFootnoteCallLabelMarker"), effects.consume(code$4), effects.exit("gfmFootnoteCallLabelMarker"), callStart;
	}
	function callStart(code$4) {
		return code$4 === 94 ? (effects.enter("gfmFootnoteCallMarker"), effects.consume(code$4), effects.exit("gfmFootnoteCallMarker"), effects.enter("gfmFootnoteCallString"), effects.enter("chunkString").contentType = "string", callData) : nok(code$4);
	}
	function callData(code$4) {
		if (size > 999 || code$4 === 93 && !data || code$4 === null || code$4 === 91 || markdownLineEndingOrSpace(code$4)) return nok(code$4);
		if (code$4 === 93) {
			effects.exit("chunkString");
			let token = effects.exit("gfmFootnoteCallString");
			return defined.includes(normalizeIdentifier(self$1.sliceSerialize(token))) ? (effects.enter("gfmFootnoteCallLabelMarker"), effects.consume(code$4), effects.exit("gfmFootnoteCallLabelMarker"), effects.exit("gfmFootnoteCall"), ok$2) : nok(code$4);
		}
		return markdownLineEndingOrSpace(code$4) || (data = !0), size++, effects.consume(code$4), code$4 === 92 ? callEscape : callData;
	}
	function callEscape(code$4) {
		return code$4 === 91 || code$4 === 92 || code$4 === 93 ? (effects.consume(code$4), size++, callData) : callData(code$4);
	}
}
function tokenizeDefinitionStart(effects, ok$2, nok) {
	let self$1 = this, defined = self$1.parser.gfmFootnotes || (self$1.parser.gfmFootnotes = []), identifier$1, size = 0, data;
	return start;
	function start(code$4) {
		return effects.enter("gfmFootnoteDefinition")._container = !0, effects.enter("gfmFootnoteDefinitionLabel"), effects.enter("gfmFootnoteDefinitionLabelMarker"), effects.consume(code$4), effects.exit("gfmFootnoteDefinitionLabelMarker"), labelAtMarker;
	}
	function labelAtMarker(code$4) {
		return code$4 === 94 ? (effects.enter("gfmFootnoteDefinitionMarker"), effects.consume(code$4), effects.exit("gfmFootnoteDefinitionMarker"), effects.enter("gfmFootnoteDefinitionLabelString"), effects.enter("chunkString").contentType = "string", labelInside) : nok(code$4);
	}
	function labelInside(code$4) {
		if (size > 999 || code$4 === 93 && !data || code$4 === null || code$4 === 91 || markdownLineEndingOrSpace(code$4)) return nok(code$4);
		if (code$4 === 93) {
			effects.exit("chunkString");
			let token = effects.exit("gfmFootnoteDefinitionLabelString");
			return identifier$1 = normalizeIdentifier(self$1.sliceSerialize(token)), effects.enter("gfmFootnoteDefinitionLabelMarker"), effects.consume(code$4), effects.exit("gfmFootnoteDefinitionLabelMarker"), effects.exit("gfmFootnoteDefinitionLabel"), labelAfter;
		}
		return markdownLineEndingOrSpace(code$4) || (data = !0), size++, effects.consume(code$4), code$4 === 92 ? labelEscape : labelInside;
	}
	function labelEscape(code$4) {
		return code$4 === 91 || code$4 === 92 || code$4 === 93 ? (effects.consume(code$4), size++, labelInside) : labelInside(code$4);
	}
	function labelAfter(code$4) {
		return code$4 === 58 ? (effects.enter("definitionMarker"), effects.consume(code$4), effects.exit("definitionMarker"), defined.includes(identifier$1) || defined.push(identifier$1), factorySpace(effects, whitespaceAfter, "gfmFootnoteDefinitionWhitespace")) : nok(code$4);
	}
	function whitespaceAfter(code$4) {
		return ok$2(code$4);
	}
}
function tokenizeDefinitionContinuation(effects, ok$2, nok) {
	return effects.check(blankLine, ok$2, effects.attempt(indent, ok$2, nok));
}
function gfmFootnoteDefinitionEnd(effects) {
	effects.exit("gfmFootnoteDefinition");
}
function tokenizeIndent(effects, ok$2, nok) {
	let self$1 = this;
	return factorySpace(effects, afterPrefix, "gfmFootnoteDefinitionIndent", 5);
	function afterPrefix(code$4) {
		let tail = self$1.events[self$1.events.length - 1];
		return tail && tail[1].type === "gfmFootnoteDefinitionIndent" && tail[2].sliceSerialize(tail[1], !0).length === 4 ? ok$2(code$4) : nok(code$4);
	}
}
function gfmStrikethrough(options) {
	let single = (options || {}).singleTilde, tokenizer = {
		name: "strikethrough",
		tokenize: tokenizeStrikethrough,
		resolveAll: resolveAllStrikethrough
	};
	return single ??= !0, {
		text: { 126: tokenizer },
		insideSpan: { null: [tokenizer] },
		attentionMarkers: { null: [126] }
	};
	function resolveAllStrikethrough(events, context) {
		let index$2 = -1;
		for (; ++index$2 < events.length;) if (events[index$2][0] === "enter" && events[index$2][1].type === "strikethroughSequenceTemporary" && events[index$2][1]._close) {
			let open = index$2;
			for (; open--;) if (events[open][0] === "exit" && events[open][1].type === "strikethroughSequenceTemporary" && events[open][1]._open && events[index$2][1].end.offset - events[index$2][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
				events[index$2][1].type = "strikethroughSequence", events[open][1].type = "strikethroughSequence";
				let strikethrough$1 = {
					type: "strikethrough",
					start: Object.assign({}, events[open][1].start),
					end: Object.assign({}, events[index$2][1].end)
				}, text$6 = {
					type: "strikethroughText",
					start: Object.assign({}, events[open][1].end),
					end: Object.assign({}, events[index$2][1].start)
				}, nextEvents = [
					[
						"enter",
						strikethrough$1,
						context
					],
					[
						"enter",
						events[open][1],
						context
					],
					[
						"exit",
						events[open][1],
						context
					],
					[
						"enter",
						text$6,
						context
					]
				], insideSpan$1 = context.parser.constructs.insideSpan.null;
				insideSpan$1 && splice(nextEvents, nextEvents.length, 0, resolveAll(insideSpan$1, events.slice(open + 1, index$2), context)), splice(nextEvents, nextEvents.length, 0, [
					[
						"exit",
						text$6,
						context
					],
					[
						"enter",
						events[index$2][1],
						context
					],
					[
						"exit",
						events[index$2][1],
						context
					],
					[
						"exit",
						strikethrough$1,
						context
					]
				]), splice(events, open - 1, index$2 - open + 3, nextEvents), index$2 = open + nextEvents.length - 2;
				break;
			}
		}
		for (index$2 = -1; ++index$2 < events.length;) events[index$2][1].type === "strikethroughSequenceTemporary" && (events[index$2][1].type = "data");
		return events;
	}
	function tokenizeStrikethrough(effects, ok$2, nok) {
		let previous$2 = this.previous, events = this.events, size = 0;
		return start;
		function start(code$4) {
			return previous$2 === 126 && events[events.length - 1][1].type !== "characterEscape" ? nok(code$4) : (effects.enter("strikethroughSequenceTemporary"), more(code$4));
		}
		function more(code$4) {
			let before = classifyCharacter(previous$2);
			if (code$4 === 126) return size > 1 ? nok(code$4) : (effects.consume(code$4), size++, more);
			if (size < 2 && !single) return nok(code$4);
			let token = effects.exit("strikethroughSequenceTemporary"), after = classifyCharacter(code$4);
			return token._open = !after || after === 2 && !!before, token._close = !before || before === 2 && !!after, ok$2(code$4);
		}
	}
}
var EditMap = class {
	constructor() {
		this.map = [];
	}
	add(index$2, remove, add) {
		addImplementation(this, index$2, remove, add);
	}
	consume(events) {
		/* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */
		if (this.map.sort(function(a, b) {
			return a[0] - b[0];
		}), this.map.length === 0) return;
		let index$2 = this.map.length, vecs = [];
		for (; index$2 > 0;) --index$2, vecs.push(events.slice(this.map[index$2][0] + this.map[index$2][1]), this.map[index$2][2]), events.length = this.map[index$2][0];
		vecs.push(events.slice()), events.length = 0;
		let slice = vecs.pop();
		for (; slice;) {
			for (let element$3 of slice) events.push(element$3);
			slice = vecs.pop();
		}
		this.map.length = 0;
	}
};
function addImplementation(editMap, at, remove, add) {
	let index$2 = 0;
	if (!(remove === 0 && add.length === 0)) {
		for (; index$2 < editMap.map.length;) {
			if (editMap.map[index$2][0] === at) {
				editMap.map[index$2][1] += remove, editMap.map[index$2][2].push(...add);
				return;
			}
			index$2 += 1;
		}
		editMap.map.push([
			at,
			remove,
			add
		]);
	}
}
function gfmTableAlign(events, index$2) {
	let inDelimiterRow = !1, align = [];
	for (; index$2 < events.length;) {
		let event = events[index$2];
		if (inDelimiterRow) {
			if (event[0] === "enter") event[1].type === "tableContent" && align.push(events[index$2 + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
			else if (event[1].type === "tableContent") {
				if (events[index$2 - 1][1].type === "tableDelimiterMarker") {
					let alignIndex = align.length - 1;
					align[alignIndex] = align[alignIndex] === "left" ? "center" : "right";
				}
			} else if (event[1].type === "tableDelimiterRow") break;
		} else event[0] === "enter" && event[1].type === "tableDelimiterRow" && (inDelimiterRow = !0);
		index$2 += 1;
	}
	return align;
}
function gfmTable() {
	return { flow: { null: {
		name: "table",
		tokenize: tokenizeTable,
		resolveAll: resolveTable
	} } };
}
function tokenizeTable(effects, ok$2, nok) {
	let self$1 = this, size = 0, sizeB = 0, seen;
	return start;
	function start(code$4) {
		let index$2 = self$1.events.length - 1;
		for (; index$2 > -1;) {
			let type = self$1.events[index$2][1].type;
			if (type === "lineEnding" || type === "linePrefix") index$2--;
			else break;
		}
		let tail = index$2 > -1 ? self$1.events[index$2][1].type : null, next = tail === "tableHead" || tail === "tableRow" ? bodyRowStart : headRowBefore;
		return next === bodyRowStart && self$1.parser.lazy[self$1.now().line] ? nok(code$4) : next(code$4);
	}
	function headRowBefore(code$4) {
		return effects.enter("tableHead"), effects.enter("tableRow"), headRowStart(code$4);
	}
	function headRowStart(code$4) {
		return code$4 === 124 ? headRowBreak(code$4) : (seen = !0, sizeB += 1, headRowBreak(code$4));
	}
	function headRowBreak(code$4) {
		return code$4 === null ? nok(code$4) : markdownLineEnding(code$4) ? sizeB > 1 ? (sizeB = 0, self$1.interrupt = !0, effects.exit("tableRow"), effects.enter("lineEnding"), effects.consume(code$4), effects.exit("lineEnding"), headDelimiterStart) : nok(code$4) : markdownSpace(code$4) ? factorySpace(effects, headRowBreak, "whitespace")(code$4) : (sizeB += 1, seen && (seen = !1, size += 1), code$4 === 124 ? (effects.enter("tableCellDivider"), effects.consume(code$4), effects.exit("tableCellDivider"), seen = !0, headRowBreak) : (effects.enter("data"), headRowData(code$4)));
	}
	function headRowData(code$4) {
		return code$4 === null || code$4 === 124 || markdownLineEndingOrSpace(code$4) ? (effects.exit("data"), headRowBreak(code$4)) : (effects.consume(code$4), code$4 === 92 ? headRowEscape : headRowData);
	}
	function headRowEscape(code$4) {
		return code$4 === 92 || code$4 === 124 ? (effects.consume(code$4), headRowData) : headRowData(code$4);
	}
	function headDelimiterStart(code$4) {
		return self$1.interrupt = !1, self$1.parser.lazy[self$1.now().line] ? nok(code$4) : (effects.enter("tableDelimiterRow"), seen = !1, markdownSpace(code$4) ? factorySpace(effects, headDelimiterBefore, "linePrefix", self$1.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code$4) : headDelimiterBefore(code$4));
	}
	function headDelimiterBefore(code$4) {
		return code$4 === 45 || code$4 === 58 ? headDelimiterValueBefore(code$4) : code$4 === 124 ? (seen = !0, effects.enter("tableCellDivider"), effects.consume(code$4), effects.exit("tableCellDivider"), headDelimiterCellBefore) : headDelimiterNok(code$4);
	}
	function headDelimiterCellBefore(code$4) {
		return markdownSpace(code$4) ? factorySpace(effects, headDelimiterValueBefore, "whitespace")(code$4) : headDelimiterValueBefore(code$4);
	}
	function headDelimiterValueBefore(code$4) {
		return code$4 === 58 ? (sizeB += 1, seen = !0, effects.enter("tableDelimiterMarker"), effects.consume(code$4), effects.exit("tableDelimiterMarker"), headDelimiterLeftAlignmentAfter) : code$4 === 45 ? (sizeB += 1, headDelimiterLeftAlignmentAfter(code$4)) : code$4 === null || markdownLineEnding(code$4) ? headDelimiterCellAfter(code$4) : headDelimiterNok(code$4);
	}
	function headDelimiterLeftAlignmentAfter(code$4) {
		return code$4 === 45 ? (effects.enter("tableDelimiterFiller"), headDelimiterFiller(code$4)) : headDelimiterNok(code$4);
	}
	function headDelimiterFiller(code$4) {
		return code$4 === 45 ? (effects.consume(code$4), headDelimiterFiller) : code$4 === 58 ? (seen = !0, effects.exit("tableDelimiterFiller"), effects.enter("tableDelimiterMarker"), effects.consume(code$4), effects.exit("tableDelimiterMarker"), headDelimiterRightAlignmentAfter) : (effects.exit("tableDelimiterFiller"), headDelimiterRightAlignmentAfter(code$4));
	}
	function headDelimiterRightAlignmentAfter(code$4) {
		return markdownSpace(code$4) ? factorySpace(effects, headDelimiterCellAfter, "whitespace")(code$4) : headDelimiterCellAfter(code$4);
	}
	function headDelimiterCellAfter(code$4) {
		return code$4 === 124 ? headDelimiterBefore(code$4) : code$4 === null || markdownLineEnding(code$4) ? !seen || size !== sizeB ? headDelimiterNok(code$4) : (effects.exit("tableDelimiterRow"), effects.exit("tableHead"), ok$2(code$4)) : headDelimiterNok(code$4);
	}
	function headDelimiterNok(code$4) {
		return nok(code$4);
	}
	function bodyRowStart(code$4) {
		return effects.enter("tableRow"), bodyRowBreak(code$4);
	}
	function bodyRowBreak(code$4) {
		return code$4 === 124 ? (effects.enter("tableCellDivider"), effects.consume(code$4), effects.exit("tableCellDivider"), bodyRowBreak) : code$4 === null || markdownLineEnding(code$4) ? (effects.exit("tableRow"), ok$2(code$4)) : markdownSpace(code$4) ? factorySpace(effects, bodyRowBreak, "whitespace")(code$4) : (effects.enter("data"), bodyRowData(code$4));
	}
	function bodyRowData(code$4) {
		return code$4 === null || code$4 === 124 || markdownLineEndingOrSpace(code$4) ? (effects.exit("data"), bodyRowBreak(code$4)) : (effects.consume(code$4), code$4 === 92 ? bodyRowEscape : bodyRowData);
	}
	function bodyRowEscape(code$4) {
		return code$4 === 92 || code$4 === 124 ? (effects.consume(code$4), bodyRowData) : bodyRowData(code$4);
	}
}
function resolveTable(events, context) {
	let index$2 = -1, inFirstCellAwaitingPipe = !0, rowKind = 0, lastCell = [
		0,
		0,
		0,
		0
	], cell$1 = [
		0,
		0,
		0,
		0
	], afterHeadAwaitingFirstBodyRow = !1, lastTableEnd = 0, currentTable, currentBody, currentCell, map$2 = new EditMap();
	for (; ++index$2 < events.length;) {
		let event = events[index$2], token = event[1];
		event[0] === "enter" ? token.type === "tableHead" ? (afterHeadAwaitingFirstBodyRow = !1, lastTableEnd !== 0 && (flushTableEnd(map$2, context, lastTableEnd, currentTable, currentBody), currentBody = void 0, lastTableEnd = 0), currentTable = {
			type: "table",
			start: Object.assign({}, token.start),
			end: Object.assign({}, token.end)
		}, map$2.add(index$2, 0, [[
			"enter",
			currentTable,
			context
		]])) : token.type === "tableRow" || token.type === "tableDelimiterRow" ? (inFirstCellAwaitingPipe = !0, currentCell = void 0, lastCell = [
			0,
			0,
			0,
			0
		], cell$1 = [
			0,
			index$2 + 1,
			0,
			0
		], afterHeadAwaitingFirstBodyRow && (afterHeadAwaitingFirstBodyRow = !1, currentBody = {
			type: "tableBody",
			start: Object.assign({}, token.start),
			end: Object.assign({}, token.end)
		}, map$2.add(index$2, 0, [[
			"enter",
			currentBody,
			context
		]])), rowKind = token.type === "tableDelimiterRow" ? 2 : currentBody ? 3 : 1) : rowKind && (token.type === "data" || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller") ? (inFirstCellAwaitingPipe = !1, cell$1[2] === 0 && (lastCell[1] !== 0 && (cell$1[0] = cell$1[1], currentCell = flushCell(map$2, context, lastCell, rowKind, void 0, currentCell), lastCell = [
			0,
			0,
			0,
			0
		]), cell$1[2] = index$2)) : token.type === "tableCellDivider" && (inFirstCellAwaitingPipe ? inFirstCellAwaitingPipe = !1 : (lastCell[1] !== 0 && (cell$1[0] = cell$1[1], currentCell = flushCell(map$2, context, lastCell, rowKind, void 0, currentCell)), lastCell = cell$1, cell$1 = [
			lastCell[1],
			index$2,
			0,
			0
		])) : token.type === "tableHead" ? (afterHeadAwaitingFirstBodyRow = !0, lastTableEnd = index$2) : token.type === "tableRow" || token.type === "tableDelimiterRow" ? (lastTableEnd = index$2, lastCell[1] === 0 ? cell$1[1] !== 0 && (currentCell = flushCell(map$2, context, cell$1, rowKind, index$2, currentCell)) : (cell$1[0] = cell$1[1], currentCell = flushCell(map$2, context, lastCell, rowKind, index$2, currentCell)), rowKind = 0) : rowKind && (token.type === "data" || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller") && (cell$1[3] = index$2);
	}
	for (lastTableEnd !== 0 && flushTableEnd(map$2, context, lastTableEnd, currentTable, currentBody), map$2.consume(context.events), index$2 = -1; ++index$2 < context.events.length;) {
		let event = context.events[index$2];
		event[0] === "enter" && event[1].type === "table" && (event[1]._align = gfmTableAlign(context.events, index$2));
	}
	return events;
}
function flushCell(map$2, context, range, rowKind, rowEnd, previousCell) {
	let groupName = rowKind === 1 ? "tableHeader" : rowKind === 2 ? "tableDelimiter" : "tableData", valueName = "tableContent";
	range[0] !== 0 && (previousCell.end = Object.assign({}, getPoint(context.events, range[0])), map$2.add(range[0], 0, [[
		"exit",
		previousCell,
		context
	]]));
	let now = getPoint(context.events, range[1]);
	if (previousCell = {
		type: groupName,
		start: Object.assign({}, now),
		end: Object.assign({}, now)
	}, map$2.add(range[1], 0, [[
		"enter",
		previousCell,
		context
	]]), range[2] !== 0) {
		let relatedStart = getPoint(context.events, range[2]), relatedEnd = getPoint(context.events, range[3]), valueToken = {
			type: "tableContent",
			start: Object.assign({}, relatedStart),
			end: Object.assign({}, relatedEnd)
		};
		if (map$2.add(range[2], 0, [[
			"enter",
			valueToken,
			context
		]]), rowKind !== 2) {
			let start = context.events[range[2]], end = context.events[range[3]];
			if (start[1].end = Object.assign({}, end[1].end), start[1].type = "chunkText", start[1].contentType = "text", range[3] > range[2] + 1) {
				let a = range[2] + 1, b = range[3] - range[2] - 1;
				map$2.add(a, b, []);
			}
		}
		map$2.add(range[3] + 1, 0, [[
			"exit",
			valueToken,
			context
		]]);
	}
	return rowEnd !== void 0 && (previousCell.end = Object.assign({}, getPoint(context.events, rowEnd)), map$2.add(rowEnd, 0, [[
		"exit",
		previousCell,
		context
	]]), previousCell = void 0), previousCell;
}
function flushTableEnd(map$2, context, index$2, table$1, tableBody) {
	let exits = [], related = getPoint(context.events, index$2);
	tableBody && (tableBody.end = Object.assign({}, related), exits.push([
		"exit",
		tableBody,
		context
	])), table$1.end = Object.assign({}, related), exits.push([
		"exit",
		table$1,
		context
	]), map$2.add(index$2 + 1, 0, exits);
}
function getPoint(events, index$2) {
	let event = events[index$2], side = event[0] === "enter" ? "start" : "end";
	return event[1][side];
}
var tasklistCheck = {
	name: "tasklistCheck",
	tokenize: tokenizeTasklistCheck
};
function gfmTaskListItem() {
	return { text: { 91: tasklistCheck } };
}
function tokenizeTasklistCheck(effects, ok$2, nok) {
	let self$1 = this;
	return open;
	function open(code$4) {
		return self$1.previous !== null || !self$1._gfmTasklistFirstContentOfListItem ? nok(code$4) : (effects.enter("taskListCheck"), effects.enter("taskListCheckMarker"), effects.consume(code$4), effects.exit("taskListCheckMarker"), inside);
	}
	function inside(code$4) {
		return markdownLineEndingOrSpace(code$4) ? (effects.enter("taskListCheckValueUnchecked"), effects.consume(code$4), effects.exit("taskListCheckValueUnchecked"), close) : code$4 === 88 || code$4 === 120 ? (effects.enter("taskListCheckValueChecked"), effects.consume(code$4), effects.exit("taskListCheckValueChecked"), close) : nok(code$4);
	}
	function close(code$4) {
		return code$4 === 93 ? (effects.enter("taskListCheckMarker"), effects.consume(code$4), effects.exit("taskListCheckMarker"), effects.exit("taskListCheck"), after) : nok(code$4);
	}
	function after(code$4) {
		return markdownLineEnding(code$4) ? ok$2(code$4) : markdownSpace(code$4) ? effects.check({ tokenize: spaceThenNonSpace }, ok$2, nok)(code$4) : nok(code$4);
	}
}
function spaceThenNonSpace(effects, ok$2, nok) {
	return factorySpace(effects, after, "whitespace");
	function after(code$4) {
		return code$4 === null ? nok(code$4) : ok$2(code$4);
	}
}
function gfm(options) {
	return combineExtensions([
		gfmAutolinkLiteral(),
		gfmFootnote(),
		gfmStrikethrough(options),
		gfmTable(),
		gfmTaskListItem()
	]);
}
var emptyOptions$3 = {};
function remarkGfm(options) {
	let self$1 = this, settings = options || emptyOptions$3, data = self$1.data(), micromarkExtensions = data.micromarkExtensions ||= [], fromMarkdownExtensions = data.fromMarkdownExtensions ||= [], toMarkdownExtensions = data.toMarkdownExtensions ||= [];
	micromarkExtensions.push(gfm(settings)), fromMarkdownExtensions.push(gfmFromMarkdown()), toMarkdownExtensions.push(gfmToMarkdown(settings));
}
const findAfter = (function(parent, index$2, test) {
	let is = convert(test);
	if (!parent || !parent.type || !parent.children) throw Error("Expected parent node");
	if (typeof index$2 == "number") {
		if (index$2 < 0 || index$2 === Infinity) throw Error("Expected positive finite number as index");
	} else if (index$2 = parent.children.indexOf(index$2), index$2 < 0) throw Error("Expected child node or index");
	for (; ++index$2 < parent.children.length;) if (is(parent.children[index$2], index$2, parent)) return parent.children[index$2];
}), convertElement = (function(test) {
	if (test == null) return element;
	if (typeof test == "string") return tagNameFactory(test);
	if (typeof test == "object") return anyFactory(test);
	if (typeof test == "function") return castFactory(test);
	throw Error("Expected function, string, or array as `test`");
});
function anyFactory(tests) {
	let checks$1 = [], index$2 = -1;
	for (; ++index$2 < tests.length;) checks$1[index$2] = convertElement(tests[index$2]);
	return castFactory(any);
	function any(...parameters) {
		let index$3 = -1;
		for (; ++index$3 < checks$1.length;) if (checks$1[index$3].apply(this, parameters)) return !0;
		return !1;
	}
}
function tagNameFactory(check) {
	return castFactory(tagName);
	function tagName(element$3) {
		return element$3.tagName === check;
	}
}
function castFactory(testFunction) {
	return check;
	function check(value, index$2, parent) {
		return !!(looksLikeAnElement(value) && testFunction.call(this, value, typeof index$2 == "number" ? index$2 : void 0, parent || void 0));
	}
}
function element(element$3) {
	return !!(element$3 && typeof element$3 == "object" && "type" in element$3 && element$3.type === "element" && "tagName" in element$3 && typeof element$3.tagName == "string");
}
function looksLikeAnElement(value) {
	return typeof value == "object" && !!value && "type" in value && "tagName" in value;
}
var searchLineFeeds = /\n/g, searchTabOrSpaces = /[\t ]+/g, br = convertElement("br"), cell = convertElement(isCell), p = convertElement("p"), row = convertElement("tr"), notRendered = convertElement([
	"datalist",
	"head",
	"noembed",
	"noframes",
	"noscript",
	"rp",
	"script",
	"style",
	"template",
	"title",
	hidden,
	closedDialog
]), blockOrCaption = convertElement(/* @__PURE__ */ "address.article.aside.blockquote.body.caption.center.dd.dialog.dir.dl.dt.div.figure.figcaption.footer.form,.h1.h2.h3.h4.h5.h6.header.hgroup.hr.html.legend.li.listing.main.menu.nav.ol.p.plaintext.pre.section.ul.xmp".split("."));
function toText(tree, options) {
	let options_ = options || {}, children = "children" in tree ? tree.children : [], block = blockOrCaption(tree), whitespace$1 = inferWhitespace(tree, {
		whitespace: options_.whitespace || "normal",
		breakBefore: !1,
		breakAfter: !1
	}), results = [];
	(tree.type === "text" || tree.type === "comment") && results.push(...collectText(tree, {
		whitespace: whitespace$1,
		breakBefore: !0,
		breakAfter: !0
	}));
	let index$2 = -1;
	for (; ++index$2 < children.length;) results.push(...renderedTextCollection(children[index$2], tree, {
		whitespace: whitespace$1,
		breakBefore: index$2 ? void 0 : block,
		breakAfter: index$2 < children.length - 1 ? br(children[index$2 + 1]) : block
	}));
	let result = [], count;
	for (index$2 = -1; ++index$2 < results.length;) {
		let value = results[index$2];
		typeof value == "number" ? count !== void 0 && value > count && (count = value) : value && (count !== void 0 && count > -1 && result.push("\n".repeat(count) || " "), count = -1, result.push(value));
	}
	return result.join("");
}
function renderedTextCollection(node$1, parent, info) {
	return node$1.type === "element" ? collectElement(node$1, parent, info) : node$1.type === "text" ? info.whitespace === "normal" ? collectText(node$1, info) : collectPreText(node$1) : [];
}
function collectElement(node$1, parent, info) {
	let whitespace$1 = inferWhitespace(node$1, info), children = node$1.children || [], index$2 = -1, items = [];
	if (notRendered(node$1)) return items;
	let prefix, suffix;
	for (br(node$1) || row(node$1) && findAfter(parent, node$1, row) ? suffix = "\n" : p(node$1) ? (prefix = 2, suffix = 2) : blockOrCaption(node$1) && (prefix = 1, suffix = 1); ++index$2 < children.length;) items = items.concat(renderedTextCollection(children[index$2], node$1, {
		whitespace: whitespace$1,
		breakBefore: index$2 ? void 0 : prefix,
		breakAfter: index$2 < children.length - 1 ? br(children[index$2 + 1]) : suffix
	}));
	return cell(node$1) && findAfter(parent, node$1, cell) && items.push("	"), prefix && items.unshift(prefix), suffix && items.push(suffix), items;
}
function collectText(node$1, info) {
	let value = String(node$1.value), lines = [], result = [], start = 0;
	for (; start <= value.length;) {
		searchLineFeeds.lastIndex = start;
		let match = searchLineFeeds.exec(value), end = match && "index" in match ? match.index : value.length;
		lines.push(trimAndCollapseSpacesAndTabs(value.slice(start, end).replace(/[\u061C\u200E\u200F\u202A-\u202E\u2066-\u2069]/g, ""), start === 0 ? info.breakBefore : !0, end === value.length ? info.breakAfter : !0)), start = end + 1;
	}
	let index$2 = -1, join$1;
	for (; ++index$2 < lines.length;) lines[index$2].charCodeAt(lines[index$2].length - 1) === 8203 || index$2 < lines.length - 1 && lines[index$2 + 1].charCodeAt(0) === 8203 ? (result.push(lines[index$2]), join$1 = void 0) : lines[index$2] ? (typeof join$1 == "number" && result.push(join$1), result.push(lines[index$2]), join$1 = 0) : (index$2 === 0 || index$2 === lines.length - 1) && result.push(0);
	return result;
}
function collectPreText(node$1) {
	return [String(node$1.value)];
}
function trimAndCollapseSpacesAndTabs(value, breakBefore, breakAfter) {
	let result = [], start = 0, end;
	for (; start < value.length;) {
		searchTabOrSpaces.lastIndex = start;
		let match = searchTabOrSpaces.exec(value);
		end = match ? match.index : value.length, !start && !end && match && !breakBefore && result.push(""), start !== end && result.push(value.slice(start, end)), start = match ? end + match[0].length : end;
	}
	return start !== end && !breakAfter && result.push(""), result.join(" ");
}
function inferWhitespace(node$1, info) {
	if (node$1.type === "element") {
		let properties = node$1.properties || {};
		switch (node$1.tagName) {
			case "listing":
			case "plaintext":
			case "xmp": return "pre";
			case "nobr": return "nowrap";
			case "pre": return properties.wrap ? "pre-wrap" : "pre";
			case "td":
			case "th": return properties.noWrap ? "nowrap" : info.whitespace;
			case "textarea": return "pre-wrap";
			default:
		}
	}
	return info.whitespace;
}
function hidden(node$1) {
	return !!(node$1.properties || {}).hidden;
}
function isCell(node$1) {
	return node$1.tagName === "td" || node$1.tagName === "th";
}
function closedDialog(node$1) {
	return node$1.tagName === "dialog" && !(node$1.properties || {}).open;
}
function cPlusPlus(hljs) {
	let regex$1 = hljs.regex, C_LINE_COMMENT_MODE$1 = hljs.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), DECLTYPE_AUTO_RE = "decltype\\(auto\\)", NAMESPACE_RE = "[a-zA-Z_]\\w*::", FUNCTION_TYPE_RE = "(?!struct)(" + DECLTYPE_AUTO_RE + "|" + regex$1.optional(NAMESPACE_RE) + "[a-zA-Z_]\\w*" + regex$1.optional("<[^<>]+>") + ")", CPP_PRIMITIVE_TYPES = {
		className: "type",
		begin: "\\b[a-z\\d_]*_t\\b"
	}, STRINGS = {
		className: "string",
		variants: [
			{
				begin: "(u8?|U|L)?\"",
				end: "\"",
				illegal: "\\n",
				contains: [hljs.BACKSLASH_ESCAPE]
			},
			{
				begin: "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
				end: "'",
				illegal: "."
			},
			hljs.END_SAME_AS_BEGIN({
				begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
				end: /\)([^()\\ ]{0,16})"/
			})
		]
	}, NUMBERS = {
		className: "number",
		variants: [{ begin: "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)" }, { begin: "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)" }],
		relevance: 0
	}, PREPROCESSOR = {
		className: "meta",
		begin: /#\s*[a-z]+\b/,
		end: /$/,
		keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
		contains: [
			{
				begin: /\\\n/,
				relevance: 0
			},
			hljs.inherit(STRINGS, { className: "string" }),
			{
				className: "string",
				begin: /<.*?>/
			},
			C_LINE_COMMENT_MODE$1,
			hljs.C_BLOCK_COMMENT_MODE
		]
	}, TITLE_MODE$1 = {
		className: "title",
		begin: regex$1.optional(NAMESPACE_RE) + hljs.IDENT_RE,
		relevance: 0
	}, FUNCTION_TITLE = regex$1.optional(NAMESPACE_RE) + hljs.IDENT_RE + "\\s*\\(", RESERVED_KEYWORDS = /* @__PURE__ */ "alignas.alignof.and.and_eq.asm.atomic_cancel.atomic_commit.atomic_noexcept.auto.bitand.bitor.break.case.catch.class.co_await.co_return.co_yield.compl.concept.const_cast|10.consteval.constexpr.constinit.continue.decltype.default.delete.do.dynamic_cast|10.else.enum.explicit.export.extern.false.final.for.friend.goto.if.import.inline.module.mutable.namespace.new.noexcept.not.not_eq.nullptr.operator.or.or_eq.override.private.protected.public.reflexpr.register.reinterpret_cast|10.requires.return.sizeof.static_assert.static_cast|10.struct.switch.synchronized.template.this.thread_local.throw.transaction_safe.transaction_safe_dynamic.true.try.typedef.typeid.typename.union.using.virtual.volatile.while.xor.xor_eq".split("."), RESERVED_TYPES = [
		"bool",
		"char",
		"char16_t",
		"char32_t",
		"char8_t",
		"double",
		"float",
		"int",
		"long",
		"short",
		"void",
		"wchar_t",
		"unsigned",
		"signed",
		"const",
		"static"
	], TYPE_HINTS = /* @__PURE__ */ "any.auto_ptr.barrier.binary_semaphore.bitset.complex.condition_variable.condition_variable_any.counting_semaphore.deque.false_type.flat_map.flat_set.future.imaginary.initializer_list.istringstream.jthread.latch.lock_guard.multimap.multiset.mutex.optional.ostringstream.packaged_task.pair.promise.priority_queue.queue.recursive_mutex.recursive_timed_mutex.scoped_lock.set.shared_future.shared_lock.shared_mutex.shared_timed_mutex.shared_ptr.stack.string_view.stringstream.timed_mutex.thread.true_type.tuple.unique_lock.unique_ptr.unordered_map.unordered_multimap.unordered_multiset.unordered_set.variant.vector.weak_ptr.wstring.wstring_view".split("."), FUNCTION_HINTS = /* @__PURE__ */ "abort.abs.acos.apply.as_const.asin.atan.atan2.calloc.ceil.cerr.cin.clog.cos.cosh.cout.declval.endl.exchange.exit.exp.fabs.floor.fmod.forward.fprintf.fputs.free.frexp.fscanf.future.invoke.isalnum.isalpha.iscntrl.isdigit.isgraph.islower.isprint.ispunct.isspace.isupper.isxdigit.labs.launder.ldexp.log.log10.make_pair.make_shared.make_shared_for_overwrite.make_tuple.make_unique.malloc.memchr.memcmp.memcpy.memset.modf.move.pow.printf.putchar.puts.realloc.scanf.sin.sinh.snprintf.sprintf.sqrt.sscanf.std.stderr.stdin.stdout.strcat.strchr.strcmp.strcpy.strcspn.strlen.strncat.strncmp.strncpy.strpbrk.strrchr.strspn.strstr.swap.tan.tanh.terminate.to_underlying.tolower.toupper.vfprintf.visit.vprintf.vsprintf".split("."), CPP_KEYWORDS = {
		type: RESERVED_TYPES,
		keyword: RESERVED_KEYWORDS,
		literal: [
			"NULL",
			"false",
			"nullopt",
			"nullptr",
			"true"
		],
		built_in: ["_Pragma"],
		_type_hints: TYPE_HINTS
	}, FUNCTION_DISPATCH = {
		className: "function.dispatch",
		relevance: 0,
		keywords: { _hint: FUNCTION_HINTS },
		begin: regex$1.concat(/\b/, /(?!decltype)/, /(?!if)/, /(?!for)/, /(?!switch)/, /(?!while)/, hljs.IDENT_RE, regex$1.lookahead(/(<[^<>]+>|)\s*\(/))
	}, EXPRESSION_CONTAINS = [
		FUNCTION_DISPATCH,
		PREPROCESSOR,
		CPP_PRIMITIVE_TYPES,
		C_LINE_COMMENT_MODE$1,
		hljs.C_BLOCK_COMMENT_MODE,
		NUMBERS,
		STRINGS
	], EXPRESSION_CONTEXT = {
		variants: [
			{
				begin: /=/,
				end: /;/
			},
			{
				begin: /\(/,
				end: /\)/
			},
			{
				beginKeywords: "new throw return else",
				end: /;/
			}
		],
		keywords: CPP_KEYWORDS,
		contains: EXPRESSION_CONTAINS.concat([{
			begin: /\(/,
			end: /\)/,
			keywords: CPP_KEYWORDS,
			contains: EXPRESSION_CONTAINS.concat(["self"]),
			relevance: 0
		}]),
		relevance: 0
	}, FUNCTION_DECLARATION = {
		className: "function",
		begin: "(" + FUNCTION_TYPE_RE + "[\\*&\\s]+)+" + FUNCTION_TITLE,
		returnBegin: !0,
		end: /[{;=]/,
		excludeEnd: !0,
		keywords: CPP_KEYWORDS,
		illegal: /[^\w\s\*&:<>.]/,
		contains: [
			{
				begin: DECLTYPE_AUTO_RE,
				keywords: CPP_KEYWORDS,
				relevance: 0
			},
			{
				begin: FUNCTION_TITLE,
				returnBegin: !0,
				contains: [TITLE_MODE$1],
				relevance: 0
			},
			{
				begin: /::/,
				relevance: 0
			},
			{
				begin: /:/,
				endsWithParent: !0,
				contains: [STRINGS, NUMBERS]
			},
			{
				relevance: 0,
				match: /,/
			},
			{
				className: "params",
				begin: /\(/,
				end: /\)/,
				keywords: CPP_KEYWORDS,
				relevance: 0,
				contains: [
					C_LINE_COMMENT_MODE$1,
					hljs.C_BLOCK_COMMENT_MODE,
					STRINGS,
					NUMBERS,
					CPP_PRIMITIVE_TYPES,
					{
						begin: /\(/,
						end: /\)/,
						keywords: CPP_KEYWORDS,
						relevance: 0,
						contains: [
							"self",
							C_LINE_COMMENT_MODE$1,
							hljs.C_BLOCK_COMMENT_MODE,
							STRINGS,
							NUMBERS,
							CPP_PRIMITIVE_TYPES
						]
					}
				]
			},
			CPP_PRIMITIVE_TYPES,
			C_LINE_COMMENT_MODE$1,
			hljs.C_BLOCK_COMMENT_MODE,
			PREPROCESSOR
		]
	};
	return {
		name: "C++",
		aliases: [
			"cc",
			"c++",
			"h++",
			"hpp",
			"hh",
			"hxx",
			"cxx"
		],
		keywords: CPP_KEYWORDS,
		illegal: "</",
		classNameAliases: { "function.dispatch": "built_in" },
		contains: [].concat(EXPRESSION_CONTEXT, FUNCTION_DECLARATION, FUNCTION_DISPATCH, EXPRESSION_CONTAINS, [
			PREPROCESSOR,
			{
				begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function|flat_map|flat_set)\\s*<(?!<)",
				end: ">",
				keywords: CPP_KEYWORDS,
				contains: ["self", CPP_PRIMITIVE_TYPES]
			},
			{
				begin: hljs.IDENT_RE + "::",
				keywords: CPP_KEYWORDS
			},
			{
				match: [
					/\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
					/\s+/,
					/\w+/
				],
				className: {
					1: "keyword",
					3: "title.class"
				}
			}
		])
	};
}
function arduino(hljs) {
	let ARDUINO_KW = {
		type: [
			"boolean",
			"byte",
			"word",
			"String"
		],
		built_in: /* @__PURE__ */ "KeyboardController.MouseController.SoftwareSerial.EthernetServer.EthernetClient.LiquidCrystal.RobotControl.GSMVoiceCall.EthernetUDP.EsploraTFT.HttpClient.RobotMotor.WiFiClient.GSMScanner.FileSystem.Scheduler.GSMServer.YunClient.YunServer.IPAddress.GSMClient.GSMModem.Keyboard.Ethernet.Console.GSMBand.Esplora.Stepper.Process.WiFiUDP.GSM_SMS.Mailbox.USBHost.Firmata.PImage.Client.Server.GSMPIN.FileIO.Bridge.Serial.EEPROM.Stream.Mouse.Audio.Servo.File.Task.GPRS.WiFi.Wire.TFT.GSM.SPI.SD".split("."),
		_hints: /* @__PURE__ */ "setup.loop.runShellCommandAsynchronously.analogWriteResolution.retrieveCallingNumber.printFirmwareVersion.analogReadResolution.sendDigitalPortPair.noListenOnLocalhost.readJoystickButton.setFirmwareVersion.readJoystickSwitch.scrollDisplayRight.getVoiceCallStatus.scrollDisplayLeft.writeMicroseconds.delayMicroseconds.beginTransmission.getSignalStrength.runAsynchronously.getAsynchronously.listenOnLocalhost.getCurrentCarrier.readAccelerometer.messageAvailable.sendDigitalPorts.lineFollowConfig.countryNameWrite.runShellCommand.readStringUntil.rewindDirectory.readTemperature.setClockDivider.readLightSensor.endTransmission.analogReference.detachInterrupt.countryNameRead.attachInterrupt.encryptionType.readBytesUntil.robotNameWrite.readMicrophone.robotNameRead.cityNameWrite.userNameWrite.readJoystickY.readJoystickX.mouseReleased.openNextFile.scanNetworks.noInterrupts.digitalWrite.beginSpeaker.mousePressed.isActionDone.mouseDragged.displayLogos.noAutoscroll.addParameter.remoteNumber.getModifiers.keyboardRead.userNameRead.waitContinue.processInput.parseCommand.printVersion.readNetworks.writeMessage.blinkVersion.cityNameRead.readMessage.setDataMode.parsePacket.isListening.setBitOrder.beginPacket.isDirectory.motorsWrite.drawCompass.digitalRead.clearScreen.serialEvent.rightToLeft.setTextSize.leftToRight.requestFrom.keyReleased.compassRead.analogWrite.interrupts.WiFiServer.disconnect.playMelody.parseFloat.autoscroll.getPINUsed.setPINUsed.setTimeout.sendAnalog.readSlider.analogRead.beginWrite.createChar.motorsStop.keyPressed.tempoWrite.readButton.subnetMask.debugPrint.macAddress.writeGreen.randomSeed.attachGPRS.readString.sendString.remotePort.releaseAll.mouseMoved.background.getXChange.getYChange.answerCall.getResult.voiceCall.endPacket.constrain.getSocket.writeJSON.getButton.available.connected.findUntil.readBytes.exitValue.readGreen.writeBlue.startLoop.IPAddress.isPressed.sendSysex.pauseMode.gatewayIP.setCursor.getOemKey.tuneWrite.noDisplay.loadImage.switchPIN.onRequest.onReceive.changePIN.playFile.noBuffer.parseInt.overflow.checkPIN.knobRead.beginTFT.bitClear.updateIR.bitWrite.position.writeRGB.highByte.writeRed.setSpeed.readBlue.noStroke.remoteIP.transfer.shutdown.hangCall.beginSMS.endWrite.attached.maintain.noCursor.checkReg.checkPUK.shiftOut.isValid.shiftIn.pulseIn.connect.println.localIP.pinMode.getIMEI.display.noBlink.process.getBand.running.beginSD.drawBMP.lowByte.setBand.release.bitRead.prepare.pointTo.readRed.setMode.noFill.remove.listen.stroke.detach.attach.noTone.exists.buffer.height.bitSet.circle.config.cursor.random.IRread.setDNS.endSMS.getKey.micros.millis.begin.print.write.ready.flush.width.isPIN.blink.clear.press.mkdir.rmdir.close.point.yield.image.BSSID.click.delay.read.text.move.peek.beep.rect.line.open.seek.fill.size.turn.stop.home.find.step.tone.sqrt.RSSI.SSID.end.bit.tan.cos.sin.pow.map.abs.max.min.get.run.put".split("."),
		literal: [
			"DIGITAL_MESSAGE",
			"FIRMATA_STRING",
			"ANALOG_MESSAGE",
			"REPORT_DIGITAL",
			"REPORT_ANALOG",
			"INPUT_PULLUP",
			"SET_PIN_MODE",
			"INTERNAL2V56",
			"SYSTEM_RESET",
			"LED_BUILTIN",
			"INTERNAL1V1",
			"SYSEX_START",
			"INTERNAL",
			"EXTERNAL",
			"DEFAULT",
			"OUTPUT",
			"INPUT",
			"HIGH",
			"LOW"
		]
	}, ARDUINO = cPlusPlus(hljs), kws = ARDUINO.keywords;
	return kws.type = [...kws.type, ...ARDUINO_KW.type], kws.literal = [...kws.literal, ...ARDUINO_KW.literal], kws.built_in = [...kws.built_in, ...ARDUINO_KW.built_in], kws._hints = ARDUINO_KW._hints, ARDUINO.name = "Arduino", ARDUINO.aliases = ["ino"], ARDUINO.supersetOf = "cpp", ARDUINO;
}
function bash(hljs) {
	let regex$1 = hljs.regex, VAR = {}, BRACED_VAR = {
		begin: /\$\{/,
		end: /\}/,
		contains: ["self", {
			begin: /:-/,
			contains: [VAR]
		}]
	};
	Object.assign(VAR, {
		className: "variable",
		variants: [{ begin: regex$1.concat(/\$[\w\d#@][\w\d_]*/, "(?![\\w\\d])(?![$])") }, BRACED_VAR]
	});
	let SUBST = {
		className: "subst",
		begin: /\$\(/,
		end: /\)/,
		contains: [hljs.BACKSLASH_ESCAPE]
	}, COMMENT$1 = hljs.inherit(hljs.COMMENT(), {
		match: [/(^|\s)/, /#.*$/],
		scope: { 2: "comment" }
	}), HERE_DOC = {
		begin: /<<-?\s*(?=\w+)/,
		starts: { contains: [hljs.END_SAME_AS_BEGIN({
			begin: /(\w+)/,
			end: /(\w+)/,
			className: "string"
		})] }
	}, QUOTE_STRING = {
		className: "string",
		begin: /"/,
		end: /"/,
		contains: [
			hljs.BACKSLASH_ESCAPE,
			VAR,
			SUBST
		]
	};
	SUBST.contains.push(QUOTE_STRING);
	let ESCAPED_QUOTE = { match: /\\"/ }, APOS_STRING = {
		className: "string",
		begin: /'/,
		end: /'/
	}, ESCAPED_APOS = { match: /\\'/ }, ARITHMETIC = {
		begin: /\$?\(\(/,
		end: /\)\)/,
		contains: [
			{
				begin: /\d+#[0-9a-f]+/,
				className: "number"
			},
			hljs.NUMBER_MODE,
			VAR
		]
	}, KNOWN_SHEBANG = hljs.SHEBANG({
		binary: `(${[
			"fish",
			"bash",
			"zsh",
			"sh",
			"csh",
			"ksh",
			"tcsh",
			"dash",
			"scsh"
		].join("|")})`,
		relevance: 10
	}), FUNCTION = {
		className: "function",
		begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
		returnBegin: !0,
		contains: [hljs.inherit(hljs.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
		relevance: 0
	}, KEYWORDS$2 = [
		"if",
		"then",
		"else",
		"elif",
		"fi",
		"time",
		"for",
		"while",
		"until",
		"in",
		"do",
		"done",
		"case",
		"esac",
		"coproc",
		"function",
		"select"
	], LITERALS$2 = ["true", "false"], PATH_MODE = { match: /(\/[a-z._-]+)+/ }, SHELL_BUILT_INS = [
		"break",
		"cd",
		"continue",
		"eval",
		"exec",
		"exit",
		"export",
		"getopts",
		"hash",
		"pwd",
		"readonly",
		"return",
		"shift",
		"test",
		"times",
		"trap",
		"umask",
		"unset"
	], BASH_BUILT_INS = [
		"alias",
		"bind",
		"builtin",
		"caller",
		"command",
		"declare",
		"echo",
		"enable",
		"help",
		"let",
		"local",
		"logout",
		"mapfile",
		"printf",
		"read",
		"readarray",
		"source",
		"sudo",
		"type",
		"typeset",
		"ulimit",
		"unalias"
	], ZSH_BUILT_INS = /* @__PURE__ */ "autoload.bg.bindkey.bye.cap.chdir.clone.comparguments.compcall.compctl.compdescribe.compfiles.compgroups.compquote.comptags.comptry.compvalues.dirs.disable.disown.echotc.echoti.emulate.fc.fg.float.functions.getcap.getln.history.integer.jobs.kill.limit.log.noglob.popd.print.pushd.pushln.rehash.sched.setcap.setopt.stat.suspend.ttyctl.unfunction.unhash.unlimit.unsetopt.vared.wait.whence.where.which.zcompile.zformat.zftp.zle.zmodload.zparseopts.zprof.zpty.zregexparse.zsocket.zstyle.ztcp".split("."), GNU_CORE_UTILS = /* @__PURE__ */ "chcon.chgrp.chown.chmod.cp.dd.df.dir.dircolors.ln.ls.mkdir.mkfifo.mknod.mktemp.mv.realpath.rm.rmdir.shred.sync.touch.truncate.vdir.b2sum.base32.base64.cat.cksum.comm.csplit.cut.expand.fmt.fold.head.join.md5sum.nl.numfmt.od.paste.ptx.pr.sha1sum.sha224sum.sha256sum.sha384sum.sha512sum.shuf.sort.split.sum.tac.tail.tr.tsort.unexpand.uniq.wc.arch.basename.chroot.date.dirname.du.echo.env.expr.factor.groups.hostid.id.link.logname.nice.nohup.nproc.pathchk.pinky.printenv.printf.pwd.readlink.runcon.seq.sleep.stat.stdbuf.stty.tee.test.timeout.tty.uname.unlink.uptime.users.who.whoami.yes".split(".");
	return {
		name: "Bash",
		aliases: ["sh", "zsh"],
		keywords: {
			$pattern: /\b[a-z][a-z0-9._-]+\b/,
			keyword: KEYWORDS$2,
			literal: LITERALS$2,
			built_in: [
				...SHELL_BUILT_INS,
				...BASH_BUILT_INS,
				"set",
				"shopt",
				...ZSH_BUILT_INS,
				...GNU_CORE_UTILS
			]
		},
		contains: [
			KNOWN_SHEBANG,
			hljs.SHEBANG(),
			FUNCTION,
			ARITHMETIC,
			COMMENT$1,
			HERE_DOC,
			PATH_MODE,
			QUOTE_STRING,
			ESCAPED_QUOTE,
			APOS_STRING,
			ESCAPED_APOS,
			VAR
		]
	};
}
function c(hljs) {
	let regex$1 = hljs.regex, C_LINE_COMMENT_MODE$1 = hljs.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), DECLTYPE_AUTO_RE = "decltype\\(auto\\)", NAMESPACE_RE = "[a-zA-Z_]\\w*::", FUNCTION_TYPE_RE = "(" + DECLTYPE_AUTO_RE + "|" + regex$1.optional(NAMESPACE_RE) + "[a-zA-Z_]\\w*" + regex$1.optional("<[^<>]+>") + ")", TYPES$2 = {
		className: "type",
		variants: [{ begin: "\\b[a-z\\d_]*_t\\b" }, { match: /\batomic_[a-z]{3,6}\b/ }]
	}, STRINGS = {
		className: "string",
		variants: [
			{
				begin: "(u8?|U|L)?\"",
				end: "\"",
				illegal: "\\n",
				contains: [hljs.BACKSLASH_ESCAPE]
			},
			{
				begin: "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
				end: "'",
				illegal: "."
			},
			hljs.END_SAME_AS_BEGIN({
				begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
				end: /\)([^()\\ ]{0,16})"/
			})
		]
	}, NUMBERS = {
		className: "number",
		variants: [
			{ match: /\b(0b[01']+)/ },
			{ match: /(-?)\b([\d']+(\.[\d']*)?|\.[\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)/ },
			{ match: /(-?)\b(0[xX][a-fA-F0-9]+(?:'[a-fA-F0-9]+)*(?:\.[a-fA-F0-9]*(?:'[a-fA-F0-9]*)*)?(?:[pP][-+]?[0-9]+)?(l|L)?(u|U)?)/ },
			{ match: /(-?)\b\d+(?:'\d+)*(?:\.\d*(?:'\d*)*)?(?:[eE][-+]?\d+)?/ }
		],
		relevance: 0
	}, PREPROCESSOR = {
		className: "meta",
		begin: /#\s*[a-z]+\b/,
		end: /$/,
		keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef elifdef elifndef include" },
		contains: [
			{
				begin: /\\\n/,
				relevance: 0
			},
			hljs.inherit(STRINGS, { className: "string" }),
			{
				className: "string",
				begin: /<.*?>/
			},
			C_LINE_COMMENT_MODE$1,
			hljs.C_BLOCK_COMMENT_MODE
		]
	}, TITLE_MODE$1 = {
		className: "title",
		begin: regex$1.optional(NAMESPACE_RE) + hljs.IDENT_RE,
		relevance: 0
	}, FUNCTION_TITLE = regex$1.optional(NAMESPACE_RE) + hljs.IDENT_RE + "\\s*\\(", KEYWORDS$2 = {
		keyword: /* @__PURE__ */ "asm.auto.break.case.continue.default.do.else.enum.extern.for.fortran.goto.if.inline.register.restrict.return.sizeof.typeof.typeof_unqual.struct.switch.typedef.union.volatile.while._Alignas._Alignof._Atomic._Generic._Noreturn._Static_assert._Thread_local.alignas.alignof.noreturn.static_assert.thread_local._Pragma".split("."),
		type: /* @__PURE__ */ "float.double.signed.unsigned.int.short.long.char.void._Bool._BitInt._Complex._Imaginary._Decimal32._Decimal64._Decimal96._Decimal128._Decimal64x._Decimal128x._Float16._Float32._Float64._Float128._Float32x._Float64x._Float128x.const.static.constexpr.complex.bool.imaginary".split("."),
		literal: "true false NULL",
		built_in: "std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr"
	}, EXPRESSION_CONTAINS = [
		PREPROCESSOR,
		TYPES$2,
		C_LINE_COMMENT_MODE$1,
		hljs.C_BLOCK_COMMENT_MODE,
		NUMBERS,
		STRINGS
	], EXPRESSION_CONTEXT = {
		variants: [
			{
				begin: /=/,
				end: /;/
			},
			{
				begin: /\(/,
				end: /\)/
			},
			{
				beginKeywords: "new throw return else",
				end: /;/
			}
		],
		keywords: KEYWORDS$2,
		contains: EXPRESSION_CONTAINS.concat([{
			begin: /\(/,
			end: /\)/,
			keywords: KEYWORDS$2,
			contains: EXPRESSION_CONTAINS.concat(["self"]),
			relevance: 0
		}]),
		relevance: 0
	}, FUNCTION_DECLARATION = {
		begin: "(" + FUNCTION_TYPE_RE + "[\\*&\\s]+)+" + FUNCTION_TITLE,
		returnBegin: !0,
		end: /[{;=]/,
		excludeEnd: !0,
		keywords: KEYWORDS$2,
		illegal: /[^\w\s\*&:<>.]/,
		contains: [
			{
				begin: DECLTYPE_AUTO_RE,
				keywords: KEYWORDS$2,
				relevance: 0
			},
			{
				begin: FUNCTION_TITLE,
				returnBegin: !0,
				contains: [hljs.inherit(TITLE_MODE$1, { className: "title.function" })],
				relevance: 0
			},
			{
				relevance: 0,
				match: /,/
			},
			{
				className: "params",
				begin: /\(/,
				end: /\)/,
				keywords: KEYWORDS$2,
				relevance: 0,
				contains: [
					C_LINE_COMMENT_MODE$1,
					hljs.C_BLOCK_COMMENT_MODE,
					STRINGS,
					NUMBERS,
					TYPES$2,
					{
						begin: /\(/,
						end: /\)/,
						keywords: KEYWORDS$2,
						relevance: 0,
						contains: [
							"self",
							C_LINE_COMMENT_MODE$1,
							hljs.C_BLOCK_COMMENT_MODE,
							STRINGS,
							NUMBERS,
							TYPES$2
						]
					}
				]
			},
			TYPES$2,
			C_LINE_COMMENT_MODE$1,
			hljs.C_BLOCK_COMMENT_MODE,
			PREPROCESSOR
		]
	};
	return {
		name: "C",
		aliases: ["h"],
		keywords: KEYWORDS$2,
		disableAutodetect: !0,
		illegal: "</",
		contains: [].concat(EXPRESSION_CONTEXT, FUNCTION_DECLARATION, EXPRESSION_CONTAINS, [
			PREPROCESSOR,
			{
				begin: hljs.IDENT_RE + "::",
				keywords: KEYWORDS$2
			},
			{
				className: "class",
				beginKeywords: "enum class struct union",
				end: /[{;:<>=]/,
				contains: [{ beginKeywords: "final class struct" }, hljs.TITLE_MODE]
			}
		]),
		exports: {
			preprocessor: PREPROCESSOR,
			strings: STRINGS,
			keywords: KEYWORDS$2
		}
	};
}
function cpp(hljs) {
	let regex$1 = hljs.regex, C_LINE_COMMENT_MODE$1 = hljs.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), DECLTYPE_AUTO_RE = "decltype\\(auto\\)", NAMESPACE_RE = "[a-zA-Z_]\\w*::", FUNCTION_TYPE_RE = "(?!struct)(" + DECLTYPE_AUTO_RE + "|" + regex$1.optional(NAMESPACE_RE) + "[a-zA-Z_]\\w*" + regex$1.optional("<[^<>]+>") + ")", CPP_PRIMITIVE_TYPES = {
		className: "type",
		begin: "\\b[a-z\\d_]*_t\\b"
	}, STRINGS = {
		className: "string",
		variants: [
			{
				begin: "(u8?|U|L)?\"",
				end: "\"",
				illegal: "\\n",
				contains: [hljs.BACKSLASH_ESCAPE]
			},
			{
				begin: "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
				end: "'",
				illegal: "."
			},
			hljs.END_SAME_AS_BEGIN({
				begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
				end: /\)([^()\\ ]{0,16})"/
			})
		]
	}, NUMBERS = {
		className: "number",
		variants: [{ begin: "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)" }, { begin: "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)" }],
		relevance: 0
	}, PREPROCESSOR = {
		className: "meta",
		begin: /#\s*[a-z]+\b/,
		end: /$/,
		keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
		contains: [
			{
				begin: /\\\n/,
				relevance: 0
			},
			hljs.inherit(STRINGS, { className: "string" }),
			{
				className: "string",
				begin: /<.*?>/
			},
			C_LINE_COMMENT_MODE$1,
			hljs.C_BLOCK_COMMENT_MODE
		]
	}, TITLE_MODE$1 = {
		className: "title",
		begin: regex$1.optional(NAMESPACE_RE) + hljs.IDENT_RE,
		relevance: 0
	}, FUNCTION_TITLE = regex$1.optional(NAMESPACE_RE) + hljs.IDENT_RE + "\\s*\\(", RESERVED_KEYWORDS = /* @__PURE__ */ "alignas.alignof.and.and_eq.asm.atomic_cancel.atomic_commit.atomic_noexcept.auto.bitand.bitor.break.case.catch.class.co_await.co_return.co_yield.compl.concept.const_cast|10.consteval.constexpr.constinit.continue.decltype.default.delete.do.dynamic_cast|10.else.enum.explicit.export.extern.false.final.for.friend.goto.if.import.inline.module.mutable.namespace.new.noexcept.not.not_eq.nullptr.operator.or.or_eq.override.private.protected.public.reflexpr.register.reinterpret_cast|10.requires.return.sizeof.static_assert.static_cast|10.struct.switch.synchronized.template.this.thread_local.throw.transaction_safe.transaction_safe_dynamic.true.try.typedef.typeid.typename.union.using.virtual.volatile.while.xor.xor_eq".split("."), RESERVED_TYPES = [
		"bool",
		"char",
		"char16_t",
		"char32_t",
		"char8_t",
		"double",
		"float",
		"int",
		"long",
		"short",
		"void",
		"wchar_t",
		"unsigned",
		"signed",
		"const",
		"static"
	], TYPE_HINTS = /* @__PURE__ */ "any.auto_ptr.barrier.binary_semaphore.bitset.complex.condition_variable.condition_variable_any.counting_semaphore.deque.false_type.flat_map.flat_set.future.imaginary.initializer_list.istringstream.jthread.latch.lock_guard.multimap.multiset.mutex.optional.ostringstream.packaged_task.pair.promise.priority_queue.queue.recursive_mutex.recursive_timed_mutex.scoped_lock.set.shared_future.shared_lock.shared_mutex.shared_timed_mutex.shared_ptr.stack.string_view.stringstream.timed_mutex.thread.true_type.tuple.unique_lock.unique_ptr.unordered_map.unordered_multimap.unordered_multiset.unordered_set.variant.vector.weak_ptr.wstring.wstring_view".split("."), FUNCTION_HINTS = /* @__PURE__ */ "abort.abs.acos.apply.as_const.asin.atan.atan2.calloc.ceil.cerr.cin.clog.cos.cosh.cout.declval.endl.exchange.exit.exp.fabs.floor.fmod.forward.fprintf.fputs.free.frexp.fscanf.future.invoke.isalnum.isalpha.iscntrl.isdigit.isgraph.islower.isprint.ispunct.isspace.isupper.isxdigit.labs.launder.ldexp.log.log10.make_pair.make_shared.make_shared_for_overwrite.make_tuple.make_unique.malloc.memchr.memcmp.memcpy.memset.modf.move.pow.printf.putchar.puts.realloc.scanf.sin.sinh.snprintf.sprintf.sqrt.sscanf.std.stderr.stdin.stdout.strcat.strchr.strcmp.strcpy.strcspn.strlen.strncat.strncmp.strncpy.strpbrk.strrchr.strspn.strstr.swap.tan.tanh.terminate.to_underlying.tolower.toupper.vfprintf.visit.vprintf.vsprintf".split("."), CPP_KEYWORDS = {
		type: RESERVED_TYPES,
		keyword: RESERVED_KEYWORDS,
		literal: [
			"NULL",
			"false",
			"nullopt",
			"nullptr",
			"true"
		],
		built_in: ["_Pragma"],
		_type_hints: TYPE_HINTS
	}, FUNCTION_DISPATCH = {
		className: "function.dispatch",
		relevance: 0,
		keywords: { _hint: FUNCTION_HINTS },
		begin: regex$1.concat(/\b/, /(?!decltype)/, /(?!if)/, /(?!for)/, /(?!switch)/, /(?!while)/, hljs.IDENT_RE, regex$1.lookahead(/(<[^<>]+>|)\s*\(/))
	}, EXPRESSION_CONTAINS = [
		FUNCTION_DISPATCH,
		PREPROCESSOR,
		CPP_PRIMITIVE_TYPES,
		C_LINE_COMMENT_MODE$1,
		hljs.C_BLOCK_COMMENT_MODE,
		NUMBERS,
		STRINGS
	], EXPRESSION_CONTEXT = {
		variants: [
			{
				begin: /=/,
				end: /;/
			},
			{
				begin: /\(/,
				end: /\)/
			},
			{
				beginKeywords: "new throw return else",
				end: /;/
			}
		],
		keywords: CPP_KEYWORDS,
		contains: EXPRESSION_CONTAINS.concat([{
			begin: /\(/,
			end: /\)/,
			keywords: CPP_KEYWORDS,
			contains: EXPRESSION_CONTAINS.concat(["self"]),
			relevance: 0
		}]),
		relevance: 0
	}, FUNCTION_DECLARATION = {
		className: "function",
		begin: "(" + FUNCTION_TYPE_RE + "[\\*&\\s]+)+" + FUNCTION_TITLE,
		returnBegin: !0,
		end: /[{;=]/,
		excludeEnd: !0,
		keywords: CPP_KEYWORDS,
		illegal: /[^\w\s\*&:<>.]/,
		contains: [
			{
				begin: DECLTYPE_AUTO_RE,
				keywords: CPP_KEYWORDS,
				relevance: 0
			},
			{
				begin: FUNCTION_TITLE,
				returnBegin: !0,
				contains: [TITLE_MODE$1],
				relevance: 0
			},
			{
				begin: /::/,
				relevance: 0
			},
			{
				begin: /:/,
				endsWithParent: !0,
				contains: [STRINGS, NUMBERS]
			},
			{
				relevance: 0,
				match: /,/
			},
			{
				className: "params",
				begin: /\(/,
				end: /\)/,
				keywords: CPP_KEYWORDS,
				relevance: 0,
				contains: [
					C_LINE_COMMENT_MODE$1,
					hljs.C_BLOCK_COMMENT_MODE,
					STRINGS,
					NUMBERS,
					CPP_PRIMITIVE_TYPES,
					{
						begin: /\(/,
						end: /\)/,
						keywords: CPP_KEYWORDS,
						relevance: 0,
						contains: [
							"self",
							C_LINE_COMMENT_MODE$1,
							hljs.C_BLOCK_COMMENT_MODE,
							STRINGS,
							NUMBERS,
							CPP_PRIMITIVE_TYPES
						]
					}
				]
			},
			CPP_PRIMITIVE_TYPES,
			C_LINE_COMMENT_MODE$1,
			hljs.C_BLOCK_COMMENT_MODE,
			PREPROCESSOR
		]
	};
	return {
		name: "C++",
		aliases: [
			"cc",
			"c++",
			"h++",
			"hpp",
			"hh",
			"hxx",
			"cxx"
		],
		keywords: CPP_KEYWORDS,
		illegal: "</",
		classNameAliases: { "function.dispatch": "built_in" },
		contains: [].concat(EXPRESSION_CONTEXT, FUNCTION_DECLARATION, FUNCTION_DISPATCH, EXPRESSION_CONTAINS, [
			PREPROCESSOR,
			{
				begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function|flat_map|flat_set)\\s*<(?!<)",
				end: ">",
				keywords: CPP_KEYWORDS,
				contains: ["self", CPP_PRIMITIVE_TYPES]
			},
			{
				begin: hljs.IDENT_RE + "::",
				keywords: CPP_KEYWORDS
			},
			{
				match: [
					/\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
					/\s+/,
					/\w+/
				],
				className: {
					1: "keyword",
					3: "title.class"
				}
			}
		])
	};
}
function csharp(hljs) {
	let BUILT_IN_KEYWORDS = [
		"bool",
		"byte",
		"char",
		"decimal",
		"delegate",
		"double",
		"dynamic",
		"enum",
		"float",
		"int",
		"long",
		"nint",
		"nuint",
		"object",
		"sbyte",
		"short",
		"string",
		"ulong",
		"uint",
		"ushort"
	], FUNCTION_MODIFIERS = [
		"public",
		"private",
		"protected",
		"static",
		"internal",
		"protected",
		"abstract",
		"async",
		"extern",
		"override",
		"unsafe",
		"virtual",
		"new",
		"sealed",
		"partial"
	], KEYWORDS$2 = {
		keyword: (/* @__PURE__ */ "abstract.as.base.break.case.catch.class.const.continue.do.else.event.explicit.extern.finally.fixed.for.foreach.goto.if.implicit.in.interface.internal.is.lock.namespace.new.operator.out.override.params.private.protected.public.readonly.record.ref.return.scoped.sealed.sizeof.stackalloc.static.struct.switch.this.throw.try.typeof.unchecked.unsafe.using.virtual.void.volatile.while".split(".")).concat(/* @__PURE__ */ "add.alias.and.ascending.args.async.await.by.descending.dynamic.equals.file.from.get.global.group.init.into.join.let.nameof.not.notnull.on.or.orderby.partial.record.remove.required.scoped.select.set.unmanaged.value|0.var.when.where.with.yield".split(".")),
		built_in: BUILT_IN_KEYWORDS,
		literal: [
			"default",
			"false",
			"null",
			"true"
		]
	}, TITLE_MODE$1 = hljs.inherit(hljs.TITLE_MODE, { begin: "[a-zA-Z](\\.?\\w)*" }), NUMBERS = {
		className: "number",
		variants: [
			{ begin: "\\b(0b[01']+)" },
			{ begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)" },
			{ begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }
		],
		relevance: 0
	}, RAW_STRING = {
		className: "string",
		begin: /"""("*)(?!")(.|\n)*?"""\1/,
		relevance: 1
	}, VERBATIM_STRING = {
		className: "string",
		begin: "@\"",
		end: "\"",
		contains: [{ begin: "\"\"" }]
	}, VERBATIM_STRING_NO_LF = hljs.inherit(VERBATIM_STRING, { illegal: /\n/ }), SUBST = {
		className: "subst",
		begin: /\{/,
		end: /\}/,
		keywords: KEYWORDS$2
	}, SUBST_NO_LF = hljs.inherit(SUBST, { illegal: /\n/ }), INTERPOLATED_STRING = {
		className: "string",
		begin: /\$"/,
		end: "\"",
		illegal: /\n/,
		contains: [
			{ begin: /\{\{/ },
			{ begin: /\}\}/ },
			hljs.BACKSLASH_ESCAPE,
			SUBST_NO_LF
		]
	}, INTERPOLATED_VERBATIM_STRING = {
		className: "string",
		begin: /\$@"/,
		end: "\"",
		contains: [
			{ begin: /\{\{/ },
			{ begin: /\}\}/ },
			{ begin: "\"\"" },
			SUBST
		]
	}, INTERPOLATED_VERBATIM_STRING_NO_LF = hljs.inherit(INTERPOLATED_VERBATIM_STRING, {
		illegal: /\n/,
		contains: [
			{ begin: /\{\{/ },
			{ begin: /\}\}/ },
			{ begin: "\"\"" },
			SUBST_NO_LF
		]
	});
	SUBST.contains = [
		INTERPOLATED_VERBATIM_STRING,
		INTERPOLATED_STRING,
		VERBATIM_STRING,
		hljs.APOS_STRING_MODE,
		hljs.QUOTE_STRING_MODE,
		NUMBERS,
		hljs.C_BLOCK_COMMENT_MODE
	], SUBST_NO_LF.contains = [
		INTERPOLATED_VERBATIM_STRING_NO_LF,
		INTERPOLATED_STRING,
		VERBATIM_STRING_NO_LF,
		hljs.APOS_STRING_MODE,
		hljs.QUOTE_STRING_MODE,
		NUMBERS,
		hljs.inherit(hljs.C_BLOCK_COMMENT_MODE, { illegal: /\n/ })
	];
	let STRING = { variants: [
		RAW_STRING,
		INTERPOLATED_VERBATIM_STRING,
		INTERPOLATED_STRING,
		VERBATIM_STRING,
		hljs.APOS_STRING_MODE,
		hljs.QUOTE_STRING_MODE
	] }, GENERIC_MODIFIER = {
		begin: "<",
		end: ">",
		contains: [{ beginKeywords: "in out" }, TITLE_MODE$1]
	}, TYPE_IDENT_RE = hljs.IDENT_RE + "(<" + hljs.IDENT_RE + "(\\s*,\\s*" + hljs.IDENT_RE + ")*>)?(\\[\\])?", AT_IDENTIFIER = {
		begin: "@" + hljs.IDENT_RE,
		relevance: 0
	};
	return {
		name: "C#",
		aliases: ["cs", "c#"],
		keywords: KEYWORDS$2,
		illegal: /::/,
		contains: [
			hljs.COMMENT("///", "$", {
				returnBegin: !0,
				contains: [{
					className: "doctag",
					variants: [
						{
							begin: "///",
							relevance: 0
						},
						{ begin: "<!--|-->" },
						{
							begin: "</?",
							end: ">"
						}
					]
				}]
			}),
			hljs.C_LINE_COMMENT_MODE,
			hljs.C_BLOCK_COMMENT_MODE,
			{
				className: "meta",
				begin: "#",
				end: "$",
				keywords: { keyword: "if else elif endif define undef warning error line region endregion pragma checksum" }
			},
			STRING,
			NUMBERS,
			{
				beginKeywords: "class interface",
				relevance: 0,
				end: /[{;=]/,
				illegal: /[^\s:,]/,
				contains: [
					{ beginKeywords: "where class" },
					TITLE_MODE$1,
					GENERIC_MODIFIER,
					hljs.C_LINE_COMMENT_MODE,
					hljs.C_BLOCK_COMMENT_MODE
				]
			},
			{
				beginKeywords: "namespace",
				relevance: 0,
				end: /[{;=]/,
				illegal: /[^\s:]/,
				contains: [
					TITLE_MODE$1,
					hljs.C_LINE_COMMENT_MODE,
					hljs.C_BLOCK_COMMENT_MODE
				]
			},
			{
				beginKeywords: "record",
				relevance: 0,
				end: /[{;=]/,
				illegal: /[^\s:]/,
				contains: [
					TITLE_MODE$1,
					GENERIC_MODIFIER,
					hljs.C_LINE_COMMENT_MODE,
					hljs.C_BLOCK_COMMENT_MODE
				]
			},
			{
				className: "meta",
				begin: "^\\s*\\[(?=[\\w])",
				excludeBegin: !0,
				end: "\\]",
				excludeEnd: !0,
				contains: [{
					className: "string",
					begin: /"/,
					end: /"/
				}]
			},
			{
				beginKeywords: "new return throw await else",
				relevance: 0
			},
			{
				className: "function",
				begin: "(" + TYPE_IDENT_RE + "\\s+)+" + hljs.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
				returnBegin: !0,
				end: /\s*[{;=]/,
				excludeEnd: !0,
				keywords: KEYWORDS$2,
				contains: [
					{
						beginKeywords: FUNCTION_MODIFIERS.join(" "),
						relevance: 0
					},
					{
						begin: hljs.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
						returnBegin: !0,
						contains: [hljs.TITLE_MODE, GENERIC_MODIFIER],
						relevance: 0
					},
					{ match: /\(\)/ },
					{
						className: "params",
						begin: /\(/,
						end: /\)/,
						excludeBegin: !0,
						excludeEnd: !0,
						keywords: KEYWORDS$2,
						relevance: 0,
						contains: [
							STRING,
							NUMBERS,
							hljs.C_BLOCK_COMMENT_MODE
						]
					},
					hljs.C_LINE_COMMENT_MODE,
					hljs.C_BLOCK_COMMENT_MODE
				]
			},
			AT_IDENTIFIER
		]
	};
}
var MODES$3 = (hljs) => ({
	IMPORTANT: {
		scope: "meta",
		begin: "!important"
	},
	BLOCK_COMMENT: hljs.C_BLOCK_COMMENT_MODE,
	HEXCOLOR: {
		scope: "number",
		begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
	},
	FUNCTION_DISPATCH: {
		className: "built_in",
		begin: /[\w-]+(?=\()/
	},
	ATTRIBUTE_SELECTOR_MODE: {
		scope: "selector-attr",
		begin: /\[/,
		end: /\]/,
		illegal: "$",
		contains: [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE]
	},
	CSS_NUMBER_MODE: {
		scope: "number",
		begin: hljs.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
		relevance: 0
	},
	CSS_VARIABLE: {
		className: "attr",
		begin: /--[A-Za-z_][A-Za-z0-9_-]*/
	}
}), HTML_TAGS$2 = /* @__PURE__ */ "a.abbr.address.article.aside.audio.b.blockquote.body.button.canvas.caption.cite.code.dd.del.details.dfn.div.dl.dt.em.fieldset.figcaption.figure.footer.form.h1.h2.h3.h4.h5.h6.header.hgroup.html.i.iframe.img.input.ins.kbd.label.legend.li.main.mark.menu.nav.object.ol.optgroup.option.p.picture.q.quote.samp.section.select.source.span.strong.summary.sup.table.tbody.td.textarea.tfoot.th.thead.time.tr.ul.var.video".split("."), SVG_TAGS$2 = /* @__PURE__ */ "defs.g.marker.mask.pattern.svg.switch.symbol.feBlend.feColorMatrix.feComponentTransfer.feComposite.feConvolveMatrix.feDiffuseLighting.feDisplacementMap.feFlood.feGaussianBlur.feImage.feMerge.feMorphology.feOffset.feSpecularLighting.feTile.feTurbulence.linearGradient.radialGradient.stop.circle.ellipse.image.line.path.polygon.polyline.rect.text.use.textPath.tspan.foreignObject.clipPath".split("."), TAGS$2 = [...HTML_TAGS$2, ...SVG_TAGS$2], MEDIA_FEATURES$2 = (/* @__PURE__ */ "any-hover.any-pointer.aspect-ratio.color.color-gamut.color-index.device-aspect-ratio.device-height.device-width.display-mode.forced-colors.grid.height.hover.inverted-colors.monochrome.orientation.overflow-block.overflow-inline.pointer.prefers-color-scheme.prefers-contrast.prefers-reduced-motion.prefers-reduced-transparency.resolution.scan.scripting.update.width.min-width.max-width.min-height.max-height".split(".")).sort().reverse(), PSEUDO_CLASSES$2 = (/* @__PURE__ */ "active.any-link.blank.checked.current.default.defined.dir.disabled.drop.empty.enabled.first.first-child.first-of-type.fullscreen.future.focus.focus-visible.focus-within.has.host.host-context.hover.indeterminate.in-range.invalid.is.lang.last-child.last-of-type.left.link.local-link.not.nth-child.nth-col.nth-last-child.nth-last-col.nth-last-of-type.nth-of-type.only-child.only-of-type.optional.out-of-range.past.placeholder-shown.read-only.read-write.required.right.root.scope.target.target-within.user-invalid.valid.visited.where".split(".")).sort().reverse(), PSEUDO_ELEMENTS$2 = [
	"after",
	"backdrop",
	"before",
	"cue",
	"cue-region",
	"first-letter",
	"first-line",
	"grammar-error",
	"marker",
	"part",
	"placeholder",
	"selection",
	"slotted",
	"spelling-error"
].sort().reverse(), ATTRIBUTES$2 = (/* @__PURE__ */ "accent-color.align-content.align-items.align-self.alignment-baseline.all.anchor-name.animation.animation-composition.animation-delay.animation-direction.animation-duration.animation-fill-mode.animation-iteration-count.animation-name.animation-play-state.animation-range.animation-range-end.animation-range-start.animation-timeline.animation-timing-function.appearance.aspect-ratio.backdrop-filter.backface-visibility.background.background-attachment.background-blend-mode.background-clip.background-color.background-image.background-origin.background-position.background-position-x.background-position-y.background-repeat.background-size.baseline-shift.block-size.border.border-block.border-block-color.border-block-end.border-block-end-color.border-block-end-style.border-block-end-width.border-block-start.border-block-start-color.border-block-start-style.border-block-start-width.border-block-style.border-block-width.border-bottom.border-bottom-color.border-bottom-left-radius.border-bottom-right-radius.border-bottom-style.border-bottom-width.border-collapse.border-color.border-end-end-radius.border-end-start-radius.border-image.border-image-outset.border-image-repeat.border-image-slice.border-image-source.border-image-width.border-inline.border-inline-color.border-inline-end.border-inline-end-color.border-inline-end-style.border-inline-end-width.border-inline-start.border-inline-start-color.border-inline-start-style.border-inline-start-width.border-inline-style.border-inline-width.border-left.border-left-color.border-left-style.border-left-width.border-radius.border-right.border-right-color.border-right-style.border-right-width.border-spacing.border-start-end-radius.border-start-start-radius.border-style.border-top.border-top-color.border-top-left-radius.border-top-right-radius.border-top-style.border-top-width.border-width.bottom.box-align.box-decoration-break.box-direction.box-flex.box-flex-group.box-lines.box-ordinal-group.box-orient.box-pack.box-shadow.box-sizing.break-after.break-before.break-inside.caption-side.caret-color.clear.clip.clip-path.clip-rule.color.color-interpolation.color-interpolation-filters.color-profile.color-rendering.color-scheme.column-count.column-fill.column-gap.column-rule.column-rule-color.column-rule-style.column-rule-width.column-span.column-width.columns.contain.contain-intrinsic-block-size.contain-intrinsic-height.contain-intrinsic-inline-size.contain-intrinsic-size.contain-intrinsic-width.container.container-name.container-type.content.content-visibility.counter-increment.counter-reset.counter-set.cue.cue-after.cue-before.cursor.cx.cy.direction.display.dominant-baseline.empty-cells.enable-background.field-sizing.fill.fill-opacity.fill-rule.filter.flex.flex-basis.flex-direction.flex-flow.flex-grow.flex-shrink.flex-wrap.float.flood-color.flood-opacity.flow.font.font-display.font-family.font-feature-settings.font-kerning.font-language-override.font-optical-sizing.font-palette.font-size.font-size-adjust.font-smooth.font-smoothing.font-stretch.font-style.font-synthesis.font-synthesis-position.font-synthesis-small-caps.font-synthesis-style.font-synthesis-weight.font-variant.font-variant-alternates.font-variant-caps.font-variant-east-asian.font-variant-emoji.font-variant-ligatures.font-variant-numeric.font-variant-position.font-variation-settings.font-weight.forced-color-adjust.gap.glyph-orientation-horizontal.glyph-orientation-vertical.grid.grid-area.grid-auto-columns.grid-auto-flow.grid-auto-rows.grid-column.grid-column-end.grid-column-start.grid-gap.grid-row.grid-row-end.grid-row-start.grid-template.grid-template-areas.grid-template-columns.grid-template-rows.hanging-punctuation.height.hyphenate-character.hyphenate-limit-chars.hyphens.icon.image-orientation.image-rendering.image-resolution.ime-mode.initial-letter.initial-letter-align.inline-size.inset.inset-area.inset-block.inset-block-end.inset-block-start.inset-inline.inset-inline-end.inset-inline-start.isolation.justify-content.justify-items.justify-self.kerning.left.letter-spacing.lighting-color.line-break.line-height.line-height-step.list-style.list-style-image.list-style-position.list-style-type.margin.margin-block.margin-block-end.margin-block-start.margin-bottom.margin-inline.margin-inline-end.margin-inline-start.margin-left.margin-right.margin-top.margin-trim.marker.marker-end.marker-mid.marker-start.marks.mask.mask-border.mask-border-mode.mask-border-outset.mask-border-repeat.mask-border-slice.mask-border-source.mask-border-width.mask-clip.mask-composite.mask-image.mask-mode.mask-origin.mask-position.mask-repeat.mask-size.mask-type.masonry-auto-flow.math-depth.math-shift.math-style.max-block-size.max-height.max-inline-size.max-width.min-block-size.min-height.min-inline-size.min-width.mix-blend-mode.nav-down.nav-index.nav-left.nav-right.nav-up.none.normal.object-fit.object-position.offset.offset-anchor.offset-distance.offset-path.offset-position.offset-rotate.opacity.order.orphans.outline.outline-color.outline-offset.outline-style.outline-width.overflow.overflow-anchor.overflow-block.overflow-clip-margin.overflow-inline.overflow-wrap.overflow-x.overflow-y.overlay.overscroll-behavior.overscroll-behavior-block.overscroll-behavior-inline.overscroll-behavior-x.overscroll-behavior-y.padding.padding-block.padding-block-end.padding-block-start.padding-bottom.padding-inline.padding-inline-end.padding-inline-start.padding-left.padding-right.padding-top.page.page-break-after.page-break-before.page-break-inside.paint-order.pause.pause-after.pause-before.perspective.perspective-origin.place-content.place-items.place-self.pointer-events.position.position-anchor.position-visibility.print-color-adjust.quotes.r.resize.rest.rest-after.rest-before.right.rotate.row-gap.ruby-align.ruby-position.scale.scroll-behavior.scroll-margin.scroll-margin-block.scroll-margin-block-end.scroll-margin-block-start.scroll-margin-bottom.scroll-margin-inline.scroll-margin-inline-end.scroll-margin-inline-start.scroll-margin-left.scroll-margin-right.scroll-margin-top.scroll-padding.scroll-padding-block.scroll-padding-block-end.scroll-padding-block-start.scroll-padding-bottom.scroll-padding-inline.scroll-padding-inline-end.scroll-padding-inline-start.scroll-padding-left.scroll-padding-right.scroll-padding-top.scroll-snap-align.scroll-snap-stop.scroll-snap-type.scroll-timeline.scroll-timeline-axis.scroll-timeline-name.scrollbar-color.scrollbar-gutter.scrollbar-width.shape-image-threshold.shape-margin.shape-outside.shape-rendering.speak.speak-as.src.stop-color.stop-opacity.stroke.stroke-dasharray.stroke-dashoffset.stroke-linecap.stroke-linejoin.stroke-miterlimit.stroke-opacity.stroke-width.tab-size.table-layout.text-align.text-align-all.text-align-last.text-anchor.text-combine-upright.text-decoration.text-decoration-color.text-decoration-line.text-decoration-skip.text-decoration-skip-ink.text-decoration-style.text-decoration-thickness.text-emphasis.text-emphasis-color.text-emphasis-position.text-emphasis-style.text-indent.text-justify.text-orientation.text-overflow.text-rendering.text-shadow.text-size-adjust.text-transform.text-underline-offset.text-underline-position.text-wrap.text-wrap-mode.text-wrap-style.timeline-scope.top.touch-action.transform.transform-box.transform-origin.transform-style.transition.transition-behavior.transition-delay.transition-duration.transition-property.transition-timing-function.translate.unicode-bidi.user-modify.user-select.vector-effect.vertical-align.view-timeline.view-timeline-axis.view-timeline-inset.view-timeline-name.view-transition-name.visibility.voice-balance.voice-duration.voice-family.voice-pitch.voice-range.voice-rate.voice-stress.voice-volume.white-space.white-space-collapse.widows.width.will-change.word-break.word-spacing.word-wrap.writing-mode.x.y.z-index.zoom".split(".")).sort().reverse();
function css(hljs) {
	let regex$1 = hljs.regex, modes = MODES$3(hljs), VENDOR_PREFIX = { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ }, AT_MODIFIERS = "and or not only", AT_PROPERTY_RE = /@-?\w[\w]*(-\w+)*/, IDENT_RE$3 = "[a-zA-Z-][a-zA-Z0-9_-]*", STRINGS = [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE];
	return {
		name: "CSS",
		case_insensitive: !0,
		illegal: /[=|'\$]/,
		keywords: { keyframePosition: "from to" },
		classNameAliases: { keyframePosition: "selector-tag" },
		contains: [
			modes.BLOCK_COMMENT,
			VENDOR_PREFIX,
			modes.CSS_NUMBER_MODE,
			{
				className: "selector-id",
				begin: /#[A-Za-z0-9_-]+/,
				relevance: 0
			},
			{
				className: "selector-class",
				begin: "\\.[a-zA-Z-][a-zA-Z0-9_-]*",
				relevance: 0
			},
			modes.ATTRIBUTE_SELECTOR_MODE,
			{
				className: "selector-pseudo",
				variants: [{ begin: ":(" + PSEUDO_CLASSES$2.join("|") + ")" }, { begin: ":(:)?(" + PSEUDO_ELEMENTS$2.join("|") + ")" }]
			},
			modes.CSS_VARIABLE,
			{
				className: "attribute",
				begin: "\\b(" + ATTRIBUTES$2.join("|") + ")\\b"
			},
			{
				begin: /:/,
				end: /[;}{]/,
				contains: [
					modes.BLOCK_COMMENT,
					modes.HEXCOLOR,
					modes.IMPORTANT,
					modes.CSS_NUMBER_MODE,
					...STRINGS,
					{
						begin: /(url|data-uri)\(/,
						end: /\)/,
						relevance: 0,
						keywords: { built_in: "url data-uri" },
						contains: [...STRINGS, {
							className: "string",
							begin: /[^)]/,
							endsWithParent: !0,
							excludeEnd: !0
						}]
					},
					modes.FUNCTION_DISPATCH
				]
			},
			{
				begin: regex$1.lookahead(/@/),
				end: "[{;]",
				relevance: 0,
				illegal: /:/,
				contains: [{
					className: "keyword",
					begin: AT_PROPERTY_RE
				}, {
					begin: /\s/,
					endsWithParent: !0,
					excludeEnd: !0,
					relevance: 0,
					keywords: {
						$pattern: /[a-z-]+/,
						keyword: "and or not only",
						attribute: MEDIA_FEATURES$2.join(" ")
					},
					contains: [
						{
							begin: /[a-z-]+(?=:)/,
							className: "attribute"
						},
						...STRINGS,
						modes.CSS_NUMBER_MODE
					]
				}]
			},
			{
				className: "selector-tag",
				begin: "\\b(" + TAGS$2.join("|") + ")\\b"
			}
		]
	};
}
function diff(hljs) {
	let regex$1 = hljs.regex;
	return {
		name: "Diff",
		aliases: ["patch"],
		contains: [
			{
				className: "meta",
				relevance: 10,
				match: regex$1.either(/^@@ +-\d+,\d+ +\+\d+,\d+ +@@/, /^\*\*\* +\d+,\d+ +\*\*\*\*$/, /^--- +\d+,\d+ +----$/)
			},
			{
				className: "comment",
				variants: [{
					begin: regex$1.either(/Index: /, /^index/, /={3,}/, /^-{3}/, /^\*{3} /, /^\+{3}/, /^diff --git/),
					end: /$/
				}, { match: /^\*{15}$/ }]
			},
			{
				className: "addition",
				begin: /^\+/,
				end: /$/
			},
			{
				className: "deletion",
				begin: /^-/,
				end: /$/
			},
			{
				className: "addition",
				begin: /^!/,
				end: /$/
			}
		]
	};
}
function go(hljs) {
	let KEYWORDS$2 = {
		keyword: [
			"break",
			"case",
			"chan",
			"const",
			"continue",
			"default",
			"defer",
			"else",
			"fallthrough",
			"for",
			"func",
			"go",
			"goto",
			"if",
			"import",
			"interface",
			"map",
			"package",
			"range",
			"return",
			"select",
			"struct",
			"switch",
			"type",
			"var"
		],
		type: [
			"bool",
			"byte",
			"complex64",
			"complex128",
			"error",
			"float32",
			"float64",
			"int8",
			"int16",
			"int32",
			"int64",
			"string",
			"uint8",
			"uint16",
			"uint32",
			"uint64",
			"int",
			"uint",
			"uintptr",
			"rune"
		],
		literal: [
			"true",
			"false",
			"iota",
			"nil"
		],
		built_in: [
			"append",
			"cap",
			"close",
			"complex",
			"copy",
			"imag",
			"len",
			"make",
			"new",
			"panic",
			"print",
			"println",
			"real",
			"recover",
			"delete"
		]
	};
	return {
		name: "Go",
		aliases: ["golang"],
		keywords: KEYWORDS$2,
		illegal: "</",
		contains: [
			hljs.C_LINE_COMMENT_MODE,
			hljs.C_BLOCK_COMMENT_MODE,
			{
				className: "string",
				variants: [
					hljs.QUOTE_STRING_MODE,
					hljs.APOS_STRING_MODE,
					{
						begin: "`",
						end: "`"
					}
				]
			},
			{
				className: "number",
				variants: [
					{
						match: /-?\b0[xX]\.[a-fA-F0-9](_?[a-fA-F0-9])*[pP][+-]?\d(_?\d)*i?/,
						relevance: 0
					},
					{
						match: /-?\b0[xX](_?[a-fA-F0-9])+((\.([a-fA-F0-9](_?[a-fA-F0-9])*)?)?[pP][+-]?\d(_?\d)*)?i?/,
						relevance: 0
					},
					{
						match: /-?\b0[oO](_?[0-7])*i?/,
						relevance: 0
					},
					{
						match: /-?\.\d(_?\d)*([eE][+-]?\d(_?\d)*)?i?/,
						relevance: 0
					},
					{
						match: /-?\b\d(_?\d)*(\.(\d(_?\d)*)?)?([eE][+-]?\d(_?\d)*)?i?/,
						relevance: 0
					}
				]
			},
			{ begin: /:=/ },
			{
				className: "function",
				beginKeywords: "func",
				end: "\\s*(\\{|$)",
				excludeEnd: !0,
				contains: [hljs.TITLE_MODE, {
					className: "params",
					begin: /\(/,
					end: /\)/,
					endsParent: !0,
					keywords: KEYWORDS$2,
					illegal: /["']/
				}]
			}
		]
	};
}
function graphql(hljs) {
	let regex$1 = hljs.regex;
	return {
		name: "GraphQL",
		aliases: ["gql"],
		case_insensitive: !0,
		disableAutodetect: !1,
		keywords: {
			keyword: [
				"query",
				"mutation",
				"subscription",
				"type",
				"input",
				"schema",
				"directive",
				"interface",
				"union",
				"scalar",
				"fragment",
				"enum",
				"on"
			],
			literal: [
				"true",
				"false",
				"null"
			]
		},
		contains: [
			hljs.HASH_COMMENT_MODE,
			hljs.QUOTE_STRING_MODE,
			hljs.NUMBER_MODE,
			{
				scope: "punctuation",
				match: /[.]{3}/,
				relevance: 0
			},
			{
				scope: "punctuation",
				begin: /[\!\(\)\:\=\[\]\{\|\}]{1}/,
				relevance: 0
			},
			{
				scope: "variable",
				begin: /\$/,
				end: /\W/,
				excludeEnd: !0,
				relevance: 0
			},
			{
				scope: "meta",
				match: /@\w+/,
				excludeEnd: !0
			},
			{
				scope: "symbol",
				begin: regex$1.concat(/[_A-Za-z][_0-9A-Za-z]*/, regex$1.lookahead(/\s*:/)),
				relevance: 0
			}
		],
		illegal: [/[;<']/, /BEGIN/]
	};
}
function ini(hljs) {
	let regex$1 = hljs.regex, NUMBERS = {
		className: "number",
		relevance: 0,
		variants: [{ begin: /([+-]+)?[\d]+_[\d_]+/ }, { begin: hljs.NUMBER_RE }]
	}, COMMENTS = hljs.COMMENT();
	COMMENTS.variants = [{
		begin: /;/,
		end: /$/
	}, {
		begin: /#/,
		end: /$/
	}];
	let VARIABLES = {
		className: "variable",
		variants: [{ begin: /\$[\w\d"][\w\d_]*/ }, { begin: /\$\{(.*?)\}/ }]
	}, LITERALS$2 = {
		className: "literal",
		begin: /\bon|off|true|false|yes|no\b/
	}, STRINGS = {
		className: "string",
		contains: [hljs.BACKSLASH_ESCAPE],
		variants: [
			{
				begin: "'''",
				end: "'''",
				relevance: 10
			},
			{
				begin: "\"\"\"",
				end: "\"\"\"",
				relevance: 10
			},
			{
				begin: "\"",
				end: "\""
			},
			{
				begin: "'",
				end: "'"
			}
		]
	}, ARRAY$1 = {
		begin: /\[/,
		end: /\]/,
		contains: [
			COMMENTS,
			LITERALS$2,
			VARIABLES,
			STRINGS,
			NUMBERS,
			"self"
		],
		relevance: 0
	}, ANY_KEY = regex$1.either(/[A-Za-z0-9_-]+/, /"(\\"|[^"])*"/, /'[^']*'/);
	return {
		name: "TOML, also INI",
		aliases: ["toml"],
		case_insensitive: !0,
		illegal: /\S/,
		contains: [
			COMMENTS,
			{
				className: "section",
				begin: /\[+/,
				end: /\]+/
			},
			{
				begin: regex$1.concat(ANY_KEY, "(\\s*\\.\\s*", ANY_KEY, ")*", regex$1.lookahead(/\s*=\s*[^#\s]/)),
				className: "attr",
				starts: {
					end: /$/,
					contains: [
						COMMENTS,
						ARRAY$1,
						LITERALS$2,
						VARIABLES,
						STRINGS,
						NUMBERS
					]
				}
			}
		]
	};
}
var decimalDigits$1 = "[0-9](_*[0-9])*", frac$1 = `\\.(${decimalDigits$1})`, hexDigits$1 = "[0-9a-fA-F](_*[0-9a-fA-F])*", NUMERIC$1 = {
	className: "number",
	variants: [
		{ begin: `(\\b(${decimalDigits$1})((${frac$1})|\\.)?|(${frac$1}))[eE][+-]?(${decimalDigits$1})[fFdD]?\\b` },
		{ begin: `\\b(${decimalDigits$1})((${frac$1})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
		{ begin: `(${frac$1})[fFdD]?\\b` },
		{ begin: `\\b(${decimalDigits$1})[fFdD]\\b` },
		{ begin: `\\b0[xX]((${hexDigits$1})\\.?|(${hexDigits$1})?\\.(${hexDigits$1}))[pP][+-]?(${decimalDigits$1})[fFdD]?\\b` },
		{ begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
		{ begin: `\\b0[xX](${hexDigits$1})[lL]?\\b` },
		{ begin: "\\b0(_*[0-7])*[lL]?\\b" },
		{ begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
	],
	relevance: 0
};
function recurRegex(re$1, substitution, depth) {
	return depth === -1 ? "" : re$1.replace(substitution, (_) => recurRegex(re$1, substitution, depth - 1));
}
function java(hljs) {
	let regex$1 = hljs.regex, JAVA_IDENT_RE = "[Ã€-Ê¸a-zA-Z_$][Ã€-Ê¸a-zA-Z_$0-9]*", GENERIC_IDENT_RE = JAVA_IDENT_RE + recurRegex("(?:<" + JAVA_IDENT_RE + "~~~(?:\\s*,\\s*[Ã€-Ê¸a-zA-Z_$][Ã€-Ê¸a-zA-Z_$0-9]*~~~)*>)?", /~~~/g, 2), KEYWORDS$2 = {
		keyword: /* @__PURE__ */ "synchronized.abstract.private.var.static.if.const .for.while.strictfp.finally.protected.import.native.final.void.enum.else.break.transient.catch.instanceof.volatile.case.assert.package.default.public.try.switch.continue.throws.protected.public.private.module.requires.exports.do.sealed.yield.permits.goto.when".split("."),
		literal: [
			"false",
			"true",
			"null"
		],
		type: [
			"char",
			"boolean",
			"long",
			"float",
			"int",
			"byte",
			"short",
			"double"
		],
		built_in: ["super", "this"]
	}, ANNOTATION = {
		className: "meta",
		begin: "@" + JAVA_IDENT_RE,
		contains: [{
			begin: /\(/,
			end: /\)/,
			contains: ["self"]
		}]
	}, PARAMS = {
		className: "params",
		begin: /\(/,
		end: /\)/,
		keywords: KEYWORDS$2,
		relevance: 0,
		contains: [hljs.C_BLOCK_COMMENT_MODE],
		endsParent: !0
	};
	return {
		name: "Java",
		aliases: ["jsp"],
		keywords: KEYWORDS$2,
		illegal: /<\/|#/,
		contains: [
			hljs.COMMENT("/\\*\\*", "\\*/", {
				relevance: 0,
				contains: [{
					begin: /\w+@/,
					relevance: 0
				}, {
					className: "doctag",
					begin: "@[A-Za-z]+"
				}]
			}),
			{
				begin: /import java\.[a-z]+\./,
				keywords: "import",
				relevance: 2
			},
			hljs.C_LINE_COMMENT_MODE,
			hljs.C_BLOCK_COMMENT_MODE,
			{
				begin: /"""/,
				end: /"""/,
				className: "string",
				contains: [hljs.BACKSLASH_ESCAPE]
			},
			hljs.APOS_STRING_MODE,
			hljs.QUOTE_STRING_MODE,
			{
				match: [
					/\b(?:class|interface|enum|extends|implements|new)/,
					/\s+/,
					JAVA_IDENT_RE
				],
				className: {
					1: "keyword",
					3: "title.class"
				}
			},
			{
				match: /non-sealed/,
				scope: "keyword"
			},
			{
				begin: [
					regex$1.concat(/(?!else)/, JAVA_IDENT_RE),
					/\s+/,
					JAVA_IDENT_RE,
					/\s+/,
					/=(?!=)/
				],
				className: {
					1: "type",
					3: "variable",
					5: "operator"
				}
			},
			{
				begin: [
					/record/,
					/\s+/,
					JAVA_IDENT_RE
				],
				className: {
					1: "keyword",
					3: "title.class"
				},
				contains: [
					PARAMS,
					hljs.C_LINE_COMMENT_MODE,
					hljs.C_BLOCK_COMMENT_MODE
				]
			},
			{
				beginKeywords: "new throw return else",
				relevance: 0
			},
			{
				begin: [
					"(?:" + GENERIC_IDENT_RE + "\\s+)",
					hljs.UNDERSCORE_IDENT_RE,
					/\s*(?=\()/
				],
				className: { 2: "title.function" },
				keywords: KEYWORDS$2,
				contains: [
					{
						className: "params",
						begin: /\(/,
						end: /\)/,
						keywords: KEYWORDS$2,
						relevance: 0,
						contains: [
							ANNOTATION,
							hljs.APOS_STRING_MODE,
							hljs.QUOTE_STRING_MODE,
							NUMERIC$1,
							hljs.C_BLOCK_COMMENT_MODE
						]
					},
					hljs.C_LINE_COMMENT_MODE,
					hljs.C_BLOCK_COMMENT_MODE
				]
			},
			NUMERIC$1,
			ANNOTATION
		]
	};
}
var IDENT_RE$2 = "[A-Za-z$_][0-9A-Za-z$_]*", KEYWORDS$1 = /* @__PURE__ */ "as.in.of.if.for.while.finally.var.new.function.do.return.void.else.break.catch.instanceof.with.throw.case.default.try.switch.continue.typeof.delete.let.yield.const.class.debugger.async.await.static.import.from.export.extends.using".split("."), LITERALS$1 = [
	"true",
	"false",
	"null",
	"undefined",
	"NaN",
	"Infinity"
], TYPES$1 = /* @__PURE__ */ "Object.Function.Boolean.Symbol.Math.Date.Number.BigInt.String.RegExp.Array.Float32Array.Float64Array.Int8Array.Uint8Array.Uint8ClampedArray.Int16Array.Int32Array.Uint16Array.Uint32Array.BigInt64Array.BigUint64Array.Set.Map.WeakSet.WeakMap.ArrayBuffer.SharedArrayBuffer.Atomics.DataView.JSON.Promise.Generator.GeneratorFunction.AsyncFunction.Reflect.Proxy.Intl.WebAssembly".split("."), ERROR_TYPES$1 = [
	"Error",
	"EvalError",
	"InternalError",
	"RangeError",
	"ReferenceError",
	"SyntaxError",
	"TypeError",
	"URIError"
], BUILT_IN_GLOBALS$1 = [
	"setInterval",
	"setTimeout",
	"clearInterval",
	"clearTimeout",
	"require",
	"exports",
	"eval",
	"isFinite",
	"isNaN",
	"parseFloat",
	"parseInt",
	"decodeURI",
	"decodeURIComponent",
	"encodeURI",
	"encodeURIComponent",
	"escape",
	"unescape"
], BUILT_IN_VARIABLES$1 = [
	"arguments",
	"this",
	"super",
	"console",
	"window",
	"document",
	"localStorage",
	"sessionStorage",
	"module",
	"global"
], BUILT_INS$1 = [].concat(BUILT_IN_GLOBALS$1, TYPES$1, ERROR_TYPES$1);
function javascript(hljs) {
	let regex$1 = hljs.regex, hasClosingTag = (match, { after }) => {
		let tag = "</" + match[0].slice(1);
		return match.input.indexOf(tag, after) !== -1;
	}, IDENT_RE$1$1 = IDENT_RE$2, FRAGMENT = {
		begin: "<>",
		end: "</>"
	}, XML_SELF_CLOSING = /<[A-Za-z0-9\\._:-]+\s*\/>/, XML_TAG = {
		begin: /<[A-Za-z0-9\\._:-]+/,
		end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
		isTrulyOpeningTag: (match, response) => {
			let afterMatchIndex = match[0].length + match.index, nextChar = match.input[afterMatchIndex];
			if (nextChar === "<" || nextChar === ",") {
				response.ignoreMatch();
				return;
			}
			nextChar === ">" && (hasClosingTag(match, { after: afterMatchIndex }) || response.ignoreMatch());
			let m, afterMatch = match.input.substring(afterMatchIndex);
			if (m = afterMatch.match(/^\s*=/)) {
				response.ignoreMatch();
				return;
			}
			if ((m = afterMatch.match(/^\s+extends\s+/)) && m.index === 0) {
				response.ignoreMatch();
				return;
			}
		}
	}, KEYWORDS$1$1 = {
		$pattern: IDENT_RE$2,
		keyword: KEYWORDS$1,
		literal: LITERALS$1,
		built_in: BUILT_INS$1,
		"variable.language": BUILT_IN_VARIABLES$1
	}, decimalDigits$2 = "[0-9](_?[0-9])*", frac$2 = `\\.(${decimalDigits$2})`, decimalInteger = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", NUMBER = {
		className: "number",
		variants: [
			{ begin: `(\\b(${decimalInteger})((${frac$2})|\\.)?|(${frac$2}))[eE][+-]?(${decimalDigits$2})\\b` },
			{ begin: `\\b(${decimalInteger})\\b((${frac$2})\\b|\\.)?|(${frac$2})\\b` },
			{ begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
			{ begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
			{ begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
			{ begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
			{ begin: "\\b0[0-7]+n?\\b" }
		],
		relevance: 0
	}, SUBST = {
		className: "subst",
		begin: "\\$\\{",
		end: "\\}",
		keywords: KEYWORDS$1$1,
		contains: []
	}, HTML_TEMPLATE = {
		begin: ".?html`",
		end: "",
		starts: {
			end: "`",
			returnEnd: !1,
			contains: [hljs.BACKSLASH_ESCAPE, SUBST],
			subLanguage: "xml"
		}
	}, CSS_TEMPLATE = {
		begin: ".?css`",
		end: "",
		starts: {
			end: "`",
			returnEnd: !1,
			contains: [hljs.BACKSLASH_ESCAPE, SUBST],
			subLanguage: "css"
		}
	}, GRAPHQL_TEMPLATE = {
		begin: ".?gql`",
		end: "",
		starts: {
			end: "`",
			returnEnd: !1,
			contains: [hljs.BACKSLASH_ESCAPE, SUBST],
			subLanguage: "graphql"
		}
	}, TEMPLATE_STRING = {
		className: "string",
		begin: "`",
		end: "`",
		contains: [hljs.BACKSLASH_ESCAPE, SUBST]
	}, COMMENT$1 = {
		className: "comment",
		variants: [
			hljs.COMMENT(/\/\*\*(?!\/)/, "\\*/", {
				relevance: 0,
				contains: [{
					begin: "(?=@[A-Za-z]+)",
					relevance: 0,
					contains: [
						{
							className: "doctag",
							begin: "@[A-Za-z]+"
						},
						{
							className: "type",
							begin: "\\{",
							end: "\\}",
							excludeEnd: !0,
							excludeBegin: !0,
							relevance: 0
						},
						{
							className: "variable",
							begin: IDENT_RE$1$1 + "(?=\\s*(-)|$)",
							endsParent: !0,
							relevance: 0
						},
						{
							begin: /(?=[^\n])\s/,
							relevance: 0
						}
					]
				}]
			}),
			hljs.C_BLOCK_COMMENT_MODE,
			hljs.C_LINE_COMMENT_MODE
		]
	}, SUBST_INTERNALS = [
		hljs.APOS_STRING_MODE,
		hljs.QUOTE_STRING_MODE,
		HTML_TEMPLATE,
		CSS_TEMPLATE,
		GRAPHQL_TEMPLATE,
		TEMPLATE_STRING,
		{ match: /\$\d+/ },
		NUMBER
	];
	SUBST.contains = SUBST_INTERNALS.concat({
		begin: /\{/,
		end: /\}/,
		keywords: KEYWORDS$1$1,
		contains: ["self"].concat(SUBST_INTERNALS)
	});
	let SUBST_AND_COMMENTS = [].concat(COMMENT$1, SUBST.contains), PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([{
		begin: /(\s*)\(/,
		end: /\)/,
		keywords: KEYWORDS$1$1,
		contains: ["self"].concat(SUBST_AND_COMMENTS)
	}]), PARAMS = {
		className: "params",
		begin: /(\s*)\(/,
		end: /\)/,
		excludeBegin: !0,
		excludeEnd: !0,
		keywords: KEYWORDS$1$1,
		contains: PARAMS_CONTAINS
	}, CLASS_OR_EXTENDS = { variants: [{
		match: [
			/class/,
			/\s+/,
			IDENT_RE$1$1,
			/\s+/,
			/extends/,
			/\s+/,
			regex$1.concat(IDENT_RE$1$1, "(", regex$1.concat(/\./, IDENT_RE$1$1), ")*")
		],
		scope: {
			1: "keyword",
			3: "title.class",
			5: "keyword",
			7: "title.class.inherited"
		}
	}, {
		match: [
			/class/,
			/\s+/,
			IDENT_RE$1$1
		],
		scope: {
			1: "keyword",
			3: "title.class"
		}
	}] }, CLASS_REFERENCE = {
		relevance: 0,
		match: regex$1.either(/\bJSON/, /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/, /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/, /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/),
		className: "title.class",
		keywords: { _: [...TYPES$1, ...ERROR_TYPES$1] }
	}, USE_STRICT = {
		label: "use_strict",
		className: "meta",
		relevance: 10,
		begin: /^\s*['"]use (strict|asm)['"]/
	}, FUNCTION_DEFINITION = {
		variants: [{ match: [
			/function/,
			/\s+/,
			IDENT_RE$1$1,
			/(?=\s*\()/
		] }, { match: [/function/, /\s*(?=\()/] }],
		className: {
			1: "keyword",
			3: "title.function"
		},
		label: "func.def",
		contains: [PARAMS],
		illegal: /%/
	}, UPPER_CASE_CONSTANT = {
		relevance: 0,
		match: /\b[A-Z][A-Z_0-9]+\b/,
		className: "variable.constant"
	};
	function noneOf(list$3) {
		return regex$1.concat("(?!", list$3.join("|"), ")");
	}
	let FUNCTION_CALL = {
		match: regex$1.concat(/\b/, noneOf([
			...BUILT_IN_GLOBALS$1,
			"super",
			"import"
		].map((x) => `${x}\\s*\\(`)), IDENT_RE$1$1, regex$1.lookahead(/\s*\(/)),
		className: "title.function",
		relevance: 0
	}, PROPERTY_ACCESS = {
		begin: regex$1.concat(/\./, regex$1.lookahead(regex$1.concat(IDENT_RE$1$1, /(?![0-9A-Za-z$_(])/))),
		end: IDENT_RE$1$1,
		excludeBegin: !0,
		keywords: "prototype",
		className: "property",
		relevance: 0
	}, GETTER_OR_SETTER = {
		match: [
			/get|set/,
			/\s+/,
			IDENT_RE$1$1,
			/(?=\()/
		],
		className: {
			1: "keyword",
			3: "title.function"
		},
		contains: [{ begin: /\(\)/ }, PARAMS]
	}, FUNC_LEAD_IN_RE = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + hljs.UNDERSCORE_IDENT_RE + ")\\s*=>", FUNCTION_VARIABLE = {
		match: [
			/const|var|let/,
			/\s+/,
			IDENT_RE$1$1,
			/\s*/,
			/=\s*/,
			/(async\s*)?/,
			regex$1.lookahead(FUNC_LEAD_IN_RE)
		],
		keywords: "async",
		className: {
			1: "keyword",
			3: "title.function"
		},
		contains: [PARAMS]
	};
	return {
		name: "JavaScript",
		aliases: [
			"js",
			"jsx",
			"mjs",
			"cjs"
		],
		keywords: KEYWORDS$1$1,
		exports: {
			PARAMS_CONTAINS,
			CLASS_REFERENCE
		},
		illegal: /#(?![$_A-z])/,
		contains: [
			hljs.SHEBANG({
				label: "shebang",
				binary: "node",
				relevance: 5
			}),
			USE_STRICT,
			hljs.APOS_STRING_MODE,
			hljs.QUOTE_STRING_MODE,
			HTML_TEMPLATE,
			CSS_TEMPLATE,
			GRAPHQL_TEMPLATE,
			TEMPLATE_STRING,
			COMMENT$1,
			{ match: /\$\d+/ },
			NUMBER,
			CLASS_REFERENCE,
			{
				scope: "attr",
				match: IDENT_RE$1$1 + regex$1.lookahead(":"),
				relevance: 0
			},
			FUNCTION_VARIABLE,
			{
				begin: "(" + hljs.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
				keywords: "return throw case",
				relevance: 0,
				contains: [
					COMMENT$1,
					hljs.REGEXP_MODE,
					{
						className: "function",
						begin: FUNC_LEAD_IN_RE,
						returnBegin: !0,
						end: "\\s*=>",
						contains: [{
							className: "params",
							variants: [
								{
									begin: hljs.UNDERSCORE_IDENT_RE,
									relevance: 0
								},
								{
									className: null,
									begin: /\(\s*\)/,
									skip: !0
								},
								{
									begin: /(\s*)\(/,
									end: /\)/,
									excludeBegin: !0,
									excludeEnd: !0,
									keywords: KEYWORDS$1$1,
									contains: PARAMS_CONTAINS
								}
							]
						}]
					},
					{
						begin: /,/,
						relevance: 0
					},
					{
						match: /\s+/,
						relevance: 0
					},
					{
						variants: [
							{
								begin: FRAGMENT.begin,
								end: FRAGMENT.end
							},
							{ match: XML_SELF_CLOSING },
							{
								begin: XML_TAG.begin,
								"on:begin": XML_TAG.isTrulyOpeningTag,
								end: XML_TAG.end
							}
						],
						subLanguage: "xml",
						contains: [{
							begin: XML_TAG.begin,
							end: XML_TAG.end,
							skip: !0,
							contains: ["self"]
						}]
					}
				]
			},
			FUNCTION_DEFINITION,
			{ beginKeywords: "while if switch catch for" },
			{
				begin: "\\b(?!function)" + hljs.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
				returnBegin: !0,
				label: "func.def",
				contains: [PARAMS, hljs.inherit(hljs.TITLE_MODE, {
					begin: IDENT_RE$1$1,
					className: "title.function"
				})]
			},
			{
				match: /\.\.\./,
				relevance: 0
			},
			PROPERTY_ACCESS,
			{
				match: "\\$" + IDENT_RE$1$1,
				relevance: 0
			},
			{
				match: [/\bconstructor(?=\s*\()/],
				className: { 1: "title.function" },
				contains: [PARAMS]
			},
			FUNCTION_CALL,
			UPPER_CASE_CONSTANT,
			CLASS_OR_EXTENDS,
			GETTER_OR_SETTER,
			{ match: /\$[(.]/ }
		]
	};
}
function json(hljs) {
	let ATTRIBUTE = {
		className: "attr",
		begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/,
		relevance: 1.01
	}, PUNCTUATION = {
		match: /[{}[\],:]/,
		className: "punctuation",
		relevance: 0
	}, LITERALS$2 = [
		"true",
		"false",
		"null"
	], LITERALS_MODE = {
		scope: "literal",
		beginKeywords: LITERALS$2.join(" ")
	};
	return {
		name: "JSON",
		aliases: ["jsonc"],
		keywords: { literal: LITERALS$2 },
		contains: [
			ATTRIBUTE,
			PUNCTUATION,
			hljs.QUOTE_STRING_MODE,
			LITERALS_MODE,
			hljs.C_NUMBER_MODE,
			hljs.C_LINE_COMMENT_MODE,
			hljs.C_BLOCK_COMMENT_MODE
		],
		illegal: "\\S"
	};
}
var decimalDigits = "[0-9](_*[0-9])*", frac = `\\.(${decimalDigits})`, hexDigits = "[0-9a-fA-F](_*[0-9a-fA-F])*", NUMERIC = {
	className: "number",
	variants: [
		{ begin: `(\\b(${decimalDigits})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})[fFdD]?\\b` },
		{ begin: `\\b(${decimalDigits})((${frac})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
		{ begin: `(${frac})[fFdD]?\\b` },
		{ begin: `\\b(${decimalDigits})[fFdD]\\b` },
		{ begin: `\\b0[xX]((${hexDigits})\\.?|(${hexDigits})?\\.(${hexDigits}))[pP][+-]?(${decimalDigits})[fFdD]?\\b` },
		{ begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
		{ begin: `\\b0[xX](${hexDigits})[lL]?\\b` },
		{ begin: "\\b0(_*[0-7])*[lL]?\\b" },
		{ begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
	],
	relevance: 0
};
function kotlin(hljs) {
	let KEYWORDS$2 = {
		keyword: "abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual",
		built_in: "Byte Short Char Int Long Boolean Float Double Void Unit Nothing",
		literal: "true false null"
	}, KEYWORDS_WITH_LABEL = {
		className: "keyword",
		begin: /\b(break|continue|return|this)\b/,
		starts: { contains: [{
			className: "symbol",
			begin: /@\w+/
		}] }
	}, LABEL = {
		className: "symbol",
		begin: hljs.UNDERSCORE_IDENT_RE + "@"
	}, SUBST = {
		className: "subst",
		begin: /\$\{/,
		end: /\}/,
		contains: [hljs.C_NUMBER_MODE]
	}, VARIABLE = {
		className: "variable",
		begin: "\\$" + hljs.UNDERSCORE_IDENT_RE
	}, STRING = {
		className: "string",
		variants: [
			{
				begin: "\"\"\"",
				end: "\"\"\"(?=[^\"])",
				contains: [VARIABLE, SUBST]
			},
			{
				begin: "'",
				end: "'",
				illegal: /\n/,
				contains: [hljs.BACKSLASH_ESCAPE]
			},
			{
				begin: "\"",
				end: "\"",
				illegal: /\n/,
				contains: [
					hljs.BACKSLASH_ESCAPE,
					VARIABLE,
					SUBST
				]
			}
		]
	};
	SUBST.contains.push(STRING);
	let ANNOTATION_USE_SITE = {
		className: "meta",
		begin: "@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*" + hljs.UNDERSCORE_IDENT_RE + ")?"
	}, ANNOTATION = {
		className: "meta",
		begin: "@" + hljs.UNDERSCORE_IDENT_RE,
		contains: [{
			begin: /\(/,
			end: /\)/,
			contains: [hljs.inherit(STRING, { className: "string" }), "self"]
		}]
	}, KOTLIN_NUMBER_MODE = NUMERIC, KOTLIN_NESTED_COMMENT = hljs.COMMENT("/\\*", "\\*/", { contains: [hljs.C_BLOCK_COMMENT_MODE] }), KOTLIN_PAREN_TYPE = { variants: [{
		className: "type",
		begin: hljs.UNDERSCORE_IDENT_RE
	}, {
		begin: /\(/,
		end: /\)/,
		contains: []
	}] }, KOTLIN_PAREN_TYPE2 = KOTLIN_PAREN_TYPE;
	return KOTLIN_PAREN_TYPE2.variants[1].contains = [KOTLIN_PAREN_TYPE], KOTLIN_PAREN_TYPE.variants[1].contains = [KOTLIN_PAREN_TYPE2], {
		name: "Kotlin",
		aliases: ["kt", "kts"],
		keywords: KEYWORDS$2,
		contains: [
			hljs.COMMENT("/\\*\\*", "\\*/", {
				relevance: 0,
				contains: [{
					className: "doctag",
					begin: "@[A-Za-z]+"
				}]
			}),
			hljs.C_LINE_COMMENT_MODE,
			KOTLIN_NESTED_COMMENT,
			KEYWORDS_WITH_LABEL,
			LABEL,
			ANNOTATION_USE_SITE,
			ANNOTATION,
			{
				className: "function",
				beginKeywords: "fun",
				end: "[(]|$",
				returnBegin: !0,
				excludeEnd: !0,
				keywords: KEYWORDS$2,
				relevance: 5,
				contains: [
					{
						begin: hljs.UNDERSCORE_IDENT_RE + "\\s*\\(",
						returnBegin: !0,
						relevance: 0,
						contains: [hljs.UNDERSCORE_TITLE_MODE]
					},
					{
						className: "type",
						begin: /</,
						end: />/,
						keywords: "reified",
						relevance: 0
					},
					{
						className: "params",
						begin: /\(/,
						end: /\)/,
						endsParent: !0,
						keywords: KEYWORDS$2,
						relevance: 0,
						contains: [
							{
								begin: /:/,
								end: /[=,\/]/,
								endsWithParent: !0,
								contains: [
									KOTLIN_PAREN_TYPE,
									hljs.C_LINE_COMMENT_MODE,
									KOTLIN_NESTED_COMMENT
								],
								relevance: 0
							},
							hljs.C_LINE_COMMENT_MODE,
							KOTLIN_NESTED_COMMENT,
							ANNOTATION_USE_SITE,
							ANNOTATION,
							STRING,
							hljs.C_NUMBER_MODE
						]
					},
					KOTLIN_NESTED_COMMENT
				]
			},
			{
				begin: [
					/class|interface|trait/,
					/\s+/,
					hljs.UNDERSCORE_IDENT_RE
				],
				beginScope: { 3: "title.class" },
				keywords: "class interface trait",
				end: /[:\{(]|$/,
				excludeEnd: !0,
				illegal: "extends implements",
				contains: [
					{ beginKeywords: "public protected internal private constructor" },
					hljs.UNDERSCORE_TITLE_MODE,
					{
						className: "type",
						begin: /</,
						end: />/,
						excludeBegin: !0,
						excludeEnd: !0,
						relevance: 0
					},
					{
						className: "type",
						begin: /[,:]\s*/,
						end: /[<\(,){\s]|$/,
						excludeBegin: !0,
						returnEnd: !0
					},
					ANNOTATION_USE_SITE,
					ANNOTATION
				]
			},
			STRING,
			{
				className: "meta",
				begin: "^#!/usr/bin/env",
				end: "$",
				illegal: "\n"
			},
			KOTLIN_NUMBER_MODE
		]
	};
}
var MODES$2 = (hljs) => ({
	IMPORTANT: {
		scope: "meta",
		begin: "!important"
	},
	BLOCK_COMMENT: hljs.C_BLOCK_COMMENT_MODE,
	HEXCOLOR: {
		scope: "number",
		begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
	},
	FUNCTION_DISPATCH: {
		className: "built_in",
		begin: /[\w-]+(?=\()/
	},
	ATTRIBUTE_SELECTOR_MODE: {
		scope: "selector-attr",
		begin: /\[/,
		end: /\]/,
		illegal: "$",
		contains: [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE]
	},
	CSS_NUMBER_MODE: {
		scope: "number",
		begin: hljs.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
		relevance: 0
	},
	CSS_VARIABLE: {
		className: "attr",
		begin: /--[A-Za-z_][A-Za-z0-9_-]*/
	}
}), HTML_TAGS$1 = /* @__PURE__ */ "a.abbr.address.article.aside.audio.b.blockquote.body.button.canvas.caption.cite.code.dd.del.details.dfn.div.dl.dt.em.fieldset.figcaption.figure.footer.form.h1.h2.h3.h4.h5.h6.header.hgroup.html.i.iframe.img.input.ins.kbd.label.legend.li.main.mark.menu.nav.object.ol.optgroup.option.p.picture.q.quote.samp.section.select.source.span.strong.summary.sup.table.tbody.td.textarea.tfoot.th.thead.time.tr.ul.var.video".split("."), SVG_TAGS$1 = /* @__PURE__ */ "defs.g.marker.mask.pattern.svg.switch.symbol.feBlend.feColorMatrix.feComponentTransfer.feComposite.feConvolveMatrix.feDiffuseLighting.feDisplacementMap.feFlood.feGaussianBlur.feImage.feMerge.feMorphology.feOffset.feSpecularLighting.feTile.feTurbulence.linearGradient.radialGradient.stop.circle.ellipse.image.line.path.polygon.polyline.rect.text.use.textPath.tspan.foreignObject.clipPath".split("."), TAGS$1 = [...HTML_TAGS$1, ...SVG_TAGS$1], MEDIA_FEATURES$1 = (/* @__PURE__ */ "any-hover.any-pointer.aspect-ratio.color.color-gamut.color-index.device-aspect-ratio.device-height.device-width.display-mode.forced-colors.grid.height.hover.inverted-colors.monochrome.orientation.overflow-block.overflow-inline.pointer.prefers-color-scheme.prefers-contrast.prefers-reduced-motion.prefers-reduced-transparency.resolution.scan.scripting.update.width.min-width.max-width.min-height.max-height".split(".")).sort().reverse(), PSEUDO_CLASSES$1 = (/* @__PURE__ */ "active.any-link.blank.checked.current.default.defined.dir.disabled.drop.empty.enabled.first.first-child.first-of-type.fullscreen.future.focus.focus-visible.focus-within.has.host.host-context.hover.indeterminate.in-range.invalid.is.lang.last-child.last-of-type.left.link.local-link.not.nth-child.nth-col.nth-last-child.nth-last-col.nth-last-of-type.nth-of-type.only-child.only-of-type.optional.out-of-range.past.placeholder-shown.read-only.read-write.required.right.root.scope.target.target-within.user-invalid.valid.visited.where".split(".")).sort().reverse(), PSEUDO_ELEMENTS$1 = [
	"after",
	"backdrop",
	"before",
	"cue",
	"cue-region",
	"first-letter",
	"first-line",
	"grammar-error",
	"marker",
	"part",
	"placeholder",
	"selection",
	"slotted",
	"spelling-error"
].sort().reverse(), ATTRIBUTES$1 = (/* @__PURE__ */ "accent-color.align-content.align-items.align-self.alignment-baseline.all.anchor-name.animation.animation-composition.animation-delay.animation-direction.animation-duration.animation-fill-mode.animation-iteration-count.animation-name.animation-play-state.animation-range.animation-range-end.animation-range-start.animation-timeline.animation-timing-function.appearance.aspect-ratio.backdrop-filter.backface-visibility.background.background-attachment.background-blend-mode.background-clip.background-color.background-image.background-origin.background-position.background-position-x.background-position-y.background-repeat.background-size.baseline-shift.block-size.border.border-block.border-block-color.border-block-end.border-block-end-color.border-block-end-style.border-block-end-width.border-block-start.border-block-start-color.border-block-start-style.border-block-start-width.border-block-style.border-block-width.border-bottom.border-bottom-color.border-bottom-left-radius.border-bottom-right-radius.border-bottom-style.border-bottom-width.border-collapse.border-color.border-end-end-radius.border-end-start-radius.border-image.border-image-outset.border-image-repeat.border-image-slice.border-image-source.border-image-width.border-inline.border-inline-color.border-inline-end.border-inline-end-color.border-inline-end-style.border-inline-end-width.border-inline-start.border-inline-start-color.border-inline-start-style.border-inline-start-width.border-inline-style.border-inline-width.border-left.border-left-color.border-left-style.border-left-width.border-radius.border-right.border-right-color.border-right-style.border-right-width.border-spacing.border-start-end-radius.border-start-start-radius.border-style.border-top.border-top-color.border-top-left-radius.border-top-right-radius.border-top-style.border-top-width.border-width.bottom.box-align.box-decoration-break.box-direction.box-flex.box-flex-group.box-lines.box-ordinal-group.box-orient.box-pack.box-shadow.box-sizing.break-after.break-before.break-inside.caption-side.caret-color.clear.clip.clip-path.clip-rule.color.color-interpolation.color-interpolation-filters.color-profile.color-rendering.color-scheme.column-count.column-fill.column-gap.column-rule.column-rule-color.column-rule-style.column-rule-width.column-span.column-width.columns.contain.contain-intrinsic-block-size.contain-intrinsic-height.contain-intrinsic-inline-size.contain-intrinsic-size.contain-intrinsic-width.container.container-name.container-type.content.content-visibility.counter-increment.counter-reset.counter-set.cue.cue-after.cue-before.cursor.cx.cy.direction.display.dominant-baseline.empty-cells.enable-background.field-sizing.fill.fill-opacity.fill-rule.filter.flex.flex-basis.flex-direction.flex-flow.flex-grow.flex-shrink.flex-wrap.float.flood-color.flood-opacity.flow.font.font-display.font-family.font-feature-settings.font-kerning.font-language-override.font-optical-sizing.font-palette.font-size.font-size-adjust.font-smooth.font-smoothing.font-stretch.font-style.font-synthesis.font-synthesis-position.font-synthesis-small-caps.font-synthesis-style.font-synthesis-weight.font-variant.font-variant-alternates.font-variant-caps.font-variant-east-asian.font-variant-emoji.font-variant-ligatures.font-variant-numeric.font-variant-position.font-variation-settings.font-weight.forced-color-adjust.gap.glyph-orientation-horizontal.glyph-orientation-vertical.grid.grid-area.grid-auto-columns.grid-auto-flow.grid-auto-rows.grid-column.grid-column-end.grid-column-start.grid-gap.grid-row.grid-row-end.grid-row-start.grid-template.grid-template-areas.grid-template-columns.grid-template-rows.hanging-punctuation.height.hyphenate-character.hyphenate-limit-chars.hyphens.icon.image-orientation.image-rendering.image-resolution.ime-mode.initial-letter.initial-letter-align.inline-size.inset.inset-area.inset-block.inset-block-end.inset-block-start.inset-inline.inset-inline-end.inset-inline-start.isolation.justify-content.justify-items.justify-self.kerning.left.letter-spacing.lighting-color.line-break.line-height.line-height-step.list-style.list-style-image.list-style-position.list-style-type.margin.margin-block.margin-block-end.margin-block-start.margin-bottom.margin-inline.margin-inline-end.margin-inline-start.margin-left.margin-right.margin-top.margin-trim.marker.marker-end.marker-mid.marker-start.marks.mask.mask-border.mask-border-mode.mask-border-outset.mask-border-repeat.mask-border-slice.mask-border-source.mask-border-width.mask-clip.mask-composite.mask-image.mask-mode.mask-origin.mask-position.mask-repeat.mask-size.mask-type.masonry-auto-flow.math-depth.math-shift.math-style.max-block-size.max-height.max-inline-size.max-width.min-block-size.min-height.min-inline-size.min-width.mix-blend-mode.nav-down.nav-index.nav-left.nav-right.nav-up.none.normal.object-fit.object-position.offset.offset-anchor.offset-distance.offset-path.offset-position.offset-rotate.opacity.order.orphans.outline.outline-color.outline-offset.outline-style.outline-width.overflow.overflow-anchor.overflow-block.overflow-clip-margin.overflow-inline.overflow-wrap.overflow-x.overflow-y.overlay.overscroll-behavior.overscroll-behavior-block.overscroll-behavior-inline.overscroll-behavior-x.overscroll-behavior-y.padding.padding-block.padding-block-end.padding-block-start.padding-bottom.padding-inline.padding-inline-end.padding-inline-start.padding-left.padding-right.padding-top.page.page-break-after.page-break-before.page-break-inside.paint-order.pause.pause-after.pause-before.perspective.perspective-origin.place-content.place-items.place-self.pointer-events.position.position-anchor.position-visibility.print-color-adjust.quotes.r.resize.rest.rest-after.rest-before.right.rotate.row-gap.ruby-align.ruby-position.scale.scroll-behavior.scroll-margin.scroll-margin-block.scroll-margin-block-end.scroll-margin-block-start.scroll-margin-bottom.scroll-margin-inline.scroll-margin-inline-end.scroll-margin-inline-start.scroll-margin-left.scroll-margin-right.scroll-margin-top.scroll-padding.scroll-padding-block.scroll-padding-block-end.scroll-padding-block-start.scroll-padding-bottom.scroll-padding-inline.scroll-padding-inline-end.scroll-padding-inline-start.scroll-padding-left.scroll-padding-right.scroll-padding-top.scroll-snap-align.scroll-snap-stop.scroll-snap-type.scroll-timeline.scroll-timeline-axis.scroll-timeline-name.scrollbar-color.scrollbar-gutter.scrollbar-width.shape-image-threshold.shape-margin.shape-outside.shape-rendering.speak.speak-as.src.stop-color.stop-opacity.stroke.stroke-dasharray.stroke-dashoffset.stroke-linecap.stroke-linejoin.stroke-miterlimit.stroke-opacity.stroke-width.tab-size.table-layout.text-align.text-align-all.text-align-last.text-anchor.text-combine-upright.text-decoration.text-decoration-color.text-decoration-line.text-decoration-skip.text-decoration-skip-ink.text-decoration-style.text-decoration-thickness.text-emphasis.text-emphasis-color.text-emphasis-position.text-emphasis-style.text-indent.text-justify.text-orientation.text-overflow.text-rendering.text-shadow.text-size-adjust.text-transform.text-underline-offset.text-underline-position.text-wrap.text-wrap-mode.text-wrap-style.timeline-scope.top.touch-action.transform.transform-box.transform-origin.transform-style.transition.transition-behavior.transition-delay.transition-duration.transition-property.transition-timing-function.translate.unicode-bidi.user-modify.user-select.vector-effect.vertical-align.view-timeline.view-timeline-axis.view-timeline-inset.view-timeline-name.view-transition-name.visibility.voice-balance.voice-duration.voice-family.voice-pitch.voice-range.voice-rate.voice-stress.voice-volume.white-space.white-space-collapse.widows.width.will-change.word-break.word-spacing.word-wrap.writing-mode.x.y.z-index.zoom".split(".")).sort().reverse(), PSEUDO_SELECTORS = PSEUDO_CLASSES$1.concat(PSEUDO_ELEMENTS$1).sort().reverse();
function less(hljs) {
	let modes = MODES$2(hljs), PSEUDO_SELECTORS$1 = PSEUDO_SELECTORS, AT_MODIFIERS = "and or not only", IDENT_RE$3 = "[\\w-]+", INTERP_IDENT_RE = "(" + IDENT_RE$3 + "|@\\{[\\w-]+\\})", RULES = [], VALUE_MODES = [], STRING_MODE = function(c$1) {
		return {
			className: "string",
			begin: "~?" + c$1 + ".*?" + c$1
		};
	}, IDENT_MODE = function(name$1, begin, relevance) {
		return {
			className: name$1,
			begin,
			relevance
		};
	}, AT_KEYWORDS = {
		$pattern: /[a-z-]+/,
		keyword: "and or not only",
		attribute: MEDIA_FEATURES$1.join(" ")
	}, PARENS_MODE = {
		begin: "\\(",
		end: "\\)",
		contains: VALUE_MODES,
		keywords: AT_KEYWORDS,
		relevance: 0
	};
	VALUE_MODES.push(hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE, STRING_MODE("'"), STRING_MODE("\""), modes.CSS_NUMBER_MODE, {
		begin: "(url|data-uri)\\(",
		starts: {
			className: "string",
			end: "[\\)\\n]",
			excludeEnd: !0
		}
	}, modes.HEXCOLOR, PARENS_MODE, IDENT_MODE("variable", "@@?" + IDENT_RE$3, 10), IDENT_MODE("variable", "@\\{" + IDENT_RE$3 + "\\}"), IDENT_MODE("built_in", "~?`[^`]*?`"), {
		className: "attribute",
		begin: IDENT_RE$3 + "\\s*:",
		end: ":",
		returnBegin: !0,
		excludeEnd: !0
	}, modes.IMPORTANT, { beginKeywords: "and not" }, modes.FUNCTION_DISPATCH);
	let VALUE_WITH_RULESETS = VALUE_MODES.concat({
		begin: /\{/,
		end: /\}/,
		contains: RULES
	}), MIXIN_GUARD_MODE = {
		beginKeywords: "when",
		endsWithParent: !0,
		contains: [{ beginKeywords: "and not" }].concat(VALUE_MODES)
	}, RULE_MODE = {
		begin: INTERP_IDENT_RE + "\\s*:",
		returnBegin: !0,
		end: /[;}]/,
		relevance: 0,
		contains: [
			{ begin: /-(webkit|moz|ms|o)-/ },
			modes.CSS_VARIABLE,
			{
				className: "attribute",
				begin: "\\b(" + ATTRIBUTES$1.join("|") + ")\\b",
				end: /(?=:)/,
				starts: {
					endsWithParent: !0,
					illegal: "[<=$]",
					relevance: 0,
					contains: VALUE_MODES
				}
			}
		]
	}, AT_RULE_MODE = {
		className: "keyword",
		begin: "@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b",
		starts: {
			end: "[;{}]",
			keywords: AT_KEYWORDS,
			returnEnd: !0,
			contains: VALUE_MODES,
			relevance: 0
		}
	}, VAR_RULE_MODE = {
		className: "variable",
		variants: [{
			begin: "@" + IDENT_RE$3 + "\\s*:",
			relevance: 15
		}, { begin: "@" + IDENT_RE$3 }],
		starts: {
			end: "[;}]",
			returnEnd: !0,
			contains: VALUE_WITH_RULESETS
		}
	}, SELECTOR_MODE = {
		variants: [{
			begin: "[\\.#:&\\[>]",
			end: "[;{}]"
		}, {
			begin: INTERP_IDENT_RE,
			end: /\{/
		}],
		returnBegin: !0,
		returnEnd: !0,
		illegal: "[<='$\"]",
		relevance: 0,
		contains: [
			hljs.C_LINE_COMMENT_MODE,
			hljs.C_BLOCK_COMMENT_MODE,
			MIXIN_GUARD_MODE,
			IDENT_MODE("keyword", "all\\b"),
			IDENT_MODE("variable", "@\\{" + IDENT_RE$3 + "\\}"),
			{
				begin: "\\b(" + TAGS$1.join("|") + ")\\b",
				className: "selector-tag"
			},
			modes.CSS_NUMBER_MODE,
			IDENT_MODE("selector-tag", INTERP_IDENT_RE, 0),
			IDENT_MODE("selector-id", "#" + INTERP_IDENT_RE),
			IDENT_MODE("selector-class", "\\." + INTERP_IDENT_RE, 0),
			IDENT_MODE("selector-tag", "&", 0),
			modes.ATTRIBUTE_SELECTOR_MODE,
			{
				className: "selector-pseudo",
				begin: ":(" + PSEUDO_CLASSES$1.join("|") + ")"
			},
			{
				className: "selector-pseudo",
				begin: ":(:)?(" + PSEUDO_ELEMENTS$1.join("|") + ")"
			},
			{
				begin: /\(/,
				end: /\)/,
				relevance: 0,
				contains: VALUE_WITH_RULESETS
			},
			{ begin: "!important" },
			modes.FUNCTION_DISPATCH
		]
	}, PSEUDO_SELECTOR_MODE = {
		begin: `[\\w-]+:(:)?(${PSEUDO_SELECTORS$1.join("|")})`,
		returnBegin: !0,
		contains: [SELECTOR_MODE]
	};
	return RULES.push(hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE, AT_RULE_MODE, VAR_RULE_MODE, PSEUDO_SELECTOR_MODE, RULE_MODE, SELECTOR_MODE, MIXIN_GUARD_MODE, modes.FUNCTION_DISPATCH), {
		name: "Less",
		case_insensitive: !0,
		illegal: "[=>'/<($\"]",
		contains: RULES
	};
}
function lua(hljs) {
	let OPENING_LONG_BRACKET = "\\[=*\\[", CLOSING_LONG_BRACKET = "\\]=*\\]", LONG_BRACKETS = {
		begin: OPENING_LONG_BRACKET,
		end: CLOSING_LONG_BRACKET,
		contains: ["self"]
	}, COMMENTS = [hljs.COMMENT("--(?!" + OPENING_LONG_BRACKET + ")", "$"), hljs.COMMENT("--" + OPENING_LONG_BRACKET, CLOSING_LONG_BRACKET, {
		contains: [LONG_BRACKETS],
		relevance: 10
	})];
	return {
		name: "Lua",
		aliases: ["pluto"],
		keywords: {
			$pattern: hljs.UNDERSCORE_IDENT_RE,
			literal: "true false nil",
			keyword: "and break do else elseif end for goto if in local not or repeat return then until while",
			built_in: "_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall arg self coroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove"
		},
		contains: COMMENTS.concat([
			{
				className: "function",
				beginKeywords: "function",
				end: "\\)",
				contains: [hljs.inherit(hljs.TITLE_MODE, { begin: "([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*" }), {
					className: "params",
					begin: "\\(",
					endsWithParent: !0,
					contains: COMMENTS
				}].concat(COMMENTS)
			},
			hljs.C_NUMBER_MODE,
			hljs.APOS_STRING_MODE,
			hljs.QUOTE_STRING_MODE,
			{
				className: "string",
				begin: OPENING_LONG_BRACKET,
				end: CLOSING_LONG_BRACKET,
				contains: [LONG_BRACKETS],
				relevance: 5
			}
		])
	};
}
function makefile(hljs) {
	let VARIABLE = {
		className: "variable",
		variants: [{
			begin: "\\$\\(" + hljs.UNDERSCORE_IDENT_RE + "\\)",
			contains: [hljs.BACKSLASH_ESCAPE]
		}, { begin: /\$[@%<?\^\+\*]/ }]
	}, QUOTE_STRING = {
		className: "string",
		begin: /"/,
		end: /"/,
		contains: [hljs.BACKSLASH_ESCAPE, VARIABLE]
	}, FUNC = {
		className: "variable",
		begin: /\$\([\w-]+\s/,
		end: /\)/,
		keywords: { built_in: "subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value" },
		contains: [VARIABLE, QUOTE_STRING]
	}, ASSIGNMENT = { begin: "^" + hljs.UNDERSCORE_IDENT_RE + "\\s*(?=[:+?]?=)" }, META = {
		className: "meta",
		begin: /^\.PHONY:/,
		end: /$/,
		keywords: {
			$pattern: /[\.\w]+/,
			keyword: ".PHONY"
		}
	}, TARGET = {
		className: "section",
		begin: /^[^\s]+:/,
		end: /$/,
		contains: [VARIABLE]
	};
	return {
		name: "Makefile",
		aliases: [
			"mk",
			"mak",
			"make"
		],
		keywords: {
			$pattern: /[\w-]+/,
			keyword: "define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath"
		},
		contains: [
			hljs.HASH_COMMENT_MODE,
			VARIABLE,
			QUOTE_STRING,
			FUNC,
			ASSIGNMENT,
			META,
			TARGET
		]
	};
}
function markdown(hljs) {
	let regex$1 = hljs.regex, INLINE_HTML = {
		begin: /<\/?[A-Za-z_]/,
		end: ">",
		subLanguage: "xml",
		relevance: 0
	}, HORIZONTAL_RULE = {
		begin: "^[-\\*]{3,}",
		end: "$"
	}, CODE = {
		className: "code",
		variants: [
			{ begin: "(`{3,})[^`](.|\\n)*?\\1`*[ ]*" },
			{ begin: "(~{3,})[^~](.|\\n)*?\\1~*[ ]*" },
			{
				begin: "```",
				end: "```+[ ]*$"
			},
			{
				begin: "~~~",
				end: "~~~+[ ]*$"
			},
			{ begin: "`.+?`" },
			{
				begin: "(?=^( {4}|\\t))",
				contains: [{
					begin: "^( {4}|\\t)",
					end: "(\\n)$"
				}],
				relevance: 0
			}
		]
	}, LIST = {
		className: "bullet",
		begin: "^[ 	]*([*+-]|(\\d+\\.))(?=\\s+)",
		end: "\\s+",
		excludeEnd: !0
	}, LINK_REFERENCE = {
		begin: /^\[[^\n]+\]:/,
		returnBegin: !0,
		contains: [{
			className: "symbol",
			begin: /\[/,
			end: /\]/,
			excludeBegin: !0,
			excludeEnd: !0
		}, {
			className: "link",
			begin: /:\s*/,
			end: /$/,
			excludeBegin: !0
		}]
	}, LINK = {
		variants: [
			{
				begin: /\[.+?\]\[.*?\]/,
				relevance: 0
			},
			{
				begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/,
				relevance: 2
			},
			{
				begin: regex$1.concat(/\[.+?\]\(/, /[A-Za-z][A-Za-z0-9+.-]*/, /:\/\/.*?\)/),
				relevance: 2
			},
			{
				begin: /\[.+?\]\([./?&#].*?\)/,
				relevance: 1
			},
			{
				begin: /\[.*?\]\(.*?\)/,
				relevance: 0
			}
		],
		returnBegin: !0,
		contains: [
			{ match: /\[(?=\])/ },
			{
				className: "string",
				relevance: 0,
				begin: "\\[",
				end: "\\]",
				excludeBegin: !0,
				returnEnd: !0
			},
			{
				className: "link",
				relevance: 0,
				begin: "\\]\\(",
				end: "\\)",
				excludeBegin: !0,
				excludeEnd: !0
			},
			{
				className: "symbol",
				relevance: 0,
				begin: "\\]\\[",
				end: "\\]",
				excludeBegin: !0,
				excludeEnd: !0
			}
		]
	}, BOLD = {
		className: "strong",
		contains: [],
		variants: [{
			begin: /_{2}(?!\s)/,
			end: /_{2}/
		}, {
			begin: /\*{2}(?!\s)/,
			end: /\*{2}/
		}]
	}, ITALIC = {
		className: "emphasis",
		contains: [],
		variants: [{
			begin: /\*(?![*\s])/,
			end: /\*/
		}, {
			begin: /_(?![_\s])/,
			end: /_/,
			relevance: 0
		}]
	}, BOLD_WITHOUT_ITALIC = hljs.inherit(BOLD, { contains: [] }), ITALIC_WITHOUT_BOLD = hljs.inherit(ITALIC, { contains: [] });
	BOLD.contains.push(ITALIC_WITHOUT_BOLD), ITALIC.contains.push(BOLD_WITHOUT_ITALIC);
	let CONTAINABLE = [INLINE_HTML, LINK];
	return [
		BOLD,
		ITALIC,
		BOLD_WITHOUT_ITALIC,
		ITALIC_WITHOUT_BOLD
	].forEach((m) => {
		m.contains = m.contains.concat(CONTAINABLE);
	}), CONTAINABLE = CONTAINABLE.concat(BOLD, ITALIC), {
		name: "Markdown",
		aliases: [
			"md",
			"mkdown",
			"mkd"
		],
		contains: [
			{
				className: "section",
				variants: [{
					begin: "^#{1,6}",
					end: "$",
					contains: CONTAINABLE
				}, {
					begin: "(?=^.+?\\n[=-]{2,}$)",
					contains: [{ begin: "^[=-]*$" }, {
						begin: "^",
						end: "\\n",
						contains: CONTAINABLE
					}]
				}]
			},
			INLINE_HTML,
			LIST,
			BOLD,
			ITALIC,
			{
				className: "quote",
				begin: "^>\\s+",
				contains: CONTAINABLE,
				end: "$"
			},
			CODE,
			HORIZONTAL_RULE,
			LINK,
			LINK_REFERENCE,
			{
				scope: "literal",
				match: /&([a-zA-Z0-9]+|#[0-9]{1,7}|#[Xx][0-9a-fA-F]{1,6});/
			}
		]
	};
}
function objectivec(hljs) {
	let API_CLASS = {
		className: "built_in",
		begin: "\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+"
	}, IDENTIFIER_RE = /[a-zA-Z@][a-zA-Z0-9_]*/, TYPES$2 = [
		"int",
		"float",
		"char",
		"unsigned",
		"signed",
		"short",
		"long",
		"double",
		"wchar_t",
		"unichar",
		"void",
		"bool",
		"BOOL",
		"id|0",
		"_Bool"
	], KWS = /* @__PURE__ */ "while.export.sizeof.typedef.const.struct.for.union.volatile.static.mutable.if.do.return.goto.enum.else.break.extern.asm.case.default.register.explicit.typename.switch.continue.inline.readonly.assign.readwrite.self.@synchronized.id.typeof.nonatomic.IBOutlet.IBAction.strong.weak.copy.in.out.inout.bycopy.byref.oneway.__strong.__weak.__block.__autoreleasing.@private.@protected.@public.@try.@property.@end.@throw.@catch.@finally.@autoreleasepool.@synthesize.@dynamic.@selector.@optional.@required.@encode.@package.@import.@defs.@compatibility_alias.__bridge.__bridge_transfer.__bridge_retained.__bridge_retain.__covariant.__contravariant.__kindof._Nonnull._Nullable._Null_unspecified.__FUNCTION__.__PRETTY_FUNCTION__.__attribute__.getter.setter.retain.unsafe_unretained.nonnull.nullable.null_unspecified.null_resettable.class.instancetype.NS_DESIGNATED_INITIALIZER.NS_UNAVAILABLE.NS_REQUIRES_SUPER.NS_RETURNS_INNER_POINTER.NS_INLINE.NS_AVAILABLE.NS_DEPRECATED.NS_ENUM.NS_OPTIONS.NS_SWIFT_UNAVAILABLE.NS_ASSUME_NONNULL_BEGIN.NS_ASSUME_NONNULL_END.NS_REFINED_FOR_SWIFT.NS_SWIFT_NAME.NS_SWIFT_NOTHROW.NS_DURING.NS_HANDLER.NS_ENDHANDLER.NS_VALUERETURN.NS_VOIDRETURN".split("."), LITERALS$2 = [
		"false",
		"true",
		"FALSE",
		"TRUE",
		"nil",
		"YES",
		"NO",
		"NULL"
	], BUILT_INS$2 = [
		"dispatch_once_t",
		"dispatch_queue_t",
		"dispatch_sync",
		"dispatch_async",
		"dispatch_once"
	], KEYWORDS$2 = {
		"variable.language": ["this", "super"],
		$pattern: IDENTIFIER_RE,
		keyword: KWS,
		literal: LITERALS$2,
		built_in: BUILT_INS$2,
		type: TYPES$2
	}, CLASS_KEYWORDS = {
		$pattern: IDENTIFIER_RE,
		keyword: [
			"@interface",
			"@class",
			"@protocol",
			"@implementation"
		]
	};
	return {
		name: "Objective-C",
		aliases: [
			"mm",
			"objc",
			"obj-c",
			"obj-c++",
			"objective-c++"
		],
		keywords: KEYWORDS$2,
		illegal: "</",
		contains: [
			API_CLASS,
			hljs.C_LINE_COMMENT_MODE,
			hljs.C_BLOCK_COMMENT_MODE,
			hljs.C_NUMBER_MODE,
			hljs.QUOTE_STRING_MODE,
			hljs.APOS_STRING_MODE,
			{
				className: "string",
				variants: [{
					begin: "@\"",
					end: "\"",
					illegal: "\\n",
					contains: [hljs.BACKSLASH_ESCAPE]
				}]
			},
			{
				className: "meta",
				begin: /#\s*[a-z]+\b/,
				end: /$/,
				keywords: { keyword: "if else elif endif define undef warning error line pragma ifdef ifndef include" },
				contains: [
					{
						begin: /\\\n/,
						relevance: 0
					},
					hljs.inherit(hljs.QUOTE_STRING_MODE, { className: "string" }),
					{
						className: "string",
						begin: /<.*?>/,
						end: /$/,
						illegal: "\\n"
					},
					hljs.C_LINE_COMMENT_MODE,
					hljs.C_BLOCK_COMMENT_MODE
				]
			},
			{
				className: "class",
				begin: "(" + CLASS_KEYWORDS.keyword.join("|") + ")\\b",
				end: /(\{|$)/,
				excludeEnd: !0,
				keywords: CLASS_KEYWORDS,
				contains: [hljs.UNDERSCORE_TITLE_MODE]
			},
			{
				begin: "\\." + hljs.UNDERSCORE_IDENT_RE,
				relevance: 0
			}
		]
	};
}
function perl(hljs) {
	let regex$1 = hljs.regex, KEYWORDS$2 = /* @__PURE__ */ "abs.accept.alarm.and.atan2.bind.binmode.bless.break.caller.chdir.chmod.chomp.chop.chown.chr.chroot.class.close.closedir.connect.continue.cos.crypt.dbmclose.dbmopen.defined.delete.die.do.dump.each.else.elsif.endgrent.endhostent.endnetent.endprotoent.endpwent.endservent.eof.eval.exec.exists.exit.exp.fcntl.field.fileno.flock.for.foreach.fork.format.formline.getc.getgrent.getgrgid.getgrnam.gethostbyaddr.gethostbyname.gethostent.getlogin.getnetbyaddr.getnetbyname.getnetent.getpeername.getpgrp.getpriority.getprotobyname.getprotobynumber.getprotoent.getpwent.getpwnam.getpwuid.getservbyname.getservbyport.getservent.getsockname.getsockopt.given.glob.gmtime.goto.grep.gt.hex.if.index.int.ioctl.join.keys.kill.last.lc.lcfirst.length.link.listen.local.localtime.log.lstat.lt.ma.map.method.mkdir.msgctl.msgget.msgrcv.msgsnd.my.ne.next.no.not.oct.open.opendir.or.ord.our.pack.package.pipe.pop.pos.print.printf.prototype.push.q|0.qq.quotemeta.qw.qx.rand.read.readdir.readline.readlink.readpipe.recv.redo.ref.rename.require.reset.return.reverse.rewinddir.rindex.rmdir.say.scalar.seek.seekdir.select.semctl.semget.semop.send.setgrent.sethostent.setnetent.setpgrp.setpriority.setprotoent.setpwent.setservent.setsockopt.shift.shmctl.shmget.shmread.shmwrite.shutdown.sin.sleep.socket.socketpair.sort.splice.split.sprintf.sqrt.srand.stat.state.study.sub.substr.symlink.syscall.sysopen.sysread.sysseek.system.syswrite.tell.telldir.tie.tied.time.times.tr.truncate.uc.ucfirst.umask.undef.unless.unlink.unpack.unshift.untie.until.use.utime.values.vec.wait.waitpid.wantarray.warn.when.while.write.x|0.xor.y|0".split("."), REGEX_MODIFIERS = /[dualxmsipngr]{0,12}/, PERL_KEYWORDS = {
		$pattern: /[\w.]+/,
		keyword: KEYWORDS$2.join(" ")
	}, SUBST = {
		className: "subst",
		begin: "[$@]\\{",
		end: "\\}",
		keywords: PERL_KEYWORDS
	}, METHOD = {
		begin: /->\{/,
		end: /\}/
	}, ATTR = {
		scope: "attr",
		match: /\s+:\s*\w+(\s*\(.*?\))?/
	}, VAR = {
		scope: "variable",
		variants: [
			{ begin: /\$\d/ },
			{ begin: regex$1.concat(/[$%@](?!")(\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/, "(?![A-Za-z])(?![@$%])") },
			{
				begin: /[$%@](?!")[^\s\w{=]|\$=/,
				relevance: 0
			}
		],
		contains: [ATTR]
	}, NUMBER = {
		className: "number",
		variants: [
			{ match: /0?\.[0-9][0-9_]+\b/ },
			{ match: /\bv?(0|[1-9][0-9_]*(\.[0-9_]+)?|[1-9][0-9_]*)\b/ },
			{ match: /\b0[0-7][0-7_]*\b/ },
			{ match: /\b0x[0-9a-fA-F][0-9a-fA-F_]*\b/ },
			{ match: /\b0b[0-1][0-1_]*\b/ }
		],
		relevance: 0
	}, STRING_CONTAINS = [
		hljs.BACKSLASH_ESCAPE,
		SUBST,
		VAR
	], REGEX_DELIMS = [
		/!/,
		/\//,
		/\|/,
		/\?/,
		/'/,
		/"/,
		/#/
	], PAIRED_DOUBLE_RE = (prefix, open, close = "\\1") => {
		let middle = close === "\\1" ? close : regex$1.concat(close, open);
		return regex$1.concat(regex$1.concat("(?:", prefix, ")"), open, /(?:\\.|[^\\\/])*?/, middle, /(?:\\.|[^\\\/])*?/, close, REGEX_MODIFIERS);
	}, PAIRED_RE = (prefix, open, close) => regex$1.concat(regex$1.concat("(?:", prefix, ")"), open, /(?:\\.|[^\\\/])*?/, close, REGEX_MODIFIERS), PERL_DEFAULT_CONTAINS = [
		VAR,
		hljs.HASH_COMMENT_MODE,
		hljs.COMMENT(/^=\w/, /=cut/, { endsWithParent: !0 }),
		METHOD,
		{
			className: "string",
			contains: STRING_CONTAINS,
			variants: [
				{
					begin: "q[qwxr]?\\s*\\(",
					end: "\\)",
					relevance: 5
				},
				{
					begin: "q[qwxr]?\\s*\\[",
					end: "\\]",
					relevance: 5
				},
				{
					begin: "q[qwxr]?\\s*\\{",
					end: "\\}",
					relevance: 5
				},
				{
					begin: "q[qwxr]?\\s*\\|",
					end: "\\|",
					relevance: 5
				},
				{
					begin: "q[qwxr]?\\s*<",
					end: ">",
					relevance: 5
				},
				{
					begin: "qw\\s+q",
					end: "q",
					relevance: 5
				},
				{
					begin: "'",
					end: "'",
					contains: [hljs.BACKSLASH_ESCAPE]
				},
				{
					begin: "\"",
					end: "\""
				},
				{
					begin: "`",
					end: "`",
					contains: [hljs.BACKSLASH_ESCAPE]
				},
				{
					begin: /\{\w+\}/,
					relevance: 0
				},
				{
					begin: "-?\\w+\\s*=>",
					relevance: 0
				}
			]
		},
		NUMBER,
		{
			begin: "(\\/\\/|" + hljs.RE_STARTERS_RE + "|\\b(split|return|print|reverse|grep)\\b)\\s*",
			keywords: "split return print reverse grep",
			relevance: 0,
			contains: [
				hljs.HASH_COMMENT_MODE,
				{
					className: "regexp",
					variants: [
						{ begin: PAIRED_DOUBLE_RE("s|tr|y", regex$1.either(...REGEX_DELIMS, { capture: !0 })) },
						{ begin: PAIRED_DOUBLE_RE("s|tr|y", "\\(", "\\)") },
						{ begin: PAIRED_DOUBLE_RE("s|tr|y", "\\[", "\\]") },
						{ begin: PAIRED_DOUBLE_RE("s|tr|y", "\\{", "\\}") }
					],
					relevance: 2
				},
				{
					className: "regexp",
					variants: [
						{
							begin: /(m|qr)\/\//,
							relevance: 0
						},
						{ begin: PAIRED_RE("(?:m|qr)?", /\//, /\//) },
						{ begin: PAIRED_RE("m|qr", regex$1.either(...REGEX_DELIMS, { capture: !0 }), /\1/) },
						{ begin: PAIRED_RE("m|qr", /\(/, /\)/) },
						{ begin: PAIRED_RE("m|qr", /\[/, /\]/) },
						{ begin: PAIRED_RE("m|qr", /\{/, /\}/) }
					]
				}
			]
		},
		{
			className: "function",
			beginKeywords: "sub method",
			end: "(\\s*\\(.*?\\))?[;{]",
			excludeEnd: !0,
			relevance: 5,
			contains: [hljs.TITLE_MODE, ATTR]
		},
		{
			className: "class",
			beginKeywords: "class",
			end: "[;{]",
			excludeEnd: !0,
			relevance: 5,
			contains: [
				hljs.TITLE_MODE,
				ATTR,
				NUMBER
			]
		},
		{
			begin: "-\\w\\b",
			relevance: 0
		},
		{
			begin: "^__DATA__$",
			end: "^__END__$",
			subLanguage: "mojolicious",
			contains: [{
				begin: "^@@.*",
				end: "$",
				className: "comment"
			}]
		}
	];
	return SUBST.contains = PERL_DEFAULT_CONTAINS, METHOD.contains = PERL_DEFAULT_CONTAINS, {
		name: "Perl",
		aliases: ["pl", "pm"],
		keywords: PERL_KEYWORDS,
		contains: PERL_DEFAULT_CONTAINS
	};
}
function php(hljs) {
	let regex$1 = hljs.regex, NOT_PERL_ETC = /(?![A-Za-z0-9])(?![$])/, IDENT_RE$3 = regex$1.concat(/[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/, NOT_PERL_ETC), PASCAL_CASE_CLASS_NAME_RE = regex$1.concat(/(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/, NOT_PERL_ETC), UPCASE_NAME_RE = regex$1.concat(/[A-Z]+/, NOT_PERL_ETC), VARIABLE = {
		scope: "variable",
		match: "\\$+" + IDENT_RE$3
	}, PREPROCESSOR = {
		scope: "meta",
		variants: [
			{
				begin: /<\?php/,
				relevance: 10
			},
			{ begin: /<\?=/ },
			{
				begin: /<\?/,
				relevance: .1
			},
			{ begin: /\?>/ }
		]
	}, SUBST = {
		scope: "subst",
		variants: [{ begin: /\$\w+/ }, {
			begin: /\{\$/,
			end: /\}/
		}]
	}, SINGLE_QUOTED = hljs.inherit(hljs.APOS_STRING_MODE, { illegal: null }), DOUBLE_QUOTED = hljs.inherit(hljs.QUOTE_STRING_MODE, {
		illegal: null,
		contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST)
	}), HEREDOC = {
		begin: /<<<[ \t]*(?:(\w+)|"(\w+)")\n/,
		end: /[ \t]*(\w+)\b/,
		contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST),
		"on:begin": (m, resp) => {
			resp.data._beginMatch = m[1] || m[2];
		},
		"on:end": (m, resp) => {
			resp.data._beginMatch !== m[1] && resp.ignoreMatch();
		}
	}, NOWDOC = hljs.END_SAME_AS_BEGIN({
		begin: /<<<[ \t]*'(\w+)'\n/,
		end: /[ \t]*(\w+)\b/
	}), WHITESPACE = "[ 	\n]", STRING = {
		scope: "string",
		variants: [
			DOUBLE_QUOTED,
			SINGLE_QUOTED,
			HEREDOC,
			NOWDOC
		]
	}, NUMBER = {
		scope: "number",
		variants: [
			{ begin: "\\b0[bB][01]+(?:_[01]+)*\\b" },
			{ begin: "\\b0[oO][0-7]+(?:_[0-7]+)*\\b" },
			{ begin: "\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b" },
			{ begin: "(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?" }
		],
		relevance: 0
	}, LITERALS$2 = [
		"false",
		"null",
		"true"
	], KWS = /* @__PURE__ */ "__CLASS__.__DIR__.__FILE__.__FUNCTION__.__COMPILER_HALT_OFFSET__.__LINE__.__METHOD__.__NAMESPACE__.__TRAIT__.die.echo.exit.include.include_once.print.require.require_once.array.abstract.and.as.binary.bool.boolean.break.callable.case.catch.class.clone.const.continue.declare.default.do.double.else.elseif.empty.enddeclare.endfor.endforeach.endif.endswitch.endwhile.enum.eval.extends.final.finally.float.for.foreach.from.global.goto.if.implements.instanceof.insteadof.int.integer.interface.isset.iterable.list.match|0.mixed.new.never.object.or.private.protected.public.readonly.real.return.string.switch.throw.trait.try.unset.use.var.void.while.xor.yield".split("."), BUILT_INS$2 = /* @__PURE__ */ "Error|0.AppendIterator.ArgumentCountError.ArithmeticError.ArrayIterator.ArrayObject.AssertionError.BadFunctionCallException.BadMethodCallException.CachingIterator.CallbackFilterIterator.CompileError.Countable.DirectoryIterator.DivisionByZeroError.DomainException.EmptyIterator.ErrorException.Exception.FilesystemIterator.FilterIterator.GlobIterator.InfiniteIterator.InvalidArgumentException.IteratorIterator.LengthException.LimitIterator.LogicException.MultipleIterator.NoRewindIterator.OutOfBoundsException.OutOfRangeException.OuterIterator.OverflowException.ParentIterator.ParseError.RangeException.RecursiveArrayIterator.RecursiveCachingIterator.RecursiveCallbackFilterIterator.RecursiveDirectoryIterator.RecursiveFilterIterator.RecursiveIterator.RecursiveIteratorIterator.RecursiveRegexIterator.RecursiveTreeIterator.RegexIterator.RuntimeException.SeekableIterator.SplDoublyLinkedList.SplFileInfo.SplFileObject.SplFixedArray.SplHeap.SplMaxHeap.SplMinHeap.SplObjectStorage.SplObserver.SplPriorityQueue.SplQueue.SplStack.SplSubject.SplTempFileObject.TypeError.UnderflowException.UnexpectedValueException.UnhandledMatchError.ArrayAccess.BackedEnum.Closure.Fiber.Generator.Iterator.IteratorAggregate.Serializable.Stringable.Throwable.Traversable.UnitEnum.WeakReference.WeakMap.Directory.__PHP_Incomplete_Class.parent.php_user_filter.self.static.stdClass".split("."), KEYWORDS$2 = {
		keyword: KWS,
		literal: ((items) => {
			let result = [];
			return items.forEach((item) => {
				result.push(item), item.toLowerCase() === item ? result.push(item.toUpperCase()) : result.push(item.toLowerCase());
			}), result;
		})(LITERALS$2),
		built_in: BUILT_INS$2
	}, normalizeKeywords = (items) => items.map((item) => item.replace(/\|\d+$/, "")), CONSTRUCTOR_CALL = { variants: [{
		match: [
			/new/,
			regex$1.concat(WHITESPACE, "+"),
			regex$1.concat("(?!", normalizeKeywords(BUILT_INS$2).join("\\b|"), "\\b)"),
			PASCAL_CASE_CLASS_NAME_RE
		],
		scope: {
			1: "keyword",
			4: "title.class"
		}
	}] }, CONSTANT_REFERENCE = regex$1.concat(IDENT_RE$3, "\\b(?!\\()"), LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON = { variants: [
		{
			match: [regex$1.concat(/::/, regex$1.lookahead(/(?!class\b)/)), CONSTANT_REFERENCE],
			scope: { 2: "variable.constant" }
		},
		{
			match: [/::/, /class/],
			scope: { 2: "variable.language" }
		},
		{
			match: [
				PASCAL_CASE_CLASS_NAME_RE,
				regex$1.concat(/::/, regex$1.lookahead(/(?!class\b)/)),
				CONSTANT_REFERENCE
			],
			scope: {
				1: "title.class",
				3: "variable.constant"
			}
		},
		{
			match: [PASCAL_CASE_CLASS_NAME_RE, regex$1.concat("::", regex$1.lookahead(/(?!class\b)/))],
			scope: { 1: "title.class" }
		},
		{
			match: [
				PASCAL_CASE_CLASS_NAME_RE,
				/::/,
				/class/
			],
			scope: {
				1: "title.class",
				3: "variable.language"
			}
		}
	] }, NAMED_ARGUMENT = {
		scope: "attr",
		match: regex$1.concat(IDENT_RE$3, regex$1.lookahead(":"), regex$1.lookahead(/(?!::)/))
	}, PARAMS_MODE = {
		relevance: 0,
		begin: /\(/,
		end: /\)/,
		keywords: KEYWORDS$2,
		contains: [
			NAMED_ARGUMENT,
			VARIABLE,
			LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
			hljs.C_BLOCK_COMMENT_MODE,
			STRING,
			NUMBER,
			CONSTRUCTOR_CALL
		]
	}, FUNCTION_INVOKE = {
		relevance: 0,
		match: [
			/\b/,
			regex$1.concat("(?!fn\\b|function\\b|", normalizeKeywords(KWS).join("\\b|"), "|", normalizeKeywords(BUILT_INS$2).join("\\b|"), "\\b)"),
			IDENT_RE$3,
			regex$1.concat(WHITESPACE, "*"),
			regex$1.lookahead(/(?=\()/)
		],
		scope: { 3: "title.function.invoke" },
		contains: [PARAMS_MODE]
	};
	PARAMS_MODE.contains.push(FUNCTION_INVOKE);
	let ATTRIBUTE_CONTAINS = [
		NAMED_ARGUMENT,
		LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
		hljs.C_BLOCK_COMMENT_MODE,
		STRING,
		NUMBER,
		CONSTRUCTOR_CALL
	], ATTRIBUTES$3 = {
		begin: regex$1.concat(/#\[\s*\\?/, regex$1.either(PASCAL_CASE_CLASS_NAME_RE, UPCASE_NAME_RE)),
		beginScope: "meta",
		end: /]/,
		endScope: "meta",
		keywords: {
			literal: LITERALS$2,
			keyword: ["new", "array"]
		},
		contains: [
			{
				begin: /\[/,
				end: /]/,
				keywords: {
					literal: LITERALS$2,
					keyword: ["new", "array"]
				},
				contains: ["self", ...ATTRIBUTE_CONTAINS]
			},
			...ATTRIBUTE_CONTAINS,
			{
				scope: "meta",
				variants: [{ match: PASCAL_CASE_CLASS_NAME_RE }, { match: UPCASE_NAME_RE }]
			}
		]
	};
	return {
		case_insensitive: !1,
		keywords: KEYWORDS$2,
		contains: [
			ATTRIBUTES$3,
			hljs.HASH_COMMENT_MODE,
			hljs.COMMENT("//", "$"),
			hljs.COMMENT("/\\*", "\\*/", { contains: [{
				scope: "doctag",
				match: "@[A-Za-z]+"
			}] }),
			{
				match: /__halt_compiler\(\);/,
				keywords: "__halt_compiler",
				starts: {
					scope: "comment",
					end: hljs.MATCH_NOTHING_RE,
					contains: [{
						match: /\?>/,
						scope: "meta",
						endsParent: !0
					}]
				}
			},
			PREPROCESSOR,
			{
				scope: "variable.language",
				match: /\$this\b/
			},
			VARIABLE,
			FUNCTION_INVOKE,
			LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
			{
				match: [
					/const/,
					/\s/,
					IDENT_RE$3
				],
				scope: {
					1: "keyword",
					3: "variable.constant"
				}
			},
			CONSTRUCTOR_CALL,
			{
				scope: "function",
				relevance: 0,
				beginKeywords: "fn function",
				end: /[;{]/,
				excludeEnd: !0,
				illegal: "[$%\\[]",
				contains: [
					{ beginKeywords: "use" },
					hljs.UNDERSCORE_TITLE_MODE,
					{
						begin: "=>",
						endsParent: !0
					},
					{
						scope: "params",
						begin: "\\(",
						end: "\\)",
						excludeBegin: !0,
						excludeEnd: !0,
						keywords: KEYWORDS$2,
						contains: [
							"self",
							ATTRIBUTES$3,
							VARIABLE,
							LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
							hljs.C_BLOCK_COMMENT_MODE,
							STRING,
							NUMBER
						]
					}
				]
			},
			{
				scope: "class",
				variants: [{
					beginKeywords: "enum",
					illegal: /[($"]/
				}, {
					beginKeywords: "class interface trait",
					illegal: /[:($"]/
				}],
				relevance: 0,
				end: /\{/,
				excludeEnd: !0,
				contains: [{ beginKeywords: "extends implements" }, hljs.UNDERSCORE_TITLE_MODE]
			},
			{
				beginKeywords: "namespace",
				relevance: 0,
				end: ";",
				illegal: /[.']/,
				contains: [hljs.inherit(hljs.UNDERSCORE_TITLE_MODE, { scope: "title.class" })]
			},
			{
				beginKeywords: "use",
				relevance: 0,
				end: ";",
				contains: [{
					match: /\b(as|const|function)\b/,
					scope: "keyword"
				}, hljs.UNDERSCORE_TITLE_MODE]
			},
			STRING,
			NUMBER
		]
	};
}
function phpTemplate(hljs) {
	return {
		name: "PHP template",
		subLanguage: "xml",
		contains: [{
			begin: /<\?(php|=)?/,
			end: /\?>/,
			subLanguage: "php",
			contains: [
				{
					begin: "/\\*",
					end: "\\*/",
					skip: !0
				},
				{
					begin: "b\"",
					end: "\"",
					skip: !0
				},
				{
					begin: "b'",
					end: "'",
					skip: !0
				},
				hljs.inherit(hljs.APOS_STRING_MODE, {
					illegal: null,
					className: null,
					contains: null,
					skip: !0
				}),
				hljs.inherit(hljs.QUOTE_STRING_MODE, {
					illegal: null,
					className: null,
					contains: null,
					skip: !0
				})
			]
		}]
	};
}
function plaintext(hljs) {
	return {
		name: "Plain text",
		aliases: ["text", "txt"],
		disableAutodetect: !0
	};
}
function python(hljs) {
	let regex$1 = hljs.regex, IDENT_RE$3 = /[\p{XID_Start}_]\p{XID_Continue}*/u, RESERVED_WORDS = /* @__PURE__ */ "and.as.assert.async.await.break.case.class.continue.def.del.elif.else.except.finally.for.from.global.if.import.in.is.lambda.match.nonlocal|10.not.or.pass.raise.return.try.while.with.yield".split("."), KEYWORDS$2 = {
		$pattern: /[A-Za-z]\w+|__\w+__/,
		keyword: RESERVED_WORDS,
		built_in: /* @__PURE__ */ "__import__.abs.all.any.ascii.bin.bool.breakpoint.bytearray.bytes.callable.chr.classmethod.compile.complex.delattr.dict.dir.divmod.enumerate.eval.exec.filter.float.format.frozenset.getattr.globals.hasattr.hash.help.hex.id.input.int.isinstance.issubclass.iter.len.list.locals.map.max.memoryview.min.next.object.oct.open.ord.pow.print.property.range.repr.reversed.round.set.setattr.slice.sorted.staticmethod.str.sum.super.tuple.type.vars.zip".split("."),
		literal: [
			"__debug__",
			"Ellipsis",
			"False",
			"None",
			"NotImplemented",
			"True"
		],
		type: [
			"Any",
			"Callable",
			"Coroutine",
			"Dict",
			"List",
			"Literal",
			"Generic",
			"Optional",
			"Sequence",
			"Set",
			"Tuple",
			"Type",
			"Union"
		]
	}, PROMPT = {
		className: "meta",
		begin: /^(>>>|\.\.\.) /
	}, SUBST = {
		className: "subst",
		begin: /\{/,
		end: /\}/,
		keywords: KEYWORDS$2,
		illegal: /#/
	}, LITERAL_BRACKET = {
		begin: /\{\{/,
		relevance: 0
	}, STRING = {
		className: "string",
		contains: [hljs.BACKSLASH_ESCAPE],
		variants: [
			{
				begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
				end: /'''/,
				contains: [hljs.BACKSLASH_ESCAPE, PROMPT],
				relevance: 10
			},
			{
				begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
				end: /"""/,
				contains: [hljs.BACKSLASH_ESCAPE, PROMPT],
				relevance: 10
			},
			{
				begin: /([fF][rR]|[rR][fF]|[fF])'''/,
				end: /'''/,
				contains: [
					hljs.BACKSLASH_ESCAPE,
					PROMPT,
					LITERAL_BRACKET,
					SUBST
				]
			},
			{
				begin: /([fF][rR]|[rR][fF]|[fF])"""/,
				end: /"""/,
				contains: [
					hljs.BACKSLASH_ESCAPE,
					PROMPT,
					LITERAL_BRACKET,
					SUBST
				]
			},
			{
				begin: /([uU]|[rR])'/,
				end: /'/,
				relevance: 10
			},
			{
				begin: /([uU]|[rR])"/,
				end: /"/,
				relevance: 10
			},
			{
				begin: /([bB]|[bB][rR]|[rR][bB])'/,
				end: /'/
			},
			{
				begin: /([bB]|[bB][rR]|[rR][bB])"/,
				end: /"/
			},
			{
				begin: /([fF][rR]|[rR][fF]|[fF])'/,
				end: /'/,
				contains: [
					hljs.BACKSLASH_ESCAPE,
					LITERAL_BRACKET,
					SUBST
				]
			},
			{
				begin: /([fF][rR]|[rR][fF]|[fF])"/,
				end: /"/,
				contains: [
					hljs.BACKSLASH_ESCAPE,
					LITERAL_BRACKET,
					SUBST
				]
			},
			hljs.APOS_STRING_MODE,
			hljs.QUOTE_STRING_MODE
		]
	}, digitpart = "[0-9](_?[0-9])*", pointfloat = `(\\b(${digitpart}))?\\.(${digitpart})|\\b(${digitpart})\\.`, lookahead$2 = `\\b|${RESERVED_WORDS.join("|")}`, NUMBER = {
		className: "number",
		relevance: 0,
		variants: [
			{ begin: `(\\b(${digitpart})|(${pointfloat}))[eE][+-]?(${digitpart})[jJ]?(?=${lookahead$2})` },
			{ begin: `(${pointfloat})[jJ]?` },
			{ begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${lookahead$2})` },
			{ begin: `\\b0[bB](_?[01])+[lL]?(?=${lookahead$2})` },
			{ begin: `\\b0[oO](_?[0-7])+[lL]?(?=${lookahead$2})` },
			{ begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${lookahead$2})` },
			{ begin: `\\b(${digitpart})[jJ](?=${lookahead$2})` }
		]
	}, COMMENT_TYPE = {
		className: "comment",
		begin: regex$1.lookahead(/# type:/),
		end: /$/,
		keywords: KEYWORDS$2,
		contains: [{ begin: /# type:/ }, {
			begin: /#/,
			end: /\b\B/,
			endsWithParent: !0
		}]
	}, PARAMS = {
		className: "params",
		variants: [{
			className: "",
			begin: /\(\s*\)/,
			skip: !0
		}, {
			begin: /\(/,
			end: /\)/,
			excludeBegin: !0,
			excludeEnd: !0,
			keywords: KEYWORDS$2,
			contains: [
				"self",
				PROMPT,
				NUMBER,
				STRING,
				hljs.HASH_COMMENT_MODE
			]
		}]
	};
	return SUBST.contains = [
		STRING,
		NUMBER,
		PROMPT
	], {
		name: "Python",
		aliases: [
			"py",
			"gyp",
			"ipython"
		],
		unicodeRegex: !0,
		keywords: KEYWORDS$2,
		illegal: /(<\/|\?)|=>/,
		contains: [
			PROMPT,
			NUMBER,
			{
				scope: "variable.language",
				match: /\bself\b/
			},
			{
				beginKeywords: "if",
				relevance: 0
			},
			{
				match: /\bor\b/,
				scope: "keyword"
			},
			STRING,
			COMMENT_TYPE,
			hljs.HASH_COMMENT_MODE,
			{
				match: [
					/\bdef/,
					/\s+/,
					IDENT_RE$3
				],
				scope: {
					1: "keyword",
					3: "title.function"
				},
				contains: [PARAMS]
			},
			{
				variants: [{ match: [
					/\bclass/,
					/\s+/,
					IDENT_RE$3,
					/\s*/,
					/\(\s*/,
					IDENT_RE$3,
					/\s*\)/
				] }, { match: [
					/\bclass/,
					/\s+/,
					IDENT_RE$3
				] }],
				scope: {
					1: "keyword",
					3: "title.class",
					6: "title.class.inherited"
				}
			},
			{
				className: "meta",
				begin: /^[\t ]*@/,
				end: /(?=#)|$/,
				contains: [
					NUMBER,
					PARAMS,
					STRING
				]
			}
		]
	};
}
function pythonRepl(hljs) {
	return {
		aliases: ["pycon"],
		contains: [{
			className: "meta.prompt",
			starts: {
				end: / |$/,
				starts: {
					end: "$",
					subLanguage: "python"
				}
			},
			variants: [{ begin: /^>>>(?=[ ]|$)/ }, { begin: /^\.\.\.(?=[ ]|$)/ }]
		}]
	};
}
function r(hljs) {
	let regex$1 = hljs.regex, IDENT_RE$3 = /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/, NUMBER_TYPES_RE = regex$1.either(/0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/, /0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/, /(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/), OPERATORS_RE = /[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/, PUNCTUATION_RE = regex$1.either(/[()]/, /[{}]/, /\[\[/, /[[\]]/, /\\/, /,/);
	return {
		name: "R",
		keywords: {
			$pattern: IDENT_RE$3,
			keyword: "function if in break next repeat else for while",
			literal: "NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10",
			built_in: "LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm"
		},
		contains: [
			hljs.COMMENT(/#'/, /$/, { contains: [
				{
					scope: "doctag",
					match: /@examples/,
					starts: {
						end: regex$1.lookahead(regex$1.either(/\n^#'\s*(?=@[a-zA-Z]+)/, /\n^(?!#')/)),
						endsParent: !0
					}
				},
				{
					scope: "doctag",
					begin: "@param",
					end: /$/,
					contains: [{
						scope: "variable",
						variants: [{ match: IDENT_RE$3 }, { match: /`(?:\\.|[^`\\])+`/ }],
						endsParent: !0
					}]
				},
				{
					scope: "doctag",
					match: /@[a-zA-Z]+/
				},
				{
					scope: "keyword",
					match: /\\[a-zA-Z]+/
				}
			] }),
			hljs.HASH_COMMENT_MODE,
			{
				scope: "string",
				contains: [hljs.BACKSLASH_ESCAPE],
				variants: [
					hljs.END_SAME_AS_BEGIN({
						begin: /[rR]"(-*)\(/,
						end: /\)(-*)"/
					}),
					hljs.END_SAME_AS_BEGIN({
						begin: /[rR]"(-*)\{/,
						end: /\}(-*)"/
					}),
					hljs.END_SAME_AS_BEGIN({
						begin: /[rR]"(-*)\[/,
						end: /\](-*)"/
					}),
					hljs.END_SAME_AS_BEGIN({
						begin: /[rR]'(-*)\(/,
						end: /\)(-*)'/
					}),
					hljs.END_SAME_AS_BEGIN({
						begin: /[rR]'(-*)\{/,
						end: /\}(-*)'/
					}),
					hljs.END_SAME_AS_BEGIN({
						begin: /[rR]'(-*)\[/,
						end: /\](-*)'/
					}),
					{
						begin: "\"",
						end: "\"",
						relevance: 0
					},
					{
						begin: "'",
						end: "'",
						relevance: 0
					}
				]
			},
			{
				relevance: 0,
				variants: [
					{
						scope: {
							1: "operator",
							2: "number"
						},
						match: [OPERATORS_RE, NUMBER_TYPES_RE]
					},
					{
						scope: {
							1: "operator",
							2: "number"
						},
						match: [/%[^%]*%/, NUMBER_TYPES_RE]
					},
					{
						scope: {
							1: "punctuation",
							2: "number"
						},
						match: [PUNCTUATION_RE, NUMBER_TYPES_RE]
					},
					{
						scope: { 2: "number" },
						match: [/[^a-zA-Z0-9._]|^/, NUMBER_TYPES_RE]
					}
				]
			},
			{
				scope: { 3: "operator" },
				match: [
					IDENT_RE$3,
					/\s+/,
					/<-/,
					/\s+/
				]
			},
			{
				scope: "operator",
				relevance: 0,
				variants: [{ match: OPERATORS_RE }, { match: /%[^%]*%/ }]
			},
			{
				scope: "punctuation",
				relevance: 0,
				match: PUNCTUATION_RE
			},
			{
				begin: "`",
				end: "`",
				contains: [{ begin: /\\./ }]
			}
		]
	};
}
function ruby(hljs) {
	let regex$1 = hljs.regex, RUBY_METHOD_RE = "([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)", CLASS_NAME_RE = regex$1.either(/\b([A-Z]+[a-z0-9]+)+/, /\b([A-Z]+[a-z0-9]+)+[A-Z]+/), CLASS_NAME_WITH_NAMESPACE_RE = regex$1.concat(CLASS_NAME_RE, /(::\w+)*/), PSEUDO_KWS = [
		"include",
		"extend",
		"prepend",
		"public",
		"private",
		"protected",
		"raise",
		"throw"
	], RUBY_KEYWORDS = {
		"variable.constant": [
			"__FILE__",
			"__LINE__",
			"__ENCODING__"
		],
		"variable.language": ["self", "super"],
		keyword: [
			"alias",
			"and",
			"begin",
			"BEGIN",
			"break",
			"case",
			"class",
			"defined",
			"do",
			"else",
			"elsif",
			"end",
			"END",
			"ensure",
			"for",
			"if",
			"in",
			"module",
			"next",
			"not",
			"or",
			"redo",
			"require",
			"rescue",
			"retry",
			"return",
			"then",
			"undef",
			"unless",
			"until",
			"when",
			"while",
			"yield",
			...PSEUDO_KWS
		],
		built_in: [
			"proc",
			"lambda",
			"attr_accessor",
			"attr_reader",
			"attr_writer",
			"define_method",
			"private_constant",
			"module_function"
		],
		literal: [
			"true",
			"false",
			"nil"
		]
	}, YARDOCTAG = {
		className: "doctag",
		begin: "@[A-Za-z]+"
	}, IRB_OBJECT = {
		begin: "#<",
		end: ">"
	}, COMMENT_MODES = [
		hljs.COMMENT("#", "$", { contains: [YARDOCTAG] }),
		hljs.COMMENT("^=begin", "^=end", {
			contains: [YARDOCTAG],
			relevance: 10
		}),
		hljs.COMMENT("^__END__", hljs.MATCH_NOTHING_RE)
	], SUBST = {
		className: "subst",
		begin: /#\{/,
		end: /\}/,
		keywords: RUBY_KEYWORDS
	}, STRING = {
		className: "string",
		contains: [hljs.BACKSLASH_ESCAPE, SUBST],
		variants: [
			{
				begin: /'/,
				end: /'/
			},
			{
				begin: /"/,
				end: /"/
			},
			{
				begin: /`/,
				end: /`/
			},
			{
				begin: /%[qQwWx]?\(/,
				end: /\)/
			},
			{
				begin: /%[qQwWx]?\[/,
				end: /\]/
			},
			{
				begin: /%[qQwWx]?\{/,
				end: /\}/
			},
			{
				begin: /%[qQwWx]?</,
				end: />/
			},
			{
				begin: /%[qQwWx]?\//,
				end: /\//
			},
			{
				begin: /%[qQwWx]?%/,
				end: /%/
			},
			{
				begin: /%[qQwWx]?-/,
				end: /-/
			},
			{
				begin: /%[qQwWx]?\|/,
				end: /\|/
			},
			{ begin: /\B\?(\\\d{1,3})/ },
			{ begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/ },
			{ begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/ },
			{ begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/ },
			{ begin: /\B\?\\(c|C-)[\x20-\x7e]/ },
			{ begin: /\B\?\\?\S/ },
			{
				begin: regex$1.concat(/<<[-~]?'?/, regex$1.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)),
				contains: [hljs.END_SAME_AS_BEGIN({
					begin: /(\w+)/,
					end: /(\w+)/,
					contains: [hljs.BACKSLASH_ESCAPE, SUBST]
				})]
			}
		]
	}, decimal = "[1-9](_?[0-9])*|0", digits = "[0-9](_?[0-9])*", NUMBER = {
		className: "number",
		relevance: 0,
		variants: [
			{ begin: `\\b([1-9](_?[0-9])*|0)(\\.(${digits}))?([eE][+-]?(${digits})|r)?i?\\b` },
			{ begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b" },
			{ begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b" },
			{ begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b" },
			{ begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b" },
			{ begin: "\\b0(_?[0-7])+r?i?\\b" }
		]
	}, PARAMS = { variants: [{ match: /\(\)/ }, {
		className: "params",
		begin: /\(/,
		end: /(?=\))/,
		excludeBegin: !0,
		endsParent: !0,
		keywords: RUBY_KEYWORDS
	}] }, INCLUDE_EXTEND = {
		match: [/(include|extend)\s+/, CLASS_NAME_WITH_NAMESPACE_RE],
		scope: { 2: "title.class" },
		keywords: RUBY_KEYWORDS
	}, CLASS_DEFINITION = {
		variants: [{ match: [
			/class\s+/,
			CLASS_NAME_WITH_NAMESPACE_RE,
			/\s+<\s+/,
			CLASS_NAME_WITH_NAMESPACE_RE
		] }, { match: [/\b(class|module)\s+/, CLASS_NAME_WITH_NAMESPACE_RE] }],
		scope: {
			2: "title.class",
			4: "title.class.inherited"
		},
		keywords: RUBY_KEYWORDS
	}, UPPER_CASE_CONSTANT = {
		relevance: 0,
		match: /\b[A-Z][A-Z_0-9]+\b/,
		className: "variable.constant"
	}, METHOD_DEFINITION = {
		match: [
			/def/,
			/\s+/,
			RUBY_METHOD_RE
		],
		scope: {
			1: "keyword",
			3: "title.function"
		},
		contains: [PARAMS]
	}, RUBY_DEFAULT_CONTAINS = [
		STRING,
		CLASS_DEFINITION,
		INCLUDE_EXTEND,
		{
			relevance: 0,
			match: [CLASS_NAME_WITH_NAMESPACE_RE, /\.new[. (]/],
			scope: { 1: "title.class" }
		},
		UPPER_CASE_CONSTANT,
		{
			relevance: 0,
			match: CLASS_NAME_RE,
			scope: "title.class"
		},
		METHOD_DEFINITION,
		{ begin: hljs.IDENT_RE + "::" },
		{
			className: "symbol",
			begin: hljs.UNDERSCORE_IDENT_RE + "(!|\\?)?:",
			relevance: 0
		},
		{
			className: "symbol",
			begin: ":(?!\\s)",
			contains: [STRING, { begin: RUBY_METHOD_RE }],
			relevance: 0
		},
		NUMBER,
		{
			className: "variable",
			begin: "(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])"
		},
		{
			className: "params",
			begin: /\|(?!=)/,
			end: /\|/,
			excludeBegin: !0,
			excludeEnd: !0,
			relevance: 0,
			keywords: RUBY_KEYWORDS
		},
		{
			begin: "(" + hljs.RE_STARTERS_RE + "|unless)\\s*",
			keywords: "unless",
			contains: [{
				className: "regexp",
				contains: [hljs.BACKSLASH_ESCAPE, SUBST],
				illegal: /\n/,
				variants: [
					{
						begin: "/",
						end: "/[a-z]*"
					},
					{
						begin: /%r\{/,
						end: /\}[a-z]*/
					},
					{
						begin: "%r\\(",
						end: "\\)[a-z]*"
					},
					{
						begin: "%r!",
						end: "![a-z]*"
					},
					{
						begin: "%r\\[",
						end: "\\][a-z]*"
					}
				]
			}].concat(IRB_OBJECT, COMMENT_MODES),
			relevance: 0
		}
	].concat(IRB_OBJECT, COMMENT_MODES);
	SUBST.contains = RUBY_DEFAULT_CONTAINS, PARAMS.contains = RUBY_DEFAULT_CONTAINS;
	let IRB_DEFAULT = [{
		begin: /^\s*=>/,
		starts: {
			end: "$",
			contains: RUBY_DEFAULT_CONTAINS
		}
	}, {
		className: "meta.prompt",
		begin: "^([>?]>|[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]|(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>)(?=[ ])",
		starts: {
			end: "$",
			keywords: RUBY_KEYWORDS,
			contains: RUBY_DEFAULT_CONTAINS
		}
	}];
	return COMMENT_MODES.unshift(IRB_OBJECT), {
		name: "Ruby",
		aliases: [
			"rb",
			"gemspec",
			"podspec",
			"thor",
			"irb"
		],
		keywords: RUBY_KEYWORDS,
		illegal: /\/\*/,
		contains: [hljs.SHEBANG({ binary: "ruby" })].concat(IRB_DEFAULT, COMMENT_MODES, RUBY_DEFAULT_CONTAINS)
	};
}
function rust(hljs) {
	let regex$1 = hljs.regex, RAW_IDENTIFIER = /(r#)?/, UNDERSCORE_IDENT_RE$1 = regex$1.concat(RAW_IDENTIFIER, hljs.UNDERSCORE_IDENT_RE), IDENT_RE$3 = regex$1.concat(RAW_IDENTIFIER, hljs.IDENT_RE), FUNCTION_INVOKE = {
		className: "title.function.invoke",
		relevance: 0,
		begin: regex$1.concat(/\b/, /(?!let|for|while|if|else|match\b)/, IDENT_RE$3, regex$1.lookahead(/\s*\(/))
	}, NUMBER_SUFFIX = "([ui](8|16|32|64|128|size)|f(32|64))?", KEYWORDS$2 = /* @__PURE__ */ "abstract.as.async.await.become.box.break.const.continue.crate.do.dyn.else.enum.extern.false.final.fn.for.if.impl.in.let.loop.macro.match.mod.move.mut.override.priv.pub.ref.return.self.Self.static.struct.super.trait.true.try.type.typeof.union.unsafe.unsized.use.virtual.where.while.yield".split("."), LITERALS$2 = [
		"true",
		"false",
		"Some",
		"None",
		"Ok",
		"Err"
	], BUILTINS = /* @__PURE__ */ "drop .Copy.Send.Sized.Sync.Drop.Fn.FnMut.FnOnce.ToOwned.Clone.Debug.PartialEq.PartialOrd.Eq.Ord.AsRef.AsMut.Into.From.Default.Iterator.Extend.IntoIterator.DoubleEndedIterator.ExactSizeIterator.SliceConcatExt.ToString.assert!.assert_eq!.bitflags!.bytes!.cfg!.col!.concat!.concat_idents!.debug_assert!.debug_assert_eq!.env!.eprintln!.panic!.file!.format!.format_args!.include_bytes!.include_str!.line!.local_data_key!.module_path!.option_env!.print!.println!.select!.stringify!.try!.unimplemented!.unreachable!.vec!.write!.writeln!.macro_rules!.assert_ne!.debug_assert_ne!".split("."), TYPES$2 = [
		"i8",
		"i16",
		"i32",
		"i64",
		"i128",
		"isize",
		"u8",
		"u16",
		"u32",
		"u64",
		"u128",
		"usize",
		"f32",
		"f64",
		"str",
		"char",
		"bool",
		"Box",
		"Option",
		"Result",
		"String",
		"Vec"
	];
	return {
		name: "Rust",
		aliases: ["rs"],
		keywords: {
			$pattern: hljs.IDENT_RE + "!?",
			type: TYPES$2,
			keyword: KEYWORDS$2,
			literal: LITERALS$2,
			built_in: BUILTINS
		},
		illegal: "</",
		contains: [
			hljs.C_LINE_COMMENT_MODE,
			hljs.COMMENT("/\\*", "\\*/", { contains: ["self"] }),
			hljs.inherit(hljs.QUOTE_STRING_MODE, {
				begin: /b?"/,
				illegal: null
			}),
			{
				className: "symbol",
				begin: /'[a-zA-Z_][a-zA-Z0-9_]*(?!')/
			},
			{
				scope: "string",
				variants: [{ begin: /b?r(#*)"(.|\n)*?"\1(?!#)/ }, {
					begin: /b?'/,
					end: /'/,
					contains: [{
						scope: "char.escape",
						match: /\\('|\w|x\w{2}|u\w{4}|U\w{8})/
					}]
				}]
			},
			{
				className: "number",
				variants: [
					{ begin: "\\b0b([01_]+)" + NUMBER_SUFFIX },
					{ begin: "\\b0o([0-7_]+)" + NUMBER_SUFFIX },
					{ begin: "\\b0x([A-Fa-f0-9_]+)" + NUMBER_SUFFIX },
					{ begin: "\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)" + NUMBER_SUFFIX }
				],
				relevance: 0
			},
			{
				begin: [
					/fn/,
					/\s+/,
					UNDERSCORE_IDENT_RE$1
				],
				className: {
					1: "keyword",
					3: "title.function"
				}
			},
			{
				className: "meta",
				begin: "#!?\\[",
				end: "\\]",
				contains: [{
					className: "string",
					begin: /"/,
					end: /"/,
					contains: [hljs.BACKSLASH_ESCAPE]
				}]
			},
			{
				begin: [
					/let/,
					/\s+/,
					/(?:mut\s+)?/,
					UNDERSCORE_IDENT_RE$1
				],
				className: {
					1: "keyword",
					3: "keyword",
					4: "variable"
				}
			},
			{
				begin: [
					/for/,
					/\s+/,
					UNDERSCORE_IDENT_RE$1,
					/\s+/,
					/in/
				],
				className: {
					1: "keyword",
					3: "variable",
					5: "keyword"
				}
			},
			{
				begin: [
					/type/,
					/\s+/,
					UNDERSCORE_IDENT_RE$1
				],
				className: {
					1: "keyword",
					3: "title.class"
				}
			},
			{
				begin: [
					/(?:trait|enum|struct|union|impl|for)/,
					/\s+/,
					UNDERSCORE_IDENT_RE$1
				],
				className: {
					1: "keyword",
					3: "title.class"
				}
			},
			{
				begin: hljs.IDENT_RE + "::",
				keywords: {
					keyword: "Self",
					built_in: BUILTINS,
					type: TYPES$2
				}
			},
			{
				className: "punctuation",
				begin: "->"
			},
			FUNCTION_INVOKE
		]
	};
}
var MODES$1 = (hljs) => ({
	IMPORTANT: {
		scope: "meta",
		begin: "!important"
	},
	BLOCK_COMMENT: hljs.C_BLOCK_COMMENT_MODE,
	HEXCOLOR: {
		scope: "number",
		begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
	},
	FUNCTION_DISPATCH: {
		className: "built_in",
		begin: /[\w-]+(?=\()/
	},
	ATTRIBUTE_SELECTOR_MODE: {
		scope: "selector-attr",
		begin: /\[/,
		end: /\]/,
		illegal: "$",
		contains: [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE]
	},
	CSS_NUMBER_MODE: {
		scope: "number",
		begin: hljs.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
		relevance: 0
	},
	CSS_VARIABLE: {
		className: "attr",
		begin: /--[A-Za-z_][A-Za-z0-9_-]*/
	}
}), HTML_TAGS = /* @__PURE__ */ "a.abbr.address.article.aside.audio.b.blockquote.body.button.canvas.caption.cite.code.dd.del.details.dfn.div.dl.dt.em.fieldset.figcaption.figure.footer.form.h1.h2.h3.h4.h5.h6.header.hgroup.html.i.iframe.img.input.ins.kbd.label.legend.li.main.mark.menu.nav.object.ol.optgroup.option.p.picture.q.quote.samp.section.select.source.span.strong.summary.sup.table.tbody.td.textarea.tfoot.th.thead.time.tr.ul.var.video".split("."), SVG_TAGS = /* @__PURE__ */ "defs.g.marker.mask.pattern.svg.switch.symbol.feBlend.feColorMatrix.feComponentTransfer.feComposite.feConvolveMatrix.feDiffuseLighting.feDisplacementMap.feFlood.feGaussianBlur.feImage.feMerge.feMorphology.feOffset.feSpecularLighting.feTile.feTurbulence.linearGradient.radialGradient.stop.circle.ellipse.image.line.path.polygon.polyline.rect.text.use.textPath.tspan.foreignObject.clipPath".split("."), TAGS = [...HTML_TAGS, ...SVG_TAGS], MEDIA_FEATURES = (/* @__PURE__ */ "any-hover.any-pointer.aspect-ratio.color.color-gamut.color-index.device-aspect-ratio.device-height.device-width.display-mode.forced-colors.grid.height.hover.inverted-colors.monochrome.orientation.overflow-block.overflow-inline.pointer.prefers-color-scheme.prefers-contrast.prefers-reduced-motion.prefers-reduced-transparency.resolution.scan.scripting.update.width.min-width.max-width.min-height.max-height".split(".")).sort().reverse(), PSEUDO_CLASSES = (/* @__PURE__ */ "active.any-link.blank.checked.current.default.defined.dir.disabled.drop.empty.enabled.first.first-child.first-of-type.fullscreen.future.focus.focus-visible.focus-within.has.host.host-context.hover.indeterminate.in-range.invalid.is.lang.last-child.last-of-type.left.link.local-link.not.nth-child.nth-col.nth-last-child.nth-last-col.nth-last-of-type.nth-of-type.only-child.only-of-type.optional.out-of-range.past.placeholder-shown.read-only.read-write.required.right.root.scope.target.target-within.user-invalid.valid.visited.where".split(".")).sort().reverse(), PSEUDO_ELEMENTS = [
	"after",
	"backdrop",
	"before",
	"cue",
	"cue-region",
	"first-letter",
	"first-line",
	"grammar-error",
	"marker",
	"part",
	"placeholder",
	"selection",
	"slotted",
	"spelling-error"
].sort().reverse(), ATTRIBUTES = (/* @__PURE__ */ "accent-color.align-content.align-items.align-self.alignment-baseline.all.anchor-name.animation.animation-composition.animation-delay.animation-direction.animation-duration.animation-fill-mode.animation-iteration-count.animation-name.animation-play-state.animation-range.animation-range-end.animation-range-start.animation-timeline.animation-timing-function.appearance.aspect-ratio.backdrop-filter.backface-visibility.background.background-attachment.background-blend-mode.background-clip.background-color.background-image.background-origin.background-position.background-position-x.background-position-y.background-repeat.background-size.baseline-shift.block-size.border.border-block.border-block-color.border-block-end.border-block-end-color.border-block-end-style.border-block-end-width.border-block-start.border-block-start-color.border-block-start-style.border-block-start-width.border-block-style.border-block-width.border-bottom.border-bottom-color.border-bottom-left-radius.border-bottom-right-radius.border-bottom-style.border-bottom-width.border-collapse.border-color.border-end-end-radius.border-end-start-radius.border-image.border-image-outset.border-image-repeat.border-image-slice.border-image-source.border-image-width.border-inline.border-inline-color.border-inline-end.border-inline-end-color.border-inline-end-style.border-inline-end-width.border-inline-start.border-inline-start-color.border-inline-start-style.border-inline-start-width.border-inline-style.border-inline-width.border-left.border-left-color.border-left-style.border-left-width.border-radius.border-right.border-right-color.border-right-style.border-right-width.border-spacing.border-start-end-radius.border-start-start-radius.border-style.border-top.border-top-color.border-top-left-radius.border-top-right-radius.border-top-style.border-top-width.border-width.bottom.box-align.box-decoration-break.box-direction.box-flex.box-flex-group.box-lines.box-ordinal-group.box-orient.box-pack.box-shadow.box-sizing.break-after.break-before.break-inside.caption-side.caret-color.clear.clip.clip-path.clip-rule.color.color-interpolation.color-interpolation-filters.color-profile.color-rendering.color-scheme.column-count.column-fill.column-gap.column-rule.column-rule-color.column-rule-style.column-rule-width.column-span.column-width.columns.contain.contain-intrinsic-block-size.contain-intrinsic-height.contain-intrinsic-inline-size.contain-intrinsic-size.contain-intrinsic-width.container.container-name.container-type.content.content-visibility.counter-increment.counter-reset.counter-set.cue.cue-after.cue-before.cursor.cx.cy.direction.display.dominant-baseline.empty-cells.enable-background.field-sizing.fill.fill-opacity.fill-rule.filter.flex.flex-basis.flex-direction.flex-flow.flex-grow.flex-shrink.flex-wrap.float.flood-color.flood-opacity.flow.font.font-display.font-family.font-feature-settings.font-kerning.font-language-override.font-optical-sizing.font-palette.font-size.font-size-adjust.font-smooth.font-smoothing.font-stretch.font-style.font-synthesis.font-synthesis-position.font-synthesis-small-caps.font-synthesis-style.font-synthesis-weight.font-variant.font-variant-alternates.font-variant-caps.font-variant-east-asian.font-variant-emoji.font-variant-ligatures.font-variant-numeric.font-variant-position.font-variation-settings.font-weight.forced-color-adjust.gap.glyph-orientation-horizontal.glyph-orientation-vertical.grid.grid-area.grid-auto-columns.grid-auto-flow.grid-auto-rows.grid-column.grid-column-end.grid-column-start.grid-gap.grid-row.grid-row-end.grid-row-start.grid-template.grid-template-areas.grid-template-columns.grid-template-rows.hanging-punctuation.height.hyphenate-character.hyphenate-limit-chars.hyphens.icon.image-orientation.image-rendering.image-resolution.ime-mode.initial-letter.initial-letter-align.inline-size.inset.inset-area.inset-block.inset-block-end.inset-block-start.inset-inline.inset-inline-end.inset-inline-start.isolation.justify-content.justify-items.justify-self.kerning.left.letter-spacing.lighting-color.line-break.line-height.line-height-step.list-style.list-style-image.list-style-position.list-style-type.margin.margin-block.margin-block-end.margin-block-start.margin-bottom.margin-inline.margin-inline-end.margin-inline-start.margin-left.margin-right.margin-top.margin-trim.marker.marker-end.marker-mid.marker-start.marks.mask.mask-border.mask-border-mode.mask-border-outset.mask-border-repeat.mask-border-slice.mask-border-source.mask-border-width.mask-clip.mask-composite.mask-image.mask-mode.mask-origin.mask-position.mask-repeat.mask-size.mask-type.masonry-auto-flow.math-depth.math-shift.math-style.max-block-size.max-height.max-inline-size.max-width.min-block-size.min-height.min-inline-size.min-width.mix-blend-mode.nav-down.nav-index.nav-left.nav-right.nav-up.none.normal.object-fit.object-position.offset.offset-anchor.offset-distance.offset-path.offset-position.offset-rotate.opacity.order.orphans.outline.outline-color.outline-offset.outline-style.outline-width.overflow.overflow-anchor.overflow-block.overflow-clip-margin.overflow-inline.overflow-wrap.overflow-x.overflow-y.overlay.overscroll-behavior.overscroll-behavior-block.overscroll-behavior-inline.overscroll-behavior-x.overscroll-behavior-y.padding.padding-block.padding-block-end.padding-block-start.padding-bottom.padding-inline.padding-inline-end.padding-inline-start.padding-left.padding-right.padding-top.page.page-break-after.page-break-before.page-break-inside.paint-order.pause.pause-after.pause-before.perspective.perspective-origin.place-content.place-items.place-self.pointer-events.position.position-anchor.position-visibility.print-color-adjust.quotes.r.resize.rest.rest-after.rest-before.right.rotate.row-gap.ruby-align.ruby-position.scale.scroll-behavior.scroll-margin.scroll-margin-block.scroll-margin-block-end.scroll-margin-block-start.scroll-margin-bottom.scroll-margin-inline.scroll-margin-inline-end.scroll-margin-inline-start.scroll-margin-left.scroll-margin-right.scroll-margin-top.scroll-padding.scroll-padding-block.scroll-padding-block-end.scroll-padding-block-start.scroll-padding-bottom.scroll-padding-inline.scroll-padding-inline-end.scroll-padding-inline-start.scroll-padding-left.scroll-padding-right.scroll-padding-top.scroll-snap-align.scroll-snap-stop.scroll-snap-type.scroll-timeline.scroll-timeline-axis.scroll-timeline-name.scrollbar-color.scrollbar-gutter.scrollbar-width.shape-image-threshold.shape-margin.shape-outside.shape-rendering.speak.speak-as.src.stop-color.stop-opacity.stroke.stroke-dasharray.stroke-dashoffset.stroke-linecap.stroke-linejoin.stroke-miterlimit.stroke-opacity.stroke-width.tab-size.table-layout.text-align.text-align-all.text-align-last.text-anchor.text-combine-upright.text-decoration.text-decoration-color.text-decoration-line.text-decoration-skip.text-decoration-skip-ink.text-decoration-style.text-decoration-thickness.text-emphasis.text-emphasis-color.text-emphasis-position.text-emphasis-style.text-indent.text-justify.text-orientation.text-overflow.text-rendering.text-shadow.text-size-adjust.text-transform.text-underline-offset.text-underline-position.text-wrap.text-wrap-mode.text-wrap-style.timeline-scope.top.touch-action.transform.transform-box.transform-origin.transform-style.transition.transition-behavior.transition-delay.transition-duration.transition-property.transition-timing-function.translate.unicode-bidi.user-modify.user-select.vector-effect.vertical-align.view-timeline.view-timeline-axis.view-timeline-inset.view-timeline-name.view-transition-name.visibility.voice-balance.voice-duration.voice-family.voice-pitch.voice-range.voice-rate.voice-stress.voice-volume.white-space.white-space-collapse.widows.width.will-change.word-break.word-spacing.word-wrap.writing-mode.x.y.z-index.zoom".split(".")).sort().reverse();
function scss(hljs) {
	let modes = MODES$1(hljs), PSEUDO_ELEMENTS$1$1 = PSEUDO_ELEMENTS, PSEUDO_CLASSES$1$1 = PSEUDO_CLASSES, AT_IDENTIFIER = "@[a-z-]+", AT_MODIFIERS = "and or not only", VARIABLE = {
		className: "variable",
		begin: "(\\$[a-zA-Z-][a-zA-Z0-9_-]*)\\b",
		relevance: 0
	};
	return {
		name: "SCSS",
		case_insensitive: !0,
		illegal: "[=/|']",
		contains: [
			hljs.C_LINE_COMMENT_MODE,
			hljs.C_BLOCK_COMMENT_MODE,
			modes.CSS_NUMBER_MODE,
			{
				className: "selector-id",
				begin: "#[A-Za-z0-9_-]+",
				relevance: 0
			},
			{
				className: "selector-class",
				begin: "\\.[A-Za-z0-9_-]+",
				relevance: 0
			},
			modes.ATTRIBUTE_SELECTOR_MODE,
			{
				className: "selector-tag",
				begin: "\\b(" + TAGS.join("|") + ")\\b",
				relevance: 0
			},
			{
				className: "selector-pseudo",
				begin: ":(" + PSEUDO_CLASSES$1$1.join("|") + ")"
			},
			{
				className: "selector-pseudo",
				begin: ":(:)?(" + PSEUDO_ELEMENTS$1$1.join("|") + ")"
			},
			VARIABLE,
			{
				begin: /\(/,
				end: /\)/,
				contains: [modes.CSS_NUMBER_MODE]
			},
			modes.CSS_VARIABLE,
			{
				className: "attribute",
				begin: "\\b(" + ATTRIBUTES.join("|") + ")\\b"
			},
			{ begin: "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b" },
			{
				begin: /:/,
				end: /[;}{]/,
				relevance: 0,
				contains: [
					modes.BLOCK_COMMENT,
					VARIABLE,
					modes.HEXCOLOR,
					modes.CSS_NUMBER_MODE,
					hljs.QUOTE_STRING_MODE,
					hljs.APOS_STRING_MODE,
					modes.IMPORTANT,
					modes.FUNCTION_DISPATCH
				]
			},
			{
				begin: "@(page|font-face)",
				keywords: {
					$pattern: AT_IDENTIFIER,
					keyword: "@page @font-face"
				}
			},
			{
				begin: "@",
				end: "[{;]",
				returnBegin: !0,
				keywords: {
					$pattern: /[a-z-]+/,
					keyword: "and or not only",
					attribute: MEDIA_FEATURES.join(" ")
				},
				contains: [
					{
						begin: AT_IDENTIFIER,
						className: "keyword"
					},
					{
						begin: /[a-z-]+(?=:)/,
						className: "attribute"
					},
					VARIABLE,
					hljs.QUOTE_STRING_MODE,
					hljs.APOS_STRING_MODE,
					modes.HEXCOLOR,
					modes.CSS_NUMBER_MODE
				]
			},
			modes.FUNCTION_DISPATCH
		]
	};
}
function shell(hljs) {
	return {
		name: "Shell Session",
		aliases: ["console", "shellsession"],
		contains: [{
			className: "meta.prompt",
			begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
			starts: {
				end: /[^\\](?=\s*$)/,
				subLanguage: "bash"
			}
		}]
	};
}
function sql(hljs) {
	let regex$1 = hljs.regex, COMMENT_MODE = hljs.COMMENT("--", "$"), STRING = {
		scope: "string",
		variants: [{
			begin: /'/,
			end: /'/,
			contains: [{ match: /''/ }]
		}]
	}, QUOTED_IDENTIFIER = {
		begin: /"/,
		end: /"/,
		contains: [{ match: /""/ }]
	}, LITERALS$2 = [
		"true",
		"false",
		"unknown"
	], MULTI_WORD_TYPES = [
		"double precision",
		"large object",
		"with timezone",
		"without timezone"
	], TYPES$2 = /* @__PURE__ */ "bigint.binary.blob.boolean.char.character.clob.date.dec.decfloat.decimal.float.int.integer.interval.nchar.nclob.national.numeric.real.row.smallint.time.timestamp.varchar.varying.varbinary".split("."), NON_RESERVED_WORDS = [
		"add",
		"asc",
		"collation",
		"desc",
		"final",
		"first",
		"last",
		"view"
	], RESERVED_WORDS = /* @__PURE__ */ "abs.acos.all.allocate.alter.and.any.are.array.array_agg.array_max_cardinality.as.asensitive.asin.asymmetric.at.atan.atomic.authorization.avg.begin.begin_frame.begin_partition.between.bigint.binary.blob.boolean.both.by.call.called.cardinality.cascaded.case.cast.ceil.ceiling.char.char_length.character.character_length.check.classifier.clob.close.coalesce.collate.collect.column.commit.condition.connect.constraint.contains.convert.copy.corr.corresponding.cos.cosh.count.covar_pop.covar_samp.create.cross.cube.cume_dist.current.current_catalog.current_date.current_default_transform_group.current_path.current_role.current_row.current_schema.current_time.current_timestamp.current_path.current_role.current_transform_group_for_type.current_user.cursor.cycle.date.day.deallocate.dec.decimal.decfloat.declare.default.define.delete.dense_rank.deref.describe.deterministic.disconnect.distinct.double.drop.dynamic.each.element.else.empty.end.end_frame.end_partition.end-exec.equals.escape.every.except.exec.execute.exists.exp.external.extract.false.fetch.filter.first_value.float.floor.for.foreign.frame_row.free.from.full.function.fusion.get.global.grant.group.grouping.groups.having.hold.hour.identity.in.indicator.initial.inner.inout.insensitive.insert.int.integer.intersect.intersection.interval.into.is.join.json_array.json_arrayagg.json_exists.json_object.json_objectagg.json_query.json_table.json_table_primitive.json_value.lag.language.large.last_value.lateral.lead.leading.left.like.like_regex.listagg.ln.local.localtime.localtimestamp.log.log10.lower.match.match_number.match_recognize.matches.max.member.merge.method.min.minute.mod.modifies.module.month.multiset.national.natural.nchar.nclob.new.no.none.normalize.not.nth_value.ntile.null.nullif.numeric.octet_length.occurrences_regex.of.offset.old.omit.on.one.only.open.or.order.out.outer.over.overlaps.overlay.parameter.partition.pattern.per.percent.percent_rank.percentile_cont.percentile_disc.period.portion.position.position_regex.power.precedes.precision.prepare.primary.procedure.ptf.range.rank.reads.real.recursive.ref.references.referencing.regr_avgx.regr_avgy.regr_count.regr_intercept.regr_r2.regr_slope.regr_sxx.regr_sxy.regr_syy.release.result.return.returns.revoke.right.rollback.rollup.row.row_number.rows.running.savepoint.scope.scroll.search.second.seek.select.sensitive.session_user.set.show.similar.sin.sinh.skip.smallint.some.specific.specifictype.sql.sqlexception.sqlstate.sqlwarning.sqrt.start.static.stddev_pop.stddev_samp.submultiset.subset.substring.substring_regex.succeeds.sum.symmetric.system.system_time.system_user.table.tablesample.tan.tanh.then.time.timestamp.timezone_hour.timezone_minute.to.trailing.translate.translate_regex.translation.treat.trigger.trim.trim_array.true.truncate.uescape.union.unique.unknown.unnest.update.upper.user.using.value.values.value_of.var_pop.var_samp.varbinary.varchar.varying.versioning.when.whenever.where.width_bucket.window.with.within.without.year".split("."), RESERVED_FUNCTIONS = /* @__PURE__ */ "abs.acos.array_agg.asin.atan.avg.cast.ceil.ceiling.coalesce.corr.cos.cosh.count.covar_pop.covar_samp.cume_dist.dense_rank.deref.element.exp.extract.first_value.floor.json_array.json_arrayagg.json_exists.json_object.json_objectagg.json_query.json_table.json_table_primitive.json_value.lag.last_value.lead.listagg.ln.log.log10.lower.max.min.mod.nth_value.ntile.nullif.percent_rank.percentile_cont.percentile_disc.position.position_regex.power.rank.regr_avgx.regr_avgy.regr_count.regr_intercept.regr_r2.regr_slope.regr_sxx.regr_sxy.regr_syy.row_number.sin.sinh.sqrt.stddev_pop.stddev_samp.substring.substring_regex.sum.tan.tanh.translate.translate_regex.treat.trim.trim_array.unnest.upper.value_of.var_pop.var_samp.width_bucket".split("."), POSSIBLE_WITHOUT_PARENS = [
		"current_catalog",
		"current_date",
		"current_default_transform_group",
		"current_path",
		"current_role",
		"current_schema",
		"current_transform_group_for_type",
		"current_user",
		"session_user",
		"system_time",
		"system_user",
		"current_time",
		"localtime",
		"current_timestamp",
		"localtimestamp"
	], COMBOS = [
		"create table",
		"insert into",
		"primary key",
		"foreign key",
		"not null",
		"alter table",
		"add constraint",
		"grouping sets",
		"on overflow",
		"character set",
		"respect nulls",
		"ignore nulls",
		"nulls first",
		"nulls last",
		"depth first",
		"breadth first"
	], FUNCTIONS = RESERVED_FUNCTIONS, KEYWORDS$2 = [...RESERVED_WORDS, ...NON_RESERVED_WORDS].filter((keyword) => !RESERVED_FUNCTIONS.includes(keyword)), VARIABLE = {
		scope: "variable",
		match: /@[a-z0-9][a-z0-9_]*/
	}, OPERATOR = {
		scope: "operator",
		match: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
		relevance: 0
	}, FUNCTION_CALL = {
		match: regex$1.concat(/\b/, regex$1.either(...FUNCTIONS), /\s*\(/),
		relevance: 0,
		keywords: { built_in: FUNCTIONS }
	};
	function kws_to_regex(list$3) {
		return regex$1.concat(/\b/, regex$1.either(...list$3.map((kw) => kw.replace(/\s+/, "\\s+"))), /\b/);
	}
	let MULTI_WORD_KEYWORDS = {
		scope: "keyword",
		match: kws_to_regex(COMBOS),
		relevance: 0
	};
	function reduceRelevancy(list$3, { exceptions, when } = {}) {
		let qualifyFn = when;
		return exceptions ||= [], list$3.map((item) => item.match(/\|\d+$/) || exceptions.includes(item) ? item : qualifyFn(item) ? `${item}|0` : item);
	}
	return {
		name: "SQL",
		case_insensitive: !0,
		illegal: /[{}]|<\//,
		keywords: {
			$pattern: /\b[\w\.]+/,
			keyword: reduceRelevancy(KEYWORDS$2, { when: (x) => x.length < 3 }),
			literal: LITERALS$2,
			type: TYPES$2,
			built_in: POSSIBLE_WITHOUT_PARENS
		},
		contains: [
			{
				scope: "type",
				match: kws_to_regex(MULTI_WORD_TYPES)
			},
			MULTI_WORD_KEYWORDS,
			FUNCTION_CALL,
			VARIABLE,
			STRING,
			QUOTED_IDENTIFIER,
			hljs.C_NUMBER_MODE,
			hljs.C_BLOCK_COMMENT_MODE,
			COMMENT_MODE,
			OPERATOR
		]
	};
}
function source$1(re$1) {
	return re$1 ? typeof re$1 == "string" ? re$1 : re$1.source : null;
}
function lookahead$1(re$1) {
	return concat$1("(?=", re$1, ")");
}
function concat$1(...args) {
	return args.map((x) => source$1(x)).join("");
}
function stripOptionsFromArgs$1(args) {
	let opts = args[args.length - 1];
	return typeof opts == "object" && opts.constructor === Object ? (args.splice(args.length - 1, 1), opts) : {};
}
function either$1(...args) {
	return "(" + (stripOptionsFromArgs$1(args).capture ? "" : "?:") + args.map((x) => source$1(x)).join("|") + ")";
}
var keywordWrapper = (keyword) => concat$1(/\b/, keyword, /\w$/.test(keyword) ? /\b/ : /\B/), dotKeywords = ["Protocol", "Type"].map(keywordWrapper), optionalDotKeywords = ["init", "self"].map(keywordWrapper), keywordTypes = ["Any", "Self"], keywords = [
	"actor",
	"any",
	"associatedtype",
	"async",
	"await",
	/as\?/,
	/as!/,
	"as",
	"borrowing",
	"break",
	"case",
	"catch",
	"class",
	"consume",
	"consuming",
	"continue",
	"convenience",
	"copy",
	"default",
	"defer",
	"deinit",
	"didSet",
	"distributed",
	"do",
	"dynamic",
	"each",
	"else",
	"enum",
	"extension",
	"fallthrough",
	/fileprivate\(set\)/,
	"fileprivate",
	"final",
	"for",
	"func",
	"get",
	"guard",
	"if",
	"import",
	"indirect",
	"infix",
	/init\?/,
	/init!/,
	"inout",
	/internal\(set\)/,
	"internal",
	"in",
	"is",
	"isolated",
	"nonisolated",
	"lazy",
	"let",
	"macro",
	"mutating",
	"nonmutating",
	/open\(set\)/,
	"open",
	"operator",
	"optional",
	"override",
	"package",
	"postfix",
	"precedencegroup",
	"prefix",
	/private\(set\)/,
	"private",
	"protocol",
	/public\(set\)/,
	"public",
	"repeat",
	"required",
	"rethrows",
	"return",
	"set",
	"some",
	"static",
	"struct",
	"subscript",
	"super",
	"switch",
	"throws",
	"throw",
	/try\?/,
	/try!/,
	"try",
	"typealias",
	/unowned\(safe\)/,
	/unowned\(unsafe\)/,
	"unowned",
	"var",
	"weak",
	"where",
	"while",
	"willSet"
], literals = [
	"false",
	"nil",
	"true"
], precedencegroupKeywords = [
	"assignment",
	"associativity",
	"higherThan",
	"left",
	"lowerThan",
	"none",
	"right"
], numberSignKeywords = [
	"#colorLiteral",
	"#column",
	"#dsohandle",
	"#else",
	"#elseif",
	"#endif",
	"#error",
	"#file",
	"#fileID",
	"#fileLiteral",
	"#filePath",
	"#function",
	"#if",
	"#imageLiteral",
	"#keyPath",
	"#line",
	"#selector",
	"#sourceLocation",
	"#warning"
], builtIns = /* @__PURE__ */ "abs.all.any.assert.assertionFailure.debugPrint.dump.fatalError.getVaList.isKnownUniquelyReferenced.max.min.numericCast.pointwiseMax.pointwiseMin.precondition.preconditionFailure.print.readLine.repeatElement.sequence.stride.swap.swift_unboxFromSwiftValueWithType.transcode.type.unsafeBitCast.unsafeDowncast.withExtendedLifetime.withUnsafeMutablePointer.withUnsafePointer.withVaList.withoutActuallyEscaping.zip".split("."), operatorHead = either$1(/[/=\-+!*%<>&|^~?]/, /[\u00A1-\u00A7]/, /[\u00A9\u00AB]/, /[\u00AC\u00AE]/, /[\u00B0\u00B1]/, /[\u00B6\u00BB\u00BF\u00D7\u00F7]/, /[\u2016-\u2017]/, /[\u2020-\u2027]/, /[\u2030-\u203E]/, /[\u2041-\u2053]/, /[\u2055-\u205E]/, /[\u2190-\u23FF]/, /[\u2500-\u2775]/, /[\u2794-\u2BFF]/, /[\u2E00-\u2E7F]/, /[\u3001-\u3003]/, /[\u3008-\u3020]/, /[\u3030]/), operatorCharacter = either$1(operatorHead, /[\u0300-\u036F]/, /[\u1DC0-\u1DFF]/, /[\u20D0-\u20FF]/, /[\uFE00-\uFE0F]/, /[\uFE20-\uFE2F]/), operator = concat$1(operatorHead, operatorCharacter, "*"), identifierHead = either$1(/[a-zA-Z_]/, /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/, /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/, /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/, /[\u1E00-\u1FFF]/, /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/, /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/, /[\u2C00-\u2DFF\u2E80-\u2FFF]/, /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/, /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/, /[\uFE47-\uFEFE\uFF00-\uFFFD]/), identifierCharacter = either$1(identifierHead, /\d/, /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/), identifier = concat$1(identifierHead, identifierCharacter, "*"), typeIdentifier = concat$1(/[A-Z]/, identifierCharacter, "*"), keywordAttributes = [
	"attached",
	"autoclosure",
	concat$1(/convention\(/, either$1("swift", "block", "c"), /\)/),
	"discardableResult",
	"dynamicCallable",
	"dynamicMemberLookup",
	"escaping",
	"freestanding",
	"frozen",
	"GKInspectable",
	"IBAction",
	"IBDesignable",
	"IBInspectable",
	"IBOutlet",
	"IBSegueAction",
	"inlinable",
	"main",
	"nonobjc",
	"NSApplicationMain",
	"NSCopying",
	"NSManaged",
	concat$1(/objc\(/, identifier, /\)/),
	"objc",
	"objcMembers",
	"propertyWrapper",
	"requires_stored_property_inits",
	"resultBuilder",
	"Sendable",
	"testable",
	"UIApplicationMain",
	"unchecked",
	"unknown",
	"usableFromInline",
	"warn_unqualified_access"
], availabilityKeywords = [
	"iOS",
	"iOSApplicationExtension",
	"macOS",
	"macOSApplicationExtension",
	"macCatalyst",
	"macCatalystApplicationExtension",
	"watchOS",
	"watchOSApplicationExtension",
	"tvOS",
	"tvOSApplicationExtension",
	"swift"
];
function swift(hljs) {
	let WHITESPACE = {
		match: /\s+/,
		relevance: 0
	}, BLOCK_COMMENT = hljs.COMMENT("/\\*", "\\*/", { contains: ["self"] }), COMMENTS = [hljs.C_LINE_COMMENT_MODE, BLOCK_COMMENT], DOT_KEYWORD = {
		match: [/\./, either$1(...dotKeywords, ...optionalDotKeywords)],
		className: { 2: "keyword" }
	}, KEYWORD_GUARD = {
		match: concat$1(/\./, either$1(...keywords)),
		relevance: 0
	}, PLAIN_KEYWORDS = keywords.filter((kw) => typeof kw == "string").concat(["_|0"]), KEYWORD = { variants: [{
		className: "keyword",
		match: either$1(...keywords.filter((kw) => typeof kw != "string").concat(keywordTypes).map(keywordWrapper), ...optionalDotKeywords)
	}] }, KEYWORDS$2 = {
		$pattern: either$1(/\b\w+/, /#\w+/),
		keyword: PLAIN_KEYWORDS.concat(numberSignKeywords),
		literal: literals
	}, KEYWORD_MODES = [
		DOT_KEYWORD,
		KEYWORD_GUARD,
		KEYWORD
	], BUILT_INS$2 = [{
		match: concat$1(/\./, either$1(...builtIns)),
		relevance: 0
	}, {
		className: "built_in",
		match: concat$1(/\b/, either$1(...builtIns), /(?=\()/)
	}], OPERATOR_GUARD = {
		match: /->/,
		relevance: 0
	}, OPERATORS = [OPERATOR_GUARD, {
		className: "operator",
		relevance: 0,
		variants: [{ match: operator }, { match: `\\.(\\.|${operatorCharacter})+` }]
	}], decimalDigits$2 = "([0-9]_*)+", hexDigits$2 = "([0-9a-fA-F]_*)+", NUMBER = {
		className: "number",
		relevance: 0,
		variants: [
			{ match: `\\b(${decimalDigits$2})(\\.(${decimalDigits$2}))?([eE][+-]?(${decimalDigits$2}))?\\b` },
			{ match: `\\b0x(${hexDigits$2})(\\.(${hexDigits$2}))?([pP][+-]?(${decimalDigits$2}))?\\b` },
			{ match: /\b0o([0-7]_*)+\b/ },
			{ match: /\b0b([01]_*)+\b/ }
		]
	}, ESCAPED_CHARACTER = (rawDelimiter = "") => ({
		className: "subst",
		variants: [{ match: concat$1(/\\/, rawDelimiter, /[0\\tnr"']/) }, { match: concat$1(/\\/, rawDelimiter, /u\{[0-9a-fA-F]{1,8}\}/) }]
	}), ESCAPED_NEWLINE = (rawDelimiter = "") => ({
		className: "subst",
		match: concat$1(/\\/, rawDelimiter, /[\t ]*(?:[\r\n]|\r\n)/)
	}), INTERPOLATION = (rawDelimiter = "") => ({
		className: "subst",
		label: "interpol",
		begin: concat$1(/\\/, rawDelimiter, /\(/),
		end: /\)/
	}), MULTILINE_STRING = (rawDelimiter = "") => ({
		begin: concat$1(rawDelimiter, /"""/),
		end: concat$1(/"""/, rawDelimiter),
		contains: [
			ESCAPED_CHARACTER(rawDelimiter),
			ESCAPED_NEWLINE(rawDelimiter),
			INTERPOLATION(rawDelimiter)
		]
	}), SINGLE_LINE_STRING = (rawDelimiter = "") => ({
		begin: concat$1(rawDelimiter, /"/),
		end: concat$1(/"/, rawDelimiter),
		contains: [ESCAPED_CHARACTER(rawDelimiter), INTERPOLATION(rawDelimiter)]
	}), STRING = {
		className: "string",
		variants: [
			MULTILINE_STRING(),
			MULTILINE_STRING("#"),
			MULTILINE_STRING("##"),
			MULTILINE_STRING("###"),
			SINGLE_LINE_STRING(),
			SINGLE_LINE_STRING("#"),
			SINGLE_LINE_STRING("##"),
			SINGLE_LINE_STRING("###")
		]
	}, REGEXP_CONTENTS = [hljs.BACKSLASH_ESCAPE, {
		begin: /\[/,
		end: /\]/,
		relevance: 0,
		contains: [hljs.BACKSLASH_ESCAPE]
	}], BARE_REGEXP_LITERAL = {
		begin: /\/[^\s](?=[^/\n]*\/)/,
		end: /\//,
		contains: REGEXP_CONTENTS
	}, EXTENDED_REGEXP_LITERAL = (rawDelimiter) => {
		let begin = concat$1(rawDelimiter, /\//), end = concat$1(/\//, rawDelimiter);
		return {
			begin,
			end,
			contains: [...REGEXP_CONTENTS, {
				scope: "comment",
				begin: `#(?!.*${end})`,
				end: /$/
			}]
		};
	}, REGEXP$1 = {
		scope: "regexp",
		variants: [
			EXTENDED_REGEXP_LITERAL("###"),
			EXTENDED_REGEXP_LITERAL("##"),
			EXTENDED_REGEXP_LITERAL("#"),
			BARE_REGEXP_LITERAL
		]
	}, QUOTED_IDENTIFIER = { match: concat$1(/`/, identifier, /`/) }, IDENTIFIERS = [
		QUOTED_IDENTIFIER,
		{
			className: "variable",
			match: /\$\d+/
		},
		{
			className: "variable",
			match: `\\$${identifierCharacter}+`
		}
	], ATTRIBUTES$3 = [
		{
			match: /(@|#(un)?)available/,
			scope: "keyword",
			starts: { contains: [{
				begin: /\(/,
				end: /\)/,
				keywords: availabilityKeywords,
				contains: [
					...OPERATORS,
					NUMBER,
					STRING
				]
			}] }
		},
		{
			scope: "keyword",
			match: concat$1(/@/, either$1(...keywordAttributes), lookahead$1(either$1(/\(/, /\s+/)))
		},
		{
			scope: "meta",
			match: concat$1(/@/, identifier)
		}
	], TYPE = {
		match: lookahead$1(/\b[A-Z]/),
		relevance: 0,
		contains: [
			{
				className: "type",
				match: concat$1(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, identifierCharacter, "+")
			},
			{
				className: "type",
				match: typeIdentifier,
				relevance: 0
			},
			{
				match: /[?!]+/,
				relevance: 0
			},
			{
				match: /\.\.\./,
				relevance: 0
			},
			{
				match: concat$1(/\s+&\s+/, lookahead$1(typeIdentifier)),
				relevance: 0
			}
		]
	}, GENERIC_ARGUMENTS = {
		begin: /</,
		end: />/,
		keywords: KEYWORDS$2,
		contains: [
			...COMMENTS,
			...KEYWORD_MODES,
			...ATTRIBUTES$3,
			OPERATOR_GUARD,
			TYPE
		]
	};
	TYPE.contains.push(GENERIC_ARGUMENTS);
	let TUPLE = {
		begin: /\(/,
		end: /\)/,
		relevance: 0,
		keywords: KEYWORDS$2,
		contains: [
			"self",
			{
				match: concat$1(identifier, /\s*:/),
				keywords: "_|0",
				relevance: 0
			},
			...COMMENTS,
			REGEXP$1,
			...KEYWORD_MODES,
			...BUILT_INS$2,
			...OPERATORS,
			NUMBER,
			STRING,
			...IDENTIFIERS,
			...ATTRIBUTES$3,
			TYPE
		]
	}, GENERIC_PARAMETERS = {
		begin: /</,
		end: />/,
		keywords: "repeat each",
		contains: [...COMMENTS, TYPE]
	}, FUNCTION_PARAMETERS = {
		begin: /\(/,
		end: /\)/,
		keywords: KEYWORDS$2,
		contains: [
			{
				begin: either$1(lookahead$1(concat$1(identifier, /\s*:/)), lookahead$1(concat$1(identifier, /\s+/, identifier, /\s*:/))),
				end: /:/,
				relevance: 0,
				contains: [{
					className: "keyword",
					match: /\b_\b/
				}, {
					className: "params",
					match: identifier
				}]
			},
			...COMMENTS,
			...KEYWORD_MODES,
			...OPERATORS,
			NUMBER,
			STRING,
			...ATTRIBUTES$3,
			TYPE,
			TUPLE
		],
		endsParent: !0,
		illegal: /["']/
	}, FUNCTION_OR_MACRO = {
		match: [
			/(func|macro)/,
			/\s+/,
			either$1(QUOTED_IDENTIFIER.match, identifier, operator)
		],
		className: {
			1: "keyword",
			3: "title.function"
		},
		contains: [
			GENERIC_PARAMETERS,
			FUNCTION_PARAMETERS,
			WHITESPACE
		],
		illegal: [/\[/, /%/]
	}, INIT_SUBSCRIPT = {
		match: [/\b(?:subscript|init[?!]?)/, /\s*(?=[<(])/],
		className: { 1: "keyword" },
		contains: [
			GENERIC_PARAMETERS,
			FUNCTION_PARAMETERS,
			WHITESPACE
		],
		illegal: /\[|%/
	}, OPERATOR_DECLARATION = {
		match: [
			/operator/,
			/\s+/,
			operator
		],
		className: {
			1: "keyword",
			3: "title"
		}
	}, PRECEDENCEGROUP = {
		begin: [
			/precedencegroup/,
			/\s+/,
			typeIdentifier
		],
		className: {
			1: "keyword",
			3: "title"
		},
		contains: [TYPE],
		keywords: [...precedencegroupKeywords, ...literals],
		end: /}/
	}, CLASS_FUNC_DECLARATION = {
		match: [
			/class\b/,
			/\s+/,
			/func\b/,
			/\s+/,
			/\b[A-Za-z_][A-Za-z0-9_]*\b/
		],
		scope: {
			1: "keyword",
			3: "keyword",
			5: "title.function"
		}
	}, CLASS_VAR_DECLARATION = {
		match: [
			/class\b/,
			/\s+/,
			/var\b/
		],
		scope: {
			1: "keyword",
			3: "keyword"
		}
	}, TYPE_DECLARATION$1 = {
		begin: [
			/(struct|protocol|class|extension|enum|actor)/,
			/\s+/,
			identifier,
			/\s*/
		],
		beginScope: {
			1: "keyword",
			3: "title.class"
		},
		keywords: KEYWORDS$2,
		contains: [
			GENERIC_PARAMETERS,
			...KEYWORD_MODES,
			{
				begin: /:/,
				end: /\{/,
				keywords: KEYWORDS$2,
				contains: [{
					scope: "title.class.inherited",
					match: typeIdentifier
				}, ...KEYWORD_MODES],
				relevance: 0
			}
		]
	};
	for (let variant of STRING.variants) {
		let interpolation = variant.contains.find((mode) => mode.label === "interpol");
		interpolation.keywords = KEYWORDS$2;
		let submodes = [
			...KEYWORD_MODES,
			...BUILT_INS$2,
			...OPERATORS,
			NUMBER,
			STRING,
			...IDENTIFIERS
		];
		interpolation.contains = [...submodes, {
			begin: /\(/,
			end: /\)/,
			contains: ["self", ...submodes]
		}];
	}
	return {
		name: "Swift",
		keywords: KEYWORDS$2,
		contains: [
			...COMMENTS,
			FUNCTION_OR_MACRO,
			INIT_SUBSCRIPT,
			CLASS_FUNC_DECLARATION,
			CLASS_VAR_DECLARATION,
			TYPE_DECLARATION$1,
			OPERATOR_DECLARATION,
			PRECEDENCEGROUP,
			{
				beginKeywords: "import",
				end: /$/,
				contains: [...COMMENTS],
				relevance: 0
			},
			REGEXP$1,
			...KEYWORD_MODES,
			...BUILT_INS$2,
			...OPERATORS,
			NUMBER,
			STRING,
			...IDENTIFIERS,
			...ATTRIBUTES$3,
			TYPE,
			TUPLE
		]
	};
}
var IDENT_RE$1 = "[A-Za-z$_][0-9A-Za-z$_]*", KEYWORDS = /* @__PURE__ */ "as.in.of.if.for.while.finally.var.new.function.do.return.void.else.break.catch.instanceof.with.throw.case.default.try.switch.continue.typeof.delete.let.yield.const.class.debugger.async.await.static.import.from.export.extends.using".split("."), LITERALS = [
	"true",
	"false",
	"null",
	"undefined",
	"NaN",
	"Infinity"
], TYPES = /* @__PURE__ */ "Object.Function.Boolean.Symbol.Math.Date.Number.BigInt.String.RegExp.Array.Float32Array.Float64Array.Int8Array.Uint8Array.Uint8ClampedArray.Int16Array.Int32Array.Uint16Array.Uint32Array.BigInt64Array.BigUint64Array.Set.Map.WeakSet.WeakMap.ArrayBuffer.SharedArrayBuffer.Atomics.DataView.JSON.Promise.Generator.GeneratorFunction.AsyncFunction.Reflect.Proxy.Intl.WebAssembly".split("."), ERROR_TYPES = [
	"Error",
	"EvalError",
	"InternalError",
	"RangeError",
	"ReferenceError",
	"SyntaxError",
	"TypeError",
	"URIError"
], BUILT_IN_GLOBALS = [
	"setInterval",
	"setTimeout",
	"clearInterval",
	"clearTimeout",
	"require",
	"exports",
	"eval",
	"isFinite",
	"isNaN",
	"parseFloat",
	"parseInt",
	"decodeURI",
	"decodeURIComponent",
	"encodeURI",
	"encodeURIComponent",
	"escape",
	"unescape"
], BUILT_IN_VARIABLES = [
	"arguments",
	"this",
	"super",
	"console",
	"window",
	"document",
	"localStorage",
	"sessionStorage",
	"module",
	"global"
], BUILT_INS = [].concat(BUILT_IN_GLOBALS, TYPES, ERROR_TYPES);
function javascript$1(hljs) {
	let regex$1 = hljs.regex, hasClosingTag = (match, { after }) => {
		let tag = "</" + match[0].slice(1);
		return match.input.indexOf(tag, after) !== -1;
	}, IDENT_RE$1$1 = IDENT_RE$1, FRAGMENT = {
		begin: "<>",
		end: "</>"
	}, XML_SELF_CLOSING = /<[A-Za-z0-9\\._:-]+\s*\/>/, XML_TAG = {
		begin: /<[A-Za-z0-9\\._:-]+/,
		end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
		isTrulyOpeningTag: (match, response) => {
			let afterMatchIndex = match[0].length + match.index, nextChar = match.input[afterMatchIndex];
			if (nextChar === "<" || nextChar === ",") {
				response.ignoreMatch();
				return;
			}
			nextChar === ">" && (hasClosingTag(match, { after: afterMatchIndex }) || response.ignoreMatch());
			let m, afterMatch = match.input.substring(afterMatchIndex);
			if (m = afterMatch.match(/^\s*=/)) {
				response.ignoreMatch();
				return;
			}
			if ((m = afterMatch.match(/^\s+extends\s+/)) && m.index === 0) {
				response.ignoreMatch();
				return;
			}
		}
	}, KEYWORDS$1$1 = {
		$pattern: IDENT_RE$1,
		keyword: KEYWORDS,
		literal: LITERALS,
		built_in: BUILT_INS,
		"variable.language": BUILT_IN_VARIABLES
	}, decimalDigits$2 = "[0-9](_?[0-9])*", frac$2 = `\\.(${decimalDigits$2})`, decimalInteger = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", NUMBER = {
		className: "number",
		variants: [
			{ begin: `(\\b(${decimalInteger})((${frac$2})|\\.)?|(${frac$2}))[eE][+-]?(${decimalDigits$2})\\b` },
			{ begin: `\\b(${decimalInteger})\\b((${frac$2})\\b|\\.)?|(${frac$2})\\b` },
			{ begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
			{ begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
			{ begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
			{ begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
			{ begin: "\\b0[0-7]+n?\\b" }
		],
		relevance: 0
	}, SUBST = {
		className: "subst",
		begin: "\\$\\{",
		end: "\\}",
		keywords: KEYWORDS$1$1,
		contains: []
	}, HTML_TEMPLATE = {
		begin: ".?html`",
		end: "",
		starts: {
			end: "`",
			returnEnd: !1,
			contains: [hljs.BACKSLASH_ESCAPE, SUBST],
			subLanguage: "xml"
		}
	}, CSS_TEMPLATE = {
		begin: ".?css`",
		end: "",
		starts: {
			end: "`",
			returnEnd: !1,
			contains: [hljs.BACKSLASH_ESCAPE, SUBST],
			subLanguage: "css"
		}
	}, GRAPHQL_TEMPLATE = {
		begin: ".?gql`",
		end: "",
		starts: {
			end: "`",
			returnEnd: !1,
			contains: [hljs.BACKSLASH_ESCAPE, SUBST],
			subLanguage: "graphql"
		}
	}, TEMPLATE_STRING = {
		className: "string",
		begin: "`",
		end: "`",
		contains: [hljs.BACKSLASH_ESCAPE, SUBST]
	}, COMMENT$1 = {
		className: "comment",
		variants: [
			hljs.COMMENT(/\/\*\*(?!\/)/, "\\*/", {
				relevance: 0,
				contains: [{
					begin: "(?=@[A-Za-z]+)",
					relevance: 0,
					contains: [
						{
							className: "doctag",
							begin: "@[A-Za-z]+"
						},
						{
							className: "type",
							begin: "\\{",
							end: "\\}",
							excludeEnd: !0,
							excludeBegin: !0,
							relevance: 0
						},
						{
							className: "variable",
							begin: IDENT_RE$1$1 + "(?=\\s*(-)|$)",
							endsParent: !0,
							relevance: 0
						},
						{
							begin: /(?=[^\n])\s/,
							relevance: 0
						}
					]
				}]
			}),
			hljs.C_BLOCK_COMMENT_MODE,
			hljs.C_LINE_COMMENT_MODE
		]
	}, SUBST_INTERNALS = [
		hljs.APOS_STRING_MODE,
		hljs.QUOTE_STRING_MODE,
		HTML_TEMPLATE,
		CSS_TEMPLATE,
		GRAPHQL_TEMPLATE,
		TEMPLATE_STRING,
		{ match: /\$\d+/ },
		NUMBER
	];
	SUBST.contains = SUBST_INTERNALS.concat({
		begin: /\{/,
		end: /\}/,
		keywords: KEYWORDS$1$1,
		contains: ["self"].concat(SUBST_INTERNALS)
	});
	let SUBST_AND_COMMENTS = [].concat(COMMENT$1, SUBST.contains), PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([{
		begin: /(\s*)\(/,
		end: /\)/,
		keywords: KEYWORDS$1$1,
		contains: ["self"].concat(SUBST_AND_COMMENTS)
	}]), PARAMS = {
		className: "params",
		begin: /(\s*)\(/,
		end: /\)/,
		excludeBegin: !0,
		excludeEnd: !0,
		keywords: KEYWORDS$1$1,
		contains: PARAMS_CONTAINS
	}, CLASS_OR_EXTENDS = { variants: [{
		match: [
			/class/,
			/\s+/,
			IDENT_RE$1$1,
			/\s+/,
			/extends/,
			/\s+/,
			regex$1.concat(IDENT_RE$1$1, "(", regex$1.concat(/\./, IDENT_RE$1$1), ")*")
		],
		scope: {
			1: "keyword",
			3: "title.class",
			5: "keyword",
			7: "title.class.inherited"
		}
	}, {
		match: [
			/class/,
			/\s+/,
			IDENT_RE$1$1
		],
		scope: {
			1: "keyword",
			3: "title.class"
		}
	}] }, CLASS_REFERENCE = {
		relevance: 0,
		match: regex$1.either(/\bJSON/, /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/, /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/, /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/),
		className: "title.class",
		keywords: { _: [...TYPES, ...ERROR_TYPES] }
	}, USE_STRICT = {
		label: "use_strict",
		className: "meta",
		relevance: 10,
		begin: /^\s*['"]use (strict|asm)['"]/
	}, FUNCTION_DEFINITION = {
		variants: [{ match: [
			/function/,
			/\s+/,
			IDENT_RE$1$1,
			/(?=\s*\()/
		] }, { match: [/function/, /\s*(?=\()/] }],
		className: {
			1: "keyword",
			3: "title.function"
		},
		label: "func.def",
		contains: [PARAMS],
		illegal: /%/
	}, UPPER_CASE_CONSTANT = {
		relevance: 0,
		match: /\b[A-Z][A-Z_0-9]+\b/,
		className: "variable.constant"
	};
	function noneOf(list$3) {
		return regex$1.concat("(?!", list$3.join("|"), ")");
	}
	let FUNCTION_CALL = {
		match: regex$1.concat(/\b/, noneOf([
			...BUILT_IN_GLOBALS,
			"super",
			"import"
		].map((x) => `${x}\\s*\\(`)), IDENT_RE$1$1, regex$1.lookahead(/\s*\(/)),
		className: "title.function",
		relevance: 0
	}, PROPERTY_ACCESS = {
		begin: regex$1.concat(/\./, regex$1.lookahead(regex$1.concat(IDENT_RE$1$1, /(?![0-9A-Za-z$_(])/))),
		end: IDENT_RE$1$1,
		excludeBegin: !0,
		keywords: "prototype",
		className: "property",
		relevance: 0
	}, GETTER_OR_SETTER = {
		match: [
			/get|set/,
			/\s+/,
			IDENT_RE$1$1,
			/(?=\()/
		],
		className: {
			1: "keyword",
			3: "title.function"
		},
		contains: [{ begin: /\(\)/ }, PARAMS]
	}, FUNC_LEAD_IN_RE = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + hljs.UNDERSCORE_IDENT_RE + ")\\s*=>", FUNCTION_VARIABLE = {
		match: [
			/const|var|let/,
			/\s+/,
			IDENT_RE$1$1,
			/\s*/,
			/=\s*/,
			/(async\s*)?/,
			regex$1.lookahead(FUNC_LEAD_IN_RE)
		],
		keywords: "async",
		className: {
			1: "keyword",
			3: "title.function"
		},
		contains: [PARAMS]
	};
	return {
		name: "JavaScript",
		aliases: [
			"js",
			"jsx",
			"mjs",
			"cjs"
		],
		keywords: KEYWORDS$1$1,
		exports: {
			PARAMS_CONTAINS,
			CLASS_REFERENCE
		},
		illegal: /#(?![$_A-z])/,
		contains: [
			hljs.SHEBANG({
				label: "shebang",
				binary: "node",
				relevance: 5
			}),
			USE_STRICT,
			hljs.APOS_STRING_MODE,
			hljs.QUOTE_STRING_MODE,
			HTML_TEMPLATE,
			CSS_TEMPLATE,
			GRAPHQL_TEMPLATE,
			TEMPLATE_STRING,
			COMMENT$1,
			{ match: /\$\d+/ },
			NUMBER,
			CLASS_REFERENCE,
			{
				scope: "attr",
				match: IDENT_RE$1$1 + regex$1.lookahead(":"),
				relevance: 0
			},
			FUNCTION_VARIABLE,
			{
				begin: "(" + hljs.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
				keywords: "return throw case",
				relevance: 0,
				contains: [
					COMMENT$1,
					hljs.REGEXP_MODE,
					{
						className: "function",
						begin: FUNC_LEAD_IN_RE,
						returnBegin: !0,
						end: "\\s*=>",
						contains: [{
							className: "params",
							variants: [
								{
									begin: hljs.UNDERSCORE_IDENT_RE,
									relevance: 0
								},
								{
									className: null,
									begin: /\(\s*\)/,
									skip: !0
								},
								{
									begin: /(\s*)\(/,
									end: /\)/,
									excludeBegin: !0,
									excludeEnd: !0,
									keywords: KEYWORDS$1$1,
									contains: PARAMS_CONTAINS
								}
							]
						}]
					},
					{
						begin: /,/,
						relevance: 0
					},
					{
						match: /\s+/,
						relevance: 0
					},
					{
						variants: [
							{
								begin: FRAGMENT.begin,
								end: FRAGMENT.end
							},
							{ match: XML_SELF_CLOSING },
							{
								begin: XML_TAG.begin,
								"on:begin": XML_TAG.isTrulyOpeningTag,
								end: XML_TAG.end
							}
						],
						subLanguage: "xml",
						contains: [{
							begin: XML_TAG.begin,
							end: XML_TAG.end,
							skip: !0,
							contains: ["self"]
						}]
					}
				]
			},
			FUNCTION_DEFINITION,
			{ beginKeywords: "while if switch catch for" },
			{
				begin: "\\b(?!function)" + hljs.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
				returnBegin: !0,
				label: "func.def",
				contains: [PARAMS, hljs.inherit(hljs.TITLE_MODE, {
					begin: IDENT_RE$1$1,
					className: "title.function"
				})]
			},
			{
				match: /\.\.\./,
				relevance: 0
			},
			PROPERTY_ACCESS,
			{
				match: "\\$" + IDENT_RE$1$1,
				relevance: 0
			},
			{
				match: [/\bconstructor(?=\s*\()/],
				className: { 1: "title.function" },
				contains: [PARAMS]
			},
			FUNCTION_CALL,
			UPPER_CASE_CONSTANT,
			CLASS_OR_EXTENDS,
			GETTER_OR_SETTER,
			{ match: /\$[(.]/ }
		]
	};
}
function typescript(hljs) {
	let regex$1 = hljs.regex, tsLanguage = javascript$1(hljs), IDENT_RE$1$1 = IDENT_RE$1, TYPES$2 = [
		"any",
		"void",
		"number",
		"boolean",
		"string",
		"object",
		"never",
		"symbol",
		"bigint",
		"unknown"
	], NAMESPACE = {
		begin: [
			/namespace/,
			/\s+/,
			hljs.IDENT_RE
		],
		beginScope: {
			1: "keyword",
			3: "title.class"
		}
	}, INTERFACE = {
		beginKeywords: "interface",
		end: /\{/,
		excludeEnd: !0,
		keywords: {
			keyword: "interface extends",
			built_in: TYPES$2
		},
		contains: [tsLanguage.exports.CLASS_REFERENCE]
	}, USE_STRICT = {
		className: "meta",
		relevance: 10,
		begin: /^\s*['"]use strict['"]/
	}, KEYWORDS$1$1 = {
		$pattern: IDENT_RE$1,
		keyword: KEYWORDS.concat([
			"type",
			"interface",
			"public",
			"private",
			"protected",
			"implements",
			"declare",
			"abstract",
			"readonly",
			"enum",
			"override",
			"satisfies"
		]),
		literal: LITERALS,
		built_in: BUILT_INS.concat(TYPES$2),
		"variable.language": BUILT_IN_VARIABLES
	}, DECORATOR = {
		className: "meta",
		begin: "@" + IDENT_RE$1$1
	}, swapMode = (mode, label, replacement) => {
		let indx = mode.contains.findIndex((m) => m.label === label);
		if (indx === -1) throw Error("can not find mode to replace");
		mode.contains.splice(indx, 1, replacement);
	};
	Object.assign(tsLanguage.keywords, KEYWORDS$1$1), tsLanguage.exports.PARAMS_CONTAINS.push(DECORATOR);
	let ATTRIBUTE_HIGHLIGHT = tsLanguage.contains.find((c$1) => c$1.scope === "attr"), OPTIONAL_KEY_OR_ARGUMENT = Object.assign({}, ATTRIBUTE_HIGHLIGHT, { match: regex$1.concat(IDENT_RE$1$1, regex$1.lookahead(/\s*\?:/)) });
	tsLanguage.exports.PARAMS_CONTAINS.push([
		tsLanguage.exports.CLASS_REFERENCE,
		ATTRIBUTE_HIGHLIGHT,
		OPTIONAL_KEY_OR_ARGUMENT
	]), tsLanguage.contains = tsLanguage.contains.concat([
		DECORATOR,
		NAMESPACE,
		INTERFACE,
		OPTIONAL_KEY_OR_ARGUMENT
	]), swapMode(tsLanguage, "shebang", hljs.SHEBANG()), swapMode(tsLanguage, "use_strict", USE_STRICT);
	let functionDeclaration = tsLanguage.contains.find((m) => m.label === "func.def");
	return functionDeclaration.relevance = 0, Object.assign(tsLanguage, {
		name: "TypeScript",
		aliases: [
			"ts",
			"tsx",
			"mts",
			"cts"
		]
	}), tsLanguage;
}
function vbnet(hljs) {
	let regex$1 = hljs.regex, CHARACTER = {
		className: "string",
		begin: /"(""|[^/n])"C\b/
	}, STRING = {
		className: "string",
		begin: /"/,
		end: /"/,
		illegal: /\n/,
		contains: [{ begin: /""/ }]
	}, MM_DD_YYYY = /\d{1,2}\/\d{1,2}\/\d{4}/, YYYY_MM_DD = /\d{4}-\d{1,2}-\d{1,2}/, TIME_12H = /(\d|1[012])(:\d+){0,2} *(AM|PM)/, TIME_24H = /\d{1,2}(:\d{1,2}){1,2}/, DATE$1 = {
		className: "literal",
		variants: [
			{ begin: regex$1.concat(/# */, regex$1.either(YYYY_MM_DD, MM_DD_YYYY), / *#/) },
			{ begin: regex$1.concat(/# */, TIME_24H, / *#/) },
			{ begin: regex$1.concat(/# */, TIME_12H, / *#/) },
			{ begin: regex$1.concat(/# */, regex$1.either(YYYY_MM_DD, MM_DD_YYYY), / +/, regex$1.either(TIME_12H, TIME_24H), / *#/) }
		]
	}, NUMBER = {
		className: "number",
		relevance: 0,
		variants: [
			{ begin: /\b\d[\d_]*((\.[\d_]+(E[+-]?[\d_]+)?)|(E[+-]?[\d_]+))[RFD@!#]?/ },
			{ begin: /\b\d[\d_]*((U?[SIL])|[%&])?/ },
			{ begin: /&H[\dA-F_]+((U?[SIL])|[%&])?/ },
			{ begin: /&O[0-7_]+((U?[SIL])|[%&])?/ },
			{ begin: /&B[01_]+((U?[SIL])|[%&])?/ }
		]
	}, LABEL = {
		className: "label",
		begin: /^\w+:/
	}, DOC_COMMENT = hljs.COMMENT(/'''/, /$/, { contains: [{
		className: "doctag",
		begin: /<\/?/,
		end: />/
	}] }), COMMENT$1 = hljs.COMMENT(null, /$/, { variants: [{ begin: /'/ }, { begin: /([\t ]|^)REM(?=\s)/ }] });
	return {
		name: "Visual Basic .NET",
		aliases: ["vb"],
		case_insensitive: !0,
		classNameAliases: { label: "symbol" },
		keywords: {
			keyword: "addhandler alias aggregate ansi as async assembly auto binary by byref byval call case catch class compare const continue custom declare default delegate dim distinct do each equals else elseif end enum erase error event exit explicit finally for friend from function get global goto group handles if implements imports in inherits interface into iterator join key let lib loop me mid module mustinherit mustoverride mybase myclass namespace narrowing new next notinheritable notoverridable of off on operator option optional order overloads overridable overrides paramarray partial preserve private property protected public raiseevent readonly redim removehandler resume return select set shadows shared skip static step stop structure strict sub synclock take text then throw to try unicode until using when where while widening with withevents writeonly yield",
			built_in: "addressof and andalso await directcast gettype getxmlnamespace is isfalse isnot istrue like mod nameof new not or orelse trycast typeof xor cbool cbyte cchar cdate cdbl cdec cint clng cobj csbyte cshort csng cstr cuint culng cushort",
			type: "boolean byte char date decimal double integer long object sbyte short single string uinteger ulong ushort",
			literal: "true false nothing"
		},
		illegal: "//|\\{|\\}|endif|gosub|variant|wend|^\\$ ",
		contains: [
			CHARACTER,
			STRING,
			DATE$1,
			NUMBER,
			LABEL,
			DOC_COMMENT,
			COMMENT$1,
			{
				className: "meta",
				begin: /[\t ]*#(const|disable|else|elseif|enable|end|externalsource|if|region)\b/,
				end: /$/,
				keywords: { keyword: "const disable else elseif enable end externalsource if region then" },
				contains: [COMMENT$1]
			}
		]
	};
}
function wasm(hljs) {
	hljs.regex;
	let BLOCK_COMMENT = hljs.COMMENT(/\(;/, /;\)/);
	BLOCK_COMMENT.contains.push("self");
	let LINE_COMMENT = hljs.COMMENT(/;;/, /$/), KWS = /* @__PURE__ */ "anyfunc,block,br,br_if,br_table,call,call_indirect,data,drop,elem,else,end,export,func,global.get,global.set,local.get,local.set,local.tee,get_global,get_local,global,if,import,local,loop,memory,memory.grow,memory.size,module,mut,nop,offset,param,result,return,select,set_global,set_local,start,table,tee_local,then,type,unreachable".split(","), FUNCTION_REFERENCE = {
		begin: [
			/(?:func|call|call_indirect)/,
			/\s+/,
			/\$[^\s)]+/
		],
		className: {
			1: "keyword",
			3: "title.function"
		}
	}, ARGUMENT = {
		className: "variable",
		begin: /\$[\w_]+/
	}, PARENS = {
		match: /(\((?!;)|\))+/,
		className: "punctuation",
		relevance: 0
	}, NUMBER = {
		className: "number",
		relevance: 0,
		match: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/
	}, TYPE = {
		match: /(i32|i64|f32|f64)(?!\.)/,
		className: "type"
	}, MATH_OPERATIONS = {
		className: "keyword",
		match: /\b(f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|nearest|neg?|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|store(?:8|16|32)?|sqrt|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))\b/
	};
	return {
		name: "WebAssembly",
		keywords: {
			$pattern: /[\w.]+/,
			keyword: KWS
		},
		contains: [
			LINE_COMMENT,
			BLOCK_COMMENT,
			{
				match: [
					/(?:offset|align)/,
					/\s*/,
					/=/
				],
				className: {
					1: "keyword",
					3: "operator"
				}
			},
			ARGUMENT,
			PARENS,
			FUNCTION_REFERENCE,
			hljs.QUOTE_STRING_MODE,
			TYPE,
			MATH_OPERATIONS,
			NUMBER
		]
	};
}
function xml(hljs) {
	let regex$1 = hljs.regex, TAG_NAME_RE = regex$1.concat(/[\p{L}_]/u, regex$1.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u), XML_IDENT_RE = /[\p{L}0-9._:-]+/u, XML_ENTITIES = {
		className: "symbol",
		begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
	}, XML_META_KEYWORDS = {
		begin: /\s/,
		contains: [{
			className: "keyword",
			begin: /#?[a-z_][a-z1-9_-]+/,
			illegal: /\n/
		}]
	}, XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {
		begin: /\(/,
		end: /\)/
	}), APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, { className: "string" }), QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, { className: "string" }), TAG_INTERNALS = {
		endsWithParent: !0,
		illegal: /</,
		relevance: 0,
		contains: [{
			className: "attr",
			begin: XML_IDENT_RE,
			relevance: 0
		}, {
			begin: /=\s*/,
			relevance: 0,
			contains: [{
				className: "string",
				endsParent: !0,
				variants: [
					{
						begin: /"/,
						end: /"/,
						contains: [XML_ENTITIES]
					},
					{
						begin: /'/,
						end: /'/,
						contains: [XML_ENTITIES]
					},
					{ begin: /[^\s"'=<>`]+/ }
				]
			}]
		}]
	};
	return {
		name: "HTML, XML",
		aliases: [
			"html",
			"xhtml",
			"rss",
			"atom",
			"xjb",
			"xsd",
			"xsl",
			"plist",
			"wsf",
			"svg"
		],
		case_insensitive: !0,
		unicodeRegex: !0,
		contains: [
			{
				className: "meta",
				begin: /<![a-z]/,
				end: />/,
				relevance: 10,
				contains: [
					XML_META_KEYWORDS,
					QUOTE_META_STRING_MODE,
					APOS_META_STRING_MODE,
					XML_META_PAR_KEYWORDS,
					{
						begin: /\[/,
						end: /\]/,
						contains: [{
							className: "meta",
							begin: /<![a-z]/,
							end: />/,
							contains: [
								XML_META_KEYWORDS,
								XML_META_PAR_KEYWORDS,
								QUOTE_META_STRING_MODE,
								APOS_META_STRING_MODE
							]
						}]
					}
				]
			},
			hljs.COMMENT(/<!--/, /-->/, { relevance: 10 }),
			{
				begin: /<!\[CDATA\[/,
				end: /\]\]>/,
				relevance: 10
			},
			XML_ENTITIES,
			{
				className: "meta",
				end: /\?>/,
				variants: [{
					begin: /<\?xml/,
					relevance: 10,
					contains: [QUOTE_META_STRING_MODE]
				}, { begin: /<\?[a-z][a-z0-9]+/ }]
			},
			{
				className: "tag",
				begin: /<style(?=\s|>)/,
				end: />/,
				keywords: { name: "style" },
				contains: [TAG_INTERNALS],
				starts: {
					end: /<\/style>/,
					returnEnd: !0,
					subLanguage: ["css", "xml"]
				}
			},
			{
				className: "tag",
				begin: /<script(?=\s|>)/,
				end: />/,
				keywords: { name: "script" },
				contains: [TAG_INTERNALS],
				starts: {
					end: /<\/script>/,
					returnEnd: !0,
					subLanguage: [
						"javascript",
						"handlebars",
						"xml"
					]
				}
			},
			{
				className: "tag",
				begin: /<>|<\/>/
			},
			{
				className: "tag",
				begin: regex$1.concat(/</, regex$1.lookahead(regex$1.concat(TAG_NAME_RE, regex$1.either(/\/>/, />/, /\s/)))),
				end: /\/?>/,
				contains: [{
					className: "name",
					begin: TAG_NAME_RE,
					relevance: 0,
					starts: TAG_INTERNALS
				}]
			},
			{
				className: "tag",
				begin: regex$1.concat(/<\//, regex$1.lookahead(regex$1.concat(TAG_NAME_RE, />/))),
				contains: [{
					className: "name",
					begin: TAG_NAME_RE,
					relevance: 0
				}, {
					begin: />/,
					relevance: 0,
					endsParent: !0
				}]
			}
		]
	};
}
function yaml$2(hljs) {
	let LITERALS$2 = "true false yes no null", URI_CHARACTERS = "[\\w#;/?:@&=+$,.~*'()[\\]]+", KEY = {
		className: "attr",
		variants: [
			{ begin: /[\w*@][\w*@ :()\./-]*:(?=[ \t]|$)/ },
			{ begin: /"[\w*@][\w*@ :()\./-]*":(?=[ \t]|$)/ },
			{ begin: /'[\w*@][\w*@ :()\./-]*':(?=[ \t]|$)/ }
		]
	}, TEMPLATE_VARIABLES = {
		className: "template-variable",
		variants: [{
			begin: /\{\{/,
			end: /\}\}/
		}, {
			begin: /%\{/,
			end: /\}/
		}]
	}, SINGLE_QUOTE_STRING = {
		className: "string",
		relevance: 0,
		begin: /'/,
		end: /'/,
		contains: [{
			match: /''/,
			scope: "char.escape",
			relevance: 0
		}]
	}, STRING = {
		className: "string",
		relevance: 0,
		variants: [{
			begin: /"/,
			end: /"/
		}, { begin: /\S+/ }],
		contains: [hljs.BACKSLASH_ESCAPE, TEMPLATE_VARIABLES]
	}, CONTAINER_STRING = hljs.inherit(STRING, { variants: [
		{
			begin: /'/,
			end: /'/,
			contains: [{
				begin: /''/,
				relevance: 0
			}]
		},
		{
			begin: /"/,
			end: /"/
		},
		{ begin: /[^\s,{}[\]]+/ }
	] }), TIMESTAMP = {
		className: "number",
		begin: "\\b[0-9]{4}(-[0-9][0-9]){0,2}([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?(\\.[0-9]*)?([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?\\b"
	}, VALUE_CONTAINER = {
		end: ",",
		endsWithParent: !0,
		excludeEnd: !0,
		keywords: LITERALS$2,
		relevance: 0
	}, OBJECT$1 = {
		begin: /\{/,
		end: /\}/,
		contains: [VALUE_CONTAINER],
		illegal: "\\n",
		relevance: 0
	}, ARRAY$1 = {
		begin: "\\[",
		end: "\\]",
		contains: [VALUE_CONTAINER],
		illegal: "\\n",
		relevance: 0
	}, MODES$4 = [
		KEY,
		{
			className: "meta",
			begin: "^---\\s*$",
			relevance: 10
		},
		{
			className: "string",
			begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"
		},
		{
			begin: "<%[%=-]?",
			end: "[%-]?%>",
			subLanguage: "ruby",
			excludeBegin: !0,
			excludeEnd: !0,
			relevance: 0
		},
		{
			className: "type",
			begin: "!\\w+!" + URI_CHARACTERS
		},
		{
			className: "type",
			begin: "!<" + URI_CHARACTERS + ">"
		},
		{
			className: "type",
			begin: "!" + URI_CHARACTERS
		},
		{
			className: "type",
			begin: "!!" + URI_CHARACTERS
		},
		{
			className: "meta",
			begin: "&" + hljs.UNDERSCORE_IDENT_RE + "$"
		},
		{
			className: "meta",
			begin: "\\*" + hljs.UNDERSCORE_IDENT_RE + "$"
		},
		{
			className: "bullet",
			begin: "-(?=[ ]|$)",
			relevance: 0
		},
		hljs.HASH_COMMENT_MODE,
		{
			beginKeywords: LITERALS$2,
			keywords: { literal: LITERALS$2 }
		},
		TIMESTAMP,
		{
			className: "number",
			begin: hljs.C_NUMBER_RE + "\\b",
			relevance: 0
		},
		OBJECT$1,
		ARRAY$1,
		SINGLE_QUOTE_STRING,
		STRING
	], VALUE_MODES = [...MODES$4];
	return VALUE_MODES.pop(), VALUE_MODES.push(CONTAINER_STRING), VALUE_CONTAINER.contains = VALUE_MODES, {
		name: "YAML",
		case_insensitive: !0,
		aliases: ["yml"],
		contains: MODES$4
	};
}
const grammars = {
	arduino,
	bash,
	c,
	cpp,
	csharp,
	css,
	diff,
	go,
	graphql,
	ini,
	java,
	javascript,
	json,
	kotlin,
	less,
	lua,
	makefile,
	markdown,
	objectivec,
	perl,
	php,
	"php-template": phpTemplate,
	plaintext,
	python,
	"python-repl": pythonRepl,
	r,
	ruby,
	rust,
	scss,
	shell,
	sql,
	swift,
	typescript,
	vbnet,
	wasm,
	xml,
	yaml: yaml$2
};
var require_core$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function deepFreeze(obj) {
		return obj instanceof Map ? obj.clear = obj.delete = obj.set = function() {
			throw Error("map is read-only");
		} : obj instanceof Set && (obj.add = obj.clear = obj.delete = function() {
			throw Error("set is read-only");
		}), Object.freeze(obj), Object.getOwnPropertyNames(obj).forEach((name$1) => {
			let prop = obj[name$1], type = typeof prop;
			(type === "object" || type === "function") && !Object.isFrozen(prop) && deepFreeze(prop);
		}), obj;
	}
	var Response = class {
		constructor(mode) {
			mode.data === void 0 && (mode.data = {}), this.data = mode.data, this.isMatchIgnored = !1;
		}
		ignoreMatch() {
			this.isMatchIgnored = !0;
		}
	};
	function escapeHTML(value) {
		return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
	}
	function inherit$1(original, ...objects) {
		let result = Object.create(null);
		for (let key in original) result[key] = original[key];
		return objects.forEach(function(obj) {
			for (let key in obj) result[key] = obj[key];
		}), result;
	}
	var SPAN_CLOSE = "</span>", emitsWrappingTags = (node$1) => !!node$1.scope, scopeToCSSClass = (name$1, { prefix }) => {
		if (name$1.startsWith("language:")) return name$1.replace("language:", "language-");
		if (name$1.includes(".")) {
			let pieces = name$1.split(".");
			return [`${prefix}${pieces.shift()}`, ...pieces.map((x, i$2) => `${x}${"_".repeat(i$2 + 1)}`)].join(" ");
		}
		return `${prefix}${name$1}`;
	}, HTMLRenderer = class {
		constructor(parseTree, options) {
			this.buffer = "", this.classPrefix = options.classPrefix, parseTree.walk(this);
		}
		addText(text$6) {
			this.buffer += escapeHTML(text$6);
		}
		openNode(node$1) {
			if (!emitsWrappingTags(node$1)) return;
			let className = scopeToCSSClass(node$1.scope, { prefix: this.classPrefix });
			this.span(className);
		}
		closeNode(node$1) {
			emitsWrappingTags(node$1) && (this.buffer += SPAN_CLOSE);
		}
		value() {
			return this.buffer;
		}
		span(className) {
			this.buffer += `<span class="${className}">`;
		}
	}, newNode = (opts = {}) => {
		let result = { children: [] };
		return Object.assign(result, opts), result;
	}, TokenTree = class TokenTree {
		constructor() {
			this.rootNode = newNode(), this.stack = [this.rootNode];
		}
		get top() {
			return this.stack[this.stack.length - 1];
		}
		get root() {
			return this.rootNode;
		}
		add(node$1) {
			this.top.children.push(node$1);
		}
		openNode(scope) {
			let node$1 = newNode({ scope });
			this.add(node$1), this.stack.push(node$1);
		}
		closeNode() {
			if (this.stack.length > 1) return this.stack.pop();
		}
		closeAllNodes() {
			for (; this.closeNode(););
		}
		toJSON() {
			return JSON.stringify(this.rootNode, null, 4);
		}
		walk(builder) {
			return this.constructor._walk(builder, this.rootNode);
		}
		static _walk(builder, node$1) {
			return typeof node$1 == "string" ? builder.addText(node$1) : node$1.children && (builder.openNode(node$1), node$1.children.forEach((child) => this._walk(builder, child)), builder.closeNode(node$1)), builder;
		}
		static _collapse(node$1) {
			typeof node$1 != "string" && node$1.children && (node$1.children.every((el) => typeof el == "string") ? node$1.children = [node$1.children.join("")] : node$1.children.forEach((child) => {
				TokenTree._collapse(child);
			}));
		}
	}, TokenTreeEmitter = class extends TokenTree {
		constructor(options) {
			super(), this.options = options;
		}
		addText(text$6) {
			text$6 !== "" && this.add(text$6);
		}
		startScope(scope) {
			this.openNode(scope);
		}
		endScope() {
			this.closeNode();
		}
		__addSublanguage(emitter, name$1) {
			let node$1 = emitter.root;
			name$1 && (node$1.scope = `language:${name$1}`), this.add(node$1);
		}
		toHTML() {
			return new HTMLRenderer(this, this.options).value();
		}
		finalize() {
			return this.closeAllNodes(), !0;
		}
	};
	function source(re$1) {
		return re$1 ? typeof re$1 == "string" ? re$1 : re$1.source : null;
	}
	function lookahead(re$1) {
		return concat("(?=", re$1, ")");
	}
	function anyNumberOfTimes(re$1) {
		return concat("(?:", re$1, ")*");
	}
	function optional(re$1) {
		return concat("(?:", re$1, ")?");
	}
	function concat(...args) {
		return args.map((x) => source(x)).join("");
	}
	function stripOptionsFromArgs(args) {
		let opts = args[args.length - 1];
		return typeof opts == "object" && opts.constructor === Object ? (args.splice(args.length - 1, 1), opts) : {};
	}
	function either(...args) {
		return "(" + (stripOptionsFromArgs(args).capture ? "" : "?:") + args.map((x) => source(x)).join("|") + ")";
	}
	function countMatchGroups(re$1) {
		return (/* @__PURE__ */ RegExp(re$1.toString() + "|")).exec("").length - 1;
	}
	function startsWith(re$1, lexeme) {
		let match = re$1 && re$1.exec(lexeme);
		return match && match.index === 0;
	}
	var BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
	function _rewriteBackreferences(regexps, { joinWith }) {
		let numCaptures = 0;
		return regexps.map((regex$1) => {
			numCaptures += 1;
			let offset = numCaptures, re$1 = source(regex$1), out = "";
			for (; re$1.length > 0;) {
				let match = BACKREF_RE.exec(re$1);
				if (!match) {
					out += re$1;
					break;
				}
				out += re$1.substring(0, match.index), re$1 = re$1.substring(match.index + match[0].length), match[0][0] === "\\" && match[1] ? out += "\\" + String(Number(match[1]) + offset) : (out += match[0], match[0] === "(" && numCaptures++);
			}
			return out;
		}).map((re$1) => `(${re$1})`).join(joinWith);
	}
	var MATCH_NOTHING_RE = /\b\B/, IDENT_RE = "[a-zA-Z]\\w*", UNDERSCORE_IDENT_RE = "[a-zA-Z_]\\w*", NUMBER_RE = "\\b\\d+(\\.\\d+)?", C_NUMBER_RE = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", BINARY_NUMBER_RE = "\\b(0b[01]+)", RE_STARTERS_RE = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", SHEBANG = (opts = {}) => {
		let beginShebang = /^#![ ]*\//;
		return opts.binary && (opts.begin = concat(beginShebang, /.*\b/, opts.binary, /\b.*/)), inherit$1({
			scope: "meta",
			begin: beginShebang,
			end: /$/,
			relevance: 0,
			"on:begin": (m, resp) => {
				m.index !== 0 && resp.ignoreMatch();
			}
		}, opts);
	}, BACKSLASH_ESCAPE = {
		begin: "\\\\[\\s\\S]",
		relevance: 0
	}, APOS_STRING_MODE = {
		scope: "string",
		begin: "'",
		end: "'",
		illegal: "\\n",
		contains: [BACKSLASH_ESCAPE]
	}, QUOTE_STRING_MODE = {
		scope: "string",
		begin: "\"",
		end: "\"",
		illegal: "\\n",
		contains: [BACKSLASH_ESCAPE]
	}, PHRASAL_WORDS_MODE = { begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/ }, COMMENT = function(begin, end, modeOptions = {}) {
		let mode = inherit$1({
			scope: "comment",
			begin,
			end,
			contains: []
		}, modeOptions);
		mode.contains.push({
			scope: "doctag",
			begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
			end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
			excludeBegin: !0,
			relevance: 0
		});
		let ENGLISH_WORD = either("I", "a", "is", "so", "us", "to", "at", "if", "in", "it", "on", /[A-Za-z]+['](d|ve|re|ll|t|s|n)/, /[A-Za-z]+[-][a-z]+/, /[A-Za-z][a-z]{2,}/);
		return mode.contains.push({ begin: concat(/[ ]+/, "(", ENGLISH_WORD, /[.]?[:]?([.][ ]|[ ])/, "){3}") }), mode;
	}, C_LINE_COMMENT_MODE = COMMENT("//", "$"), C_BLOCK_COMMENT_MODE = COMMENT("/\\*", "\\*/"), HASH_COMMENT_MODE = COMMENT("#", "$"), NUMBER_MODE = {
		scope: "number",
		begin: NUMBER_RE,
		relevance: 0
	}, C_NUMBER_MODE = {
		scope: "number",
		begin: C_NUMBER_RE,
		relevance: 0
	}, BINARY_NUMBER_MODE = {
		scope: "number",
		begin: BINARY_NUMBER_RE,
		relevance: 0
	}, REGEXP_MODE = {
		scope: "regexp",
		begin: /\/(?=[^/\n]*\/)/,
		end: /\/[gimuy]*/,
		contains: [BACKSLASH_ESCAPE, {
			begin: /\[/,
			end: /\]/,
			relevance: 0,
			contains: [BACKSLASH_ESCAPE]
		}]
	}, TITLE_MODE = {
		scope: "title",
		begin: IDENT_RE,
		relevance: 0
	}, UNDERSCORE_TITLE_MODE = {
		scope: "title",
		begin: UNDERSCORE_IDENT_RE,
		relevance: 0
	}, METHOD_GUARD = {
		begin: "\\.\\s*" + UNDERSCORE_IDENT_RE,
		relevance: 0
	}, MODES = /* @__PURE__ */ Object.freeze({
		__proto__: null,
		APOS_STRING_MODE,
		BACKSLASH_ESCAPE,
		BINARY_NUMBER_MODE,
		BINARY_NUMBER_RE,
		COMMENT,
		C_BLOCK_COMMENT_MODE,
		C_LINE_COMMENT_MODE,
		C_NUMBER_MODE,
		C_NUMBER_RE,
		END_SAME_AS_BEGIN: function(mode) {
			return Object.assign(mode, {
				"on:begin": (m, resp) => {
					resp.data._beginMatch = m[1];
				},
				"on:end": (m, resp) => {
					resp.data._beginMatch !== m[1] && resp.ignoreMatch();
				}
			});
		},
		HASH_COMMENT_MODE,
		IDENT_RE,
		MATCH_NOTHING_RE,
		METHOD_GUARD,
		NUMBER_MODE,
		NUMBER_RE,
		PHRASAL_WORDS_MODE,
		QUOTE_STRING_MODE,
		REGEXP_MODE,
		RE_STARTERS_RE,
		SHEBANG,
		TITLE_MODE,
		UNDERSCORE_IDENT_RE,
		UNDERSCORE_TITLE_MODE
	});
	function skipIfHasPrecedingDot(match, response) {
		match.input[match.index - 1] === "." && response.ignoreMatch();
	}
	function scopeClassName(mode, _parent) {
		mode.className !== void 0 && (mode.scope = mode.className, delete mode.className);
	}
	function beginKeywords(mode, parent) {
		parent && mode.beginKeywords && (mode.begin = "\\b(" + mode.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", mode.__beforeBegin = skipIfHasPrecedingDot, mode.keywords = mode.keywords || mode.beginKeywords, delete mode.beginKeywords, mode.relevance === void 0 && (mode.relevance = 0));
	}
	function compileIllegal(mode, _parent) {
		Array.isArray(mode.illegal) && (mode.illegal = either(...mode.illegal));
	}
	function compileMatch(mode, _parent) {
		if (mode.match) {
			if (mode.begin || mode.end) throw Error("begin & end are not supported with match");
			mode.begin = mode.match, delete mode.match;
		}
	}
	function compileRelevance(mode, _parent) {
		mode.relevance === void 0 && (mode.relevance = 1);
	}
	var beforeMatchExt = (mode, parent) => {
		if (!mode.beforeMatch) return;
		if (mode.starts) throw Error("beforeMatch cannot be used with starts");
		let originalMode = Object.assign({}, mode);
		Object.keys(mode).forEach((key) => {
			delete mode[key];
		}), mode.keywords = originalMode.keywords, mode.begin = concat(originalMode.beforeMatch, lookahead(originalMode.begin)), mode.starts = {
			relevance: 0,
			contains: [Object.assign(originalMode, { endsParent: !0 })]
		}, mode.relevance = 0, delete originalMode.beforeMatch;
	}, COMMON_KEYWORDS = [
		"of",
		"and",
		"for",
		"in",
		"not",
		"or",
		"if",
		"then",
		"parent",
		"list",
		"value"
	], DEFAULT_KEYWORD_SCOPE = "keyword";
	function compileKeywords(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE) {
		let compiledKeywords = Object.create(null);
		return typeof rawKeywords == "string" ? compileList$1(scopeName, rawKeywords.split(" ")) : Array.isArray(rawKeywords) ? compileList$1(scopeName, rawKeywords) : Object.keys(rawKeywords).forEach(function(scopeName$1) {
			Object.assign(compiledKeywords, compileKeywords(rawKeywords[scopeName$1], caseInsensitive, scopeName$1));
		}), compiledKeywords;
		function compileList$1(scopeName$1, keywordList) {
			caseInsensitive && (keywordList = keywordList.map((x) => x.toLowerCase())), keywordList.forEach(function(keyword) {
				let pair = keyword.split("|");
				compiledKeywords[pair[0]] = [scopeName$1, scoreForKeyword(pair[0], pair[1])];
			});
		}
	}
	function scoreForKeyword(keyword, providedScore) {
		return providedScore ? Number(providedScore) : commonKeyword(keyword) ? 0 : 1;
	}
	function commonKeyword(keyword) {
		return COMMON_KEYWORDS.includes(keyword.toLowerCase());
	}
	var seenDeprecations = {}, error = (message) => {
		console.error(message);
	}, warn = (message, ...args) => {
		console.log(`WARN: ${message}`, ...args);
	}, deprecated$1 = (version$1, message) => {
		seenDeprecations[`${version$1}/${message}`] || (console.log(`Deprecated as of ${version$1}. ${message}`), seenDeprecations[`${version$1}/${message}`] = !0);
	}, MultiClassError = /* @__PURE__ */ Error();
	function remapScopeNames(mode, regexes, { key }) {
		let offset = 0, scopeNames = mode[key], emit = {}, positions = {};
		for (let i$2 = 1; i$2 <= regexes.length; i$2++) positions[i$2 + offset] = scopeNames[i$2], emit[i$2 + offset] = !0, offset += countMatchGroups(regexes[i$2 - 1]);
		mode[key] = positions, mode[key]._emit = emit, mode[key]._multi = !0;
	}
	function beginMultiClass(mode) {
		if (Array.isArray(mode.begin)) {
			if (mode.skip || mode.excludeBegin || mode.returnBegin) throw error("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), MultiClassError;
			if (typeof mode.beginScope != "object" || mode.beginScope === null) throw error("beginScope must be object"), MultiClassError;
			remapScopeNames(mode, mode.begin, { key: "beginScope" }), mode.begin = _rewriteBackreferences(mode.begin, { joinWith: "" });
		}
	}
	function endMultiClass(mode) {
		if (Array.isArray(mode.end)) {
			if (mode.skip || mode.excludeEnd || mode.returnEnd) throw error("skip, excludeEnd, returnEnd not compatible with endScope: {}"), MultiClassError;
			if (typeof mode.endScope != "object" || mode.endScope === null) throw error("endScope must be object"), MultiClassError;
			remapScopeNames(mode, mode.end, { key: "endScope" }), mode.end = _rewriteBackreferences(mode.end, { joinWith: "" });
		}
	}
	function scopeSugar(mode) {
		mode.scope && typeof mode.scope == "object" && mode.scope !== null && (mode.beginScope = mode.scope, delete mode.scope);
	}
	function MultiClass(mode) {
		scopeSugar(mode), typeof mode.beginScope == "string" && (mode.beginScope = { _wrap: mode.beginScope }), typeof mode.endScope == "string" && (mode.endScope = { _wrap: mode.endScope }), beginMultiClass(mode), endMultiClass(mode);
	}
	function compileLanguage(language$1) {
		function langRe(value, global) {
			return new RegExp(source(value), "m" + (language$1.case_insensitive ? "i" : "") + (language$1.unicodeRegex ? "u" : "") + (global ? "g" : ""));
		}
		class MultiRegex {
			constructor() {
				this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
			}
			addRule(re$1, opts) {
				opts.position = this.position++, this.matchIndexes[this.matchAt] = opts, this.regexes.push([opts, re$1]), this.matchAt += countMatchGroups(re$1) + 1;
			}
			compile() {
				this.regexes.length === 0 && (this.exec = () => null), this.matcherRe = langRe(_rewriteBackreferences(this.regexes.map((el) => el[1]), { joinWith: "|" }), !0), this.lastIndex = 0;
			}
			exec(s) {
				this.matcherRe.lastIndex = this.lastIndex;
				let match = this.matcherRe.exec(s);
				if (!match) return null;
				let i$2 = match.findIndex((el, i$3) => i$3 > 0 && el !== void 0), matchData = this.matchIndexes[i$2];
				return match.splice(0, i$2), Object.assign(match, matchData);
			}
		}
		class ResumableMultiRegex {
			constructor() {
				this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
			}
			getMatcher(index$2) {
				if (this.multiRegexes[index$2]) return this.multiRegexes[index$2];
				let matcher = new MultiRegex();
				return this.rules.slice(index$2).forEach(([re$1, opts]) => matcher.addRule(re$1, opts)), matcher.compile(), this.multiRegexes[index$2] = matcher, matcher;
			}
			resumingScanAtSamePosition() {
				return this.regexIndex !== 0;
			}
			considerAll() {
				this.regexIndex = 0;
			}
			addRule(re$1, opts) {
				this.rules.push([re$1, opts]), opts.type === "begin" && this.count++;
			}
			exec(s) {
				let m = this.getMatcher(this.regexIndex);
				m.lastIndex = this.lastIndex;
				let result = m.exec(s);
				if (this.resumingScanAtSamePosition() && !(result && result.index === this.lastIndex)) {
					let m2 = this.getMatcher(0);
					m2.lastIndex = this.lastIndex + 1, result = m2.exec(s);
				}
				return result && (this.regexIndex += result.position + 1, this.regexIndex === this.count && this.considerAll()), result;
			}
		}
		function buildModeRegex(mode) {
			let mm = new ResumableMultiRegex();
			return mode.contains.forEach((term) => mm.addRule(term.begin, {
				rule: term,
				type: "begin"
			})), mode.terminatorEnd && mm.addRule(mode.terminatorEnd, { type: "end" }), mode.illegal && mm.addRule(mode.illegal, { type: "illegal" }), mm;
		}
		function compileMode(mode, parent) {
			let cmode = mode;
			if (mode.isCompiled) return cmode;
			[
				scopeClassName,
				compileMatch,
				MultiClass,
				beforeMatchExt
			].forEach((ext) => ext(mode, parent)), language$1.compilerExtensions.forEach((ext) => ext(mode, parent)), mode.__beforeBegin = null, [
				beginKeywords,
				compileIllegal,
				compileRelevance
			].forEach((ext) => ext(mode, parent)), mode.isCompiled = !0;
			let keywordPattern = null;
			return typeof mode.keywords == "object" && mode.keywords.$pattern && (mode.keywords = Object.assign({}, mode.keywords), keywordPattern = mode.keywords.$pattern, delete mode.keywords.$pattern), keywordPattern ||= /\w+/, mode.keywords &&= compileKeywords(mode.keywords, language$1.case_insensitive), cmode.keywordPatternRe = langRe(keywordPattern, !0), parent && (mode.begin ||= /\B|\b/, cmode.beginRe = langRe(cmode.begin), !mode.end && !mode.endsWithParent && (mode.end = /\B|\b/), mode.end && (cmode.endRe = langRe(cmode.end)), cmode.terminatorEnd = source(cmode.end) || "", mode.endsWithParent && parent.terminatorEnd && (cmode.terminatorEnd += (mode.end ? "|" : "") + parent.terminatorEnd)), mode.illegal && (cmode.illegalRe = langRe(mode.illegal)), mode.contains ||= [], mode.contains = [].concat(...mode.contains.map(function(c$1) {
				return expandOrCloneMode(c$1 === "self" ? mode : c$1);
			})), mode.contains.forEach(function(c$1) {
				compileMode(c$1, cmode);
			}), mode.starts && compileMode(mode.starts, parent), cmode.matcher = buildModeRegex(cmode), cmode;
		}
		if (language$1.compilerExtensions ||= [], language$1.contains && language$1.contains.includes("self")) throw Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
		return language$1.classNameAliases = inherit$1(language$1.classNameAliases || {}), compileMode(language$1);
	}
	function dependencyOnParent(mode) {
		return mode ? mode.endsWithParent || dependencyOnParent(mode.starts) : !1;
	}
	function expandOrCloneMode(mode) {
		return mode.variants && !mode.cachedVariants && (mode.cachedVariants = mode.variants.map(function(variant) {
			return inherit$1(mode, { variants: null }, variant);
		})), mode.cachedVariants ? mode.cachedVariants : dependencyOnParent(mode) ? inherit$1(mode, { starts: mode.starts ? inherit$1(mode.starts) : null }) : Object.isFrozen(mode) ? inherit$1(mode) : mode;
	}
	var version = "11.11.1", HTMLInjectionError = class extends Error {
		constructor(reason, html$4) {
			super(reason), this.name = "HTMLInjectionError", this.html = html$4;
		}
	}, escape = escapeHTML, inherit = inherit$1, NO_MATCH = Symbol("nomatch"), MAX_KEYWORD_HITS = 7, HLJS = function(hljs) {
		let languages = Object.create(null), aliases = Object.create(null), plugins = [], SAFE_MODE = !0, LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?", PLAINTEXT_LANGUAGE = {
			disableAutodetect: !0,
			name: "Plain text",
			contains: []
		}, options = {
			ignoreUnescapedHTML: !1,
			throwUnescapedHTML: !1,
			noHighlightRe: /^(no-?highlight)$/i,
			languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
			classPrefix: "hljs-",
			cssSelector: "pre code",
			languages: null,
			__emitter: TokenTreeEmitter
		};
		function shouldNotHighlight(languageName) {
			return options.noHighlightRe.test(languageName);
		}
		function blockLanguage(block) {
			let classes = block.className + " ";
			classes += block.parentNode ? block.parentNode.className : "";
			let match = options.languageDetectRe.exec(classes);
			if (match) {
				let language$1 = getLanguage(match[1]);
				return language$1 || (warn(LANGUAGE_NOT_FOUND.replace("{}", match[1])), warn("Falling back to no-highlight mode for this block.", block)), language$1 ? match[1] : "no-highlight";
			}
			return classes.split(/\s+/).find((_class$1) => shouldNotHighlight(_class$1) || getLanguage(_class$1));
		}
		function highlight$1(codeOrLanguageName, optionsOrCode, ignoreIllegals) {
			let code$4 = "", languageName = "";
			typeof optionsOrCode == "object" ? (code$4 = codeOrLanguageName, ignoreIllegals = optionsOrCode.ignoreIllegals, languageName = optionsOrCode.language) : (deprecated$1("10.7.0", "highlight(lang, code, ...args) has been deprecated."), deprecated$1("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277"), languageName = codeOrLanguageName, code$4 = optionsOrCode), ignoreIllegals === void 0 && (ignoreIllegals = !0);
			let context = {
				code: code$4,
				language: languageName
			};
			fire("before:highlight", context);
			let result = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals);
			return result.code = context.code, fire("after:highlight", result), result;
		}
		function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
			let keywordHits = Object.create(null);
			function keywordData(mode, matchText) {
				return mode.keywords[matchText];
			}
			function processKeywords() {
				if (!top.keywords) {
					emitter.addText(modeBuffer);
					return;
				}
				let lastIndex = 0;
				top.keywordPatternRe.lastIndex = 0;
				let match = top.keywordPatternRe.exec(modeBuffer), buf = "";
				for (; match;) {
					buf += modeBuffer.substring(lastIndex, match.index);
					let word = language$1.case_insensitive ? match[0].toLowerCase() : match[0], data = keywordData(top, word);
					if (data) {
						let [kind, keywordRelevance] = data;
						if (emitter.addText(buf), buf = "", keywordHits[word] = (keywordHits[word] || 0) + 1, keywordHits[word] <= MAX_KEYWORD_HITS && (relevance += keywordRelevance), kind.startsWith("_")) buf += match[0];
						else {
							let cssClass = language$1.classNameAliases[kind] || kind;
							emitKeyword(match[0], cssClass);
						}
					} else buf += match[0];
					lastIndex = top.keywordPatternRe.lastIndex, match = top.keywordPatternRe.exec(modeBuffer);
				}
				buf += modeBuffer.substring(lastIndex), emitter.addText(buf);
			}
			function processSubLanguage() {
				if (modeBuffer === "") return;
				let result$1 = null;
				if (typeof top.subLanguage == "string") {
					if (!languages[top.subLanguage]) {
						emitter.addText(modeBuffer);
						return;
					}
					result$1 = _highlight(top.subLanguage, modeBuffer, !0, continuations[top.subLanguage]), continuations[top.subLanguage] = result$1._top;
				} else result$1 = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
				top.relevance > 0 && (relevance += result$1.relevance), emitter.__addSublanguage(result$1._emitter, result$1.language);
			}
			function processBuffer() {
				top.subLanguage == null ? processKeywords() : processSubLanguage(), modeBuffer = "";
			}
			function emitKeyword(keyword, scope) {
				keyword !== "" && (emitter.startScope(scope), emitter.addText(keyword), emitter.endScope());
			}
			function emitMultiClass(scope, match) {
				let i$2 = 1, max = match.length - 1;
				for (; i$2 <= max;) {
					if (!scope._emit[i$2]) {
						i$2++;
						continue;
					}
					let klass = language$1.classNameAliases[scope[i$2]] || scope[i$2], text$6 = match[i$2];
					klass ? emitKeyword(text$6, klass) : (modeBuffer = text$6, processKeywords(), modeBuffer = ""), i$2++;
				}
			}
			function startNewMode(mode, match) {
				return mode.scope && typeof mode.scope == "string" && emitter.openNode(language$1.classNameAliases[mode.scope] || mode.scope), mode.beginScope && (mode.beginScope._wrap ? (emitKeyword(modeBuffer, language$1.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap), modeBuffer = "") : mode.beginScope._multi && (emitMultiClass(mode.beginScope, match), modeBuffer = "")), top = Object.create(mode, { parent: { value: top } }), top;
			}
			function endOfMode(mode, match, matchPlusRemainder) {
				let matched = startsWith(mode.endRe, matchPlusRemainder);
				if (matched) {
					if (mode["on:end"]) {
						let resp = new Response(mode);
						mode["on:end"](match, resp), resp.isMatchIgnored && (matched = !1);
					}
					if (matched) {
						for (; mode.endsParent && mode.parent;) mode = mode.parent;
						return mode;
					}
				}
				if (mode.endsWithParent) return endOfMode(mode.parent, match, matchPlusRemainder);
			}
			function doIgnore(lexeme) {
				return top.matcher.regexIndex === 0 ? (modeBuffer += lexeme[0], 1) : (resumeScanAtSamePosition = !0, 0);
			}
			function doBeginMatch(match) {
				let lexeme = match[0], newMode = match.rule, resp = new Response(newMode), beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
				for (let cb of beforeCallbacks) if (cb && (cb(match, resp), resp.isMatchIgnored)) return doIgnore(lexeme);
				return newMode.skip ? modeBuffer += lexeme : (newMode.excludeBegin && (modeBuffer += lexeme), processBuffer(), !newMode.returnBegin && !newMode.excludeBegin && (modeBuffer = lexeme)), startNewMode(newMode, match), newMode.returnBegin ? 0 : lexeme.length;
			}
			function doEndMatch(match) {
				let lexeme = match[0], matchPlusRemainder = codeToHighlight.substring(match.index), endMode = endOfMode(top, match, matchPlusRemainder);
				if (!endMode) return NO_MATCH;
				let origin = top;
				top.endScope && top.endScope._wrap ? (processBuffer(), emitKeyword(lexeme, top.endScope._wrap)) : top.endScope && top.endScope._multi ? (processBuffer(), emitMultiClass(top.endScope, match)) : origin.skip ? modeBuffer += lexeme : (origin.returnEnd || origin.excludeEnd || (modeBuffer += lexeme), processBuffer(), origin.excludeEnd && (modeBuffer = lexeme));
				do
					top.scope && emitter.closeNode(), !top.skip && !top.subLanguage && (relevance += top.relevance), top = top.parent;
				while (top !== endMode.parent);
				return endMode.starts && startNewMode(endMode.starts, match), origin.returnEnd ? 0 : lexeme.length;
			}
			function processContinuations() {
				let list$3 = [];
				for (let current = top; current !== language$1; current = current.parent) current.scope && list$3.unshift(current.scope);
				list$3.forEach((item) => emitter.openNode(item));
			}
			let lastMatch = {};
			function processLexeme(textBeforeMatch, match) {
				let lexeme = match && match[0];
				if (modeBuffer += textBeforeMatch, lexeme == null) return processBuffer(), 0;
				if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
					if (modeBuffer += codeToHighlight.slice(match.index, match.index + 1), !SAFE_MODE) {
						let err = /* @__PURE__ */ Error(`0 width match regex (${languageName})`);
						throw err.languageName = languageName, err.badRule = lastMatch.rule, err;
					}
					return 1;
				}
				if (lastMatch = match, match.type === "begin") return doBeginMatch(match);
				if (match.type === "illegal" && !ignoreIllegals) {
					let err = /* @__PURE__ */ Error("Illegal lexeme \"" + lexeme + "\" for mode \"" + (top.scope || "<unnamed>") + "\"");
					throw err.mode = top, err;
				} else if (match.type === "end") {
					let processed = doEndMatch(match);
					if (processed !== NO_MATCH) return processed;
				}
				if (match.type === "illegal" && lexeme === "") return modeBuffer += "\n", 1;
				if (iterations > 1e5 && iterations > match.index * 3) throw /* @__PURE__ */ Error("potential infinite loop, way more iterations than matches");
				return modeBuffer += lexeme, lexeme.length;
			}
			let language$1 = getLanguage(languageName);
			if (!language$1) throw error(LANGUAGE_NOT_FOUND.replace("{}", languageName)), Error("Unknown language: \"" + languageName + "\"");
			let md = compileLanguage(language$1), result = "", top = continuation || md, continuations = {}, emitter = new options.__emitter(options);
			processContinuations();
			let modeBuffer = "", relevance = 0, index$2 = 0, iterations = 0, resumeScanAtSamePosition = !1;
			try {
				if (language$1.__emitTokens) language$1.__emitTokens(codeToHighlight, emitter);
				else {
					for (top.matcher.considerAll();;) {
						iterations++, resumeScanAtSamePosition ? resumeScanAtSamePosition = !1 : top.matcher.considerAll(), top.matcher.lastIndex = index$2;
						let match = top.matcher.exec(codeToHighlight);
						if (!match) break;
						let processedCount = processLexeme(codeToHighlight.substring(index$2, match.index), match);
						index$2 = match.index + processedCount;
					}
					processLexeme(codeToHighlight.substring(index$2));
				}
				return emitter.finalize(), result = emitter.toHTML(), {
					language: languageName,
					value: result,
					relevance,
					illegal: !1,
					_emitter: emitter,
					_top: top
				};
			} catch (err) {
				if (err.message && err.message.includes("Illegal")) return {
					language: languageName,
					value: escape(codeToHighlight),
					illegal: !0,
					relevance: 0,
					_illegalBy: {
						message: err.message,
						index: index$2,
						context: codeToHighlight.slice(index$2 - 100, index$2 + 100),
						mode: err.mode,
						resultSoFar: result
					},
					_emitter: emitter
				};
				if (SAFE_MODE) return {
					language: languageName,
					value: escape(codeToHighlight),
					illegal: !1,
					relevance: 0,
					errorRaised: err,
					_emitter: emitter,
					_top: top
				};
				throw err;
			}
		}
		function justTextHighlightResult(code$4) {
			let result = {
				value: escape(code$4),
				illegal: !1,
				relevance: 0,
				_top: PLAINTEXT_LANGUAGE,
				_emitter: new options.__emitter(options)
			};
			return result._emitter.addText(code$4), result;
		}
		function highlightAuto(code$4, languageSubset) {
			languageSubset = languageSubset || options.languages || Object.keys(languages);
			let plaintext$1 = justTextHighlightResult(code$4), results = languageSubset.filter(getLanguage).filter(autoDetection).map((name$1) => _highlight(name$1, code$4, !1));
			results.unshift(plaintext$1);
			let [best, secondBest] = results.sort((a, b) => {
				if (a.relevance !== b.relevance) return b.relevance - a.relevance;
				if (a.language && b.language) {
					if (getLanguage(a.language).supersetOf === b.language) return 1;
					if (getLanguage(b.language).supersetOf === a.language) return -1;
				}
				return 0;
			}), result = best;
			return result.secondBest = secondBest, result;
		}
		function updateClassName(element$3, currentLang, resultLang) {
			let language$1 = currentLang && aliases[currentLang] || resultLang;
			element$3.classList.add("hljs"), element$3.classList.add(`language-${language$1}`);
		}
		function highlightElement(element$3) {
			let node$1 = null, language$1 = blockLanguage(element$3);
			if (shouldNotHighlight(language$1)) return;
			if (fire("before:highlightElement", {
				el: element$3,
				language: language$1
			}), element$3.dataset.highlighted) {
				console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", element$3);
				return;
			}
			if (element$3.children.length > 0 && (options.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(element$3)), options.throwUnescapedHTML)) throw new HTMLInjectionError("One of your code blocks includes unescaped HTML.", element$3.innerHTML);
			node$1 = element$3;
			let text$6 = node$1.textContent, result = language$1 ? highlight$1(text$6, {
				language: language$1,
				ignoreIllegals: !0
			}) : highlightAuto(text$6);
			element$3.innerHTML = result.value, element$3.dataset.highlighted = "yes", updateClassName(element$3, language$1, result.language), element$3.result = {
				language: result.language,
				re: result.relevance,
				relevance: result.relevance
			}, result.secondBest && (element$3.secondBest = {
				language: result.secondBest.language,
				relevance: result.secondBest.relevance
			}), fire("after:highlightElement", {
				el: element$3,
				result,
				text: text$6
			});
		}
		function configure$1(userOptions) {
			options = inherit(options, userOptions);
		}
		let initHighlighting = () => {
			highlightAll(), deprecated$1("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
		};
		function initHighlightingOnLoad() {
			highlightAll(), deprecated$1("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
		}
		let wantsHighlight = !1;
		function highlightAll() {
			function boot() {
				highlightAll();
			}
			if (document.readyState === "loading") {
				wantsHighlight || window.addEventListener("DOMContentLoaded", boot, !1), wantsHighlight = !0;
				return;
			}
			document.querySelectorAll(options.cssSelector).forEach(highlightElement);
		}
		function registerLanguage(languageName, languageDefinition) {
			let lang = null;
			try {
				lang = languageDefinition(hljs);
			} catch (error$1) {
				if (error("Language definition for '{}' could not be registered.".replace("{}", languageName)), SAFE_MODE) error(error$1);
				else throw error$1;
				lang = PLAINTEXT_LANGUAGE;
			}
			lang.name ||= languageName, languages[languageName] = lang, lang.rawDefinition = languageDefinition.bind(null, hljs), lang.aliases && registerAliases(lang.aliases, { languageName });
		}
		function unregisterLanguage(languageName) {
			delete languages[languageName];
			for (let alias of Object.keys(aliases)) aliases[alias] === languageName && delete aliases[alias];
		}
		function listLanguages() {
			return Object.keys(languages);
		}
		function getLanguage(name$1) {
			return name$1 = (name$1 || "").toLowerCase(), languages[name$1] || languages[aliases[name$1]];
		}
		function registerAliases(aliasList, { languageName }) {
			typeof aliasList == "string" && (aliasList = [aliasList]), aliasList.forEach((alias) => {
				aliases[alias.toLowerCase()] = languageName;
			});
		}
		function autoDetection(name$1) {
			let lang = getLanguage(name$1);
			return lang && !lang.disableAutodetect;
		}
		function upgradePluginAPI(plugin) {
			plugin["before:highlightBlock"] && !plugin["before:highlightElement"] && (plugin["before:highlightElement"] = (data) => {
				plugin["before:highlightBlock"](Object.assign({ block: data.el }, data));
			}), plugin["after:highlightBlock"] && !plugin["after:highlightElement"] && (plugin["after:highlightElement"] = (data) => {
				plugin["after:highlightBlock"](Object.assign({ block: data.el }, data));
			});
		}
		function addPlugin(plugin) {
			upgradePluginAPI(plugin), plugins.push(plugin);
		}
		function removePlugin(plugin) {
			let index$2 = plugins.indexOf(plugin);
			index$2 !== -1 && plugins.splice(index$2, 1);
		}
		function fire(event, args) {
			let cb = event;
			plugins.forEach(function(plugin) {
				plugin[cb] && plugin[cb](args);
			});
		}
		function deprecateHighlightBlock(el) {
			return deprecated$1("10.7.0", "highlightBlock will be removed entirely in v12.0"), deprecated$1("10.7.0", "Please use highlightElement now."), highlightElement(el);
		}
		for (let key in Object.assign(hljs, {
			highlight: highlight$1,
			highlightAuto,
			highlightAll,
			highlightElement,
			highlightBlock: deprecateHighlightBlock,
			configure: configure$1,
			initHighlighting,
			initHighlightingOnLoad,
			registerLanguage,
			unregisterLanguage,
			listLanguages,
			getLanguage,
			registerAliases,
			autoDetection,
			inherit,
			addPlugin,
			removePlugin
		}), hljs.debugMode = function() {
			SAFE_MODE = !1;
		}, hljs.safeMode = function() {
			SAFE_MODE = !0;
		}, hljs.versionString = version, hljs.regex = {
			concat,
			lookahead,
			either,
			optional,
			anyNumberOfTimes
		}, MODES) typeof MODES[key] == "object" && deepFreeze(MODES[key]);
		return Object.assign(hljs, MODES), hljs;
	}, highlight = HLJS({});
	highlight.newInstance = () => HLJS({}), module.exports = highlight, highlight.HighlightJS = highlight, highlight.default = highlight;
})), import_core = /* @__PURE__ */ __toESM(require_core$1()), core_default = import_core.default, emptyOptions$2 = {}, defaultPrefix = "hljs-";
function createLowlight(grammars$1) {
	let high = core_default.newInstance();
	return grammars$1 && register(grammars$1), {
		highlight: highlight$1,
		highlightAuto,
		listLanguages,
		register,
		registerAlias,
		registered
	};
	function highlight$1(language$1, value, options) {
		let settings = options || emptyOptions$2, prefix = typeof settings.prefix == "string" ? settings.prefix : defaultPrefix;
		if (!high.getLanguage(language$1)) throw Error("Unknown language: `" + language$1 + "` is not registered");
		high.configure({
			__emitter: HastEmitter,
			classPrefix: prefix
		});
		let result = high.highlight(value, {
			ignoreIllegals: !0,
			language: language$1
		});
		/* c8 ignore next 5 */
		if (result.errorRaised) throw Error("Could not highlight with `Highlight.js`", { cause: result.errorRaised });
		let root$3 = result._emitter.root, data = root$3.data;
		return data.language = result.language, data.relevance = result.relevance, root$3;
	}
	function highlightAuto(value, options) {
		let subset = (options || emptyOptions$2).subset || listLanguages(), index$2 = -1, relevance = 0, result;
		for (; ++index$2 < subset.length;) {
			let name$1 = subset[index$2];
			if (!high.getLanguage(name$1)) continue;
			let current = highlight$1(name$1, value, options);
			current.data && current.data.relevance !== void 0 && current.data.relevance > relevance && (relevance = current.data.relevance, result = current);
		}
		return result || {
			type: "root",
			children: [],
			data: {
				language: void 0,
				relevance
			}
		};
	}
	function listLanguages() {
		return high.listLanguages();
	}
	function register(grammarsOrName, grammar) {
		if (typeof grammarsOrName == "string") high.registerLanguage(grammarsOrName, grammar);
		else {
			let name$1;
			for (name$1 in grammarsOrName) Object.hasOwn(grammarsOrName, name$1) && high.registerLanguage(name$1, grammarsOrName[name$1]);
		}
	}
	function registerAlias(aliasesOrName, alias) {
		if (typeof aliasesOrName == "string") high.registerAliases(typeof alias == "string" ? alias : [...alias], { languageName: aliasesOrName });
		else {
			let key;
			for (key in aliasesOrName) if (Object.hasOwn(aliasesOrName, key)) {
				let aliases = aliasesOrName[key];
				high.registerAliases(typeof aliases == "string" ? aliases : [...aliases], { languageName: key });
			}
		}
	}
	function registered(aliasOrName) {
		return !!high.getLanguage(aliasOrName);
	}
}
var HastEmitter = class {
	constructor(options) {
		this.options = options, this.root = {
			type: "root",
			children: [],
			data: {
				language: void 0,
				relevance: 0
			}
		}, this.stack = [this.root];
	}
	addText(value) {
		if (value === "") return;
		let current = this.stack[this.stack.length - 1], tail = current.children[current.children.length - 1];
		tail && tail.type === "text" ? tail.value += value : current.children.push({
			type: "text",
			value
		});
	}
	startScope(rawName) {
		this.openNode(String(rawName));
	}
	endScope() {
		this.closeNode();
	}
	__addSublanguage(other, name$1) {
		let current = this.stack[this.stack.length - 1], results = other.root.children;
		name$1 ? current.children.push({
			type: "element",
			tagName: "span",
			properties: { className: [name$1] },
			children: results
		}) : current.children.push(...results);
	}
	openNode(name$1) {
		let self$1 = this, className = name$1.split(".").map(function(d, i$2) {
			return i$2 ? d + "_".repeat(i$2) : self$1.options.classPrefix + d;
		}), current = this.stack[this.stack.length - 1], child = {
			type: "element",
			tagName: "span",
			properties: { className },
			children: []
		};
		current.children.push(child), this.stack.push(child);
	}
	closeNode() {
		this.stack.pop();
	}
	finalize() {}
	toHTML() {
		return "";
	}
}, emptyOptions$1 = {};
function rehypeHighlight(options) {
	let settings = options || emptyOptions$1, aliases = settings.aliases, detect = settings.detect || !1, languages = settings.languages || grammars, plainText = settings.plainText, prefix = settings.prefix, subset = settings.subset, name$1 = "hljs", lowlight = createLowlight(languages);
	if (aliases && lowlight.registerAlias(aliases), prefix) {
		let pos = prefix.indexOf("-");
		name$1 = pos === -1 ? prefix : prefix.slice(0, pos);
	}
	return function(tree, file) {
		visit(tree, "element", function(node$1, _, parent) {
			if (node$1.tagName !== "code" || !parent || parent.type !== "element" || parent.tagName !== "pre") return;
			let lang = language(node$1);
			if (lang === !1 || !lang && !detect || lang && plainText && plainText.includes(lang)) return;
			Array.isArray(node$1.properties.className) || (node$1.properties.className = []), node$1.properties.className.includes(name$1) || node$1.properties.className.unshift(name$1);
			let text$6 = toText(node$1, { whitespace: "pre" }), result;
			try {
				result = lang ? lowlight.highlight(lang, text$6, { prefix }) : lowlight.highlightAuto(text$6, {
					prefix,
					subset
				});
			} catch (error$1) {
				let cause = error$1;
				if (lang && /Unknown language/.test(cause.message)) {
					file.message("Cannot highlight as `" + lang + "`, itâ€™s not registered", {
						ancestors: [parent, node$1],
						cause,
						place: node$1.position,
						ruleId: "missing-language",
						source: "rehype-highlight"
					});
					/* c8 ignore next 5 -- throw arbitrary hljs errors */
					return;
				}
				throw cause;
			}
			!lang && result.data && result.data.language && node$1.properties.className.push("language-" + result.data.language), result.children.length > 0 && (node$1.children = result.children);
		});
	};
}
function language(node$1) {
	let list$3 = node$1.properties.className, index$2 = -1;
	if (!Array.isArray(list$3)) return;
	let name$1;
	for (; ++index$2 < list$3.length;) {
		let value = String(list$3[index$2]);
		if (value === "no-highlight" || value === "nohighlight") return !1;
		!name$1 && value.slice(0, 5) === "lang-" && (name$1 = value.slice(5)), !name$1 && value.slice(0, 9) === "language-" && (name$1 = value.slice(9));
	}
	return name$1;
}
const regex = /[\0-\x1F!-,\.\/:-@\[-\^`\{-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0378\u0379\u037E\u0380-\u0385\u0387\u038B\u038D\u03A2\u03F6\u0482\u0530\u0557\u0558\u055A-\u055F\u0589-\u0590\u05BE\u05C0\u05C3\u05C6\u05C8-\u05CF\u05EB-\u05EE\u05F3-\u060F\u061B-\u061F\u066A-\u066D\u06D4\u06DD\u06DE\u06E9\u06FD\u06FE\u0700-\u070F\u074B\u074C\u07B2-\u07BF\u07F6-\u07F9\u07FB\u07FC\u07FE\u07FF\u082E-\u083F\u085C-\u085F\u086B-\u089F\u08B5\u08C8-\u08D2\u08E2\u0964\u0965\u0970\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09F2-\u09FB\u09FD\u09FF\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF0-\u0AF8\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B54\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B70\u0B72-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BF0-\u0BFF\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C7F\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0CFF\u0D0D\u0D11\u0D45\u0D49\u0D4F-\u0D53\u0D58-\u0D5E\u0D64\u0D65\u0D70-\u0D79\u0D80\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF4-\u0E00\u0E3B-\u0E3F\u0E4F\u0E5A-\u0E80\u0E83\u0E85\u0E8B\u0EA4\u0EA6\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F01-\u0F17\u0F1A-\u0F1F\u0F2A-\u0F34\u0F36\u0F38\u0F3A-\u0F3D\u0F48\u0F6D-\u0F70\u0F85\u0F98\u0FBD-\u0FC5\u0FC7-\u0FFF\u104A-\u104F\u109E\u109F\u10C6\u10C8-\u10CC\u10CE\u10CF\u10FB\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u1360-\u137F\u1390-\u139F\u13F6\u13F7\u13FE-\u1400\u166D\u166E\u1680\u169B-\u169F\u16EB-\u16ED\u16F9-\u16FF\u170D\u1715-\u171F\u1735-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17D4-\u17D6\u17D8-\u17DB\u17DE\u17DF\u17EA-\u180A\u180E\u180F\u181A-\u181F\u1879-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u1945\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DA-\u19FF\u1A1C-\u1A1F\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1AA6\u1AA8-\u1AAF\u1AC1-\u1AFF\u1B4C-\u1B4F\u1B5A-\u1B6A\u1B74-\u1B7F\u1BF4-\u1BFF\u1C38-\u1C3F\u1C4A-\u1C4C\u1C7E\u1C7F\u1C89-\u1C8F\u1CBB\u1CBC\u1CC0-\u1CCF\u1CD3\u1CFB-\u1CFF\u1DFA\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FBD\u1FBF-\u1FC1\u1FC5\u1FCD-\u1FCF\u1FD4\u1FD5\u1FDC-\u1FDF\u1FED-\u1FF1\u1FF5\u1FFD-\u203E\u2041-\u2053\u2055-\u2070\u2072-\u207E\u2080-\u208F\u209D-\u20CF\u20F1-\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F-\u215F\u2189-\u24B5\u24EA-\u2BFF\u2C2F\u2C5F\u2CE5-\u2CEA\u2CF4-\u2CFF\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D70-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E00-\u2E2E\u2E30-\u3004\u3008-\u3020\u3030\u3036\u3037\u303D-\u3040\u3097\u3098\u309B\u309C\u30A0\u30FB\u3100-\u3104\u3130\u318F-\u319F\u31C0-\u31EF\u3200-\u33FF\u4DC0-\u4DFF\u9FFD-\u9FFF\uA48D-\uA4CF\uA4FE\uA4FF\uA60D-\uA60F\uA62C-\uA63F\uA673\uA67E\uA6F2-\uA716\uA720\uA721\uA789\uA78A\uA7C0\uA7C1\uA7CB-\uA7F4\uA828-\uA82B\uA82D-\uA83F\uA874-\uA87F\uA8C6-\uA8CF\uA8DA-\uA8DF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA954-\uA95F\uA97D-\uA97F\uA9C1-\uA9CE\uA9DA-\uA9DF\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A-\uAA5F\uAA77-\uAA79\uAAC3-\uAADA\uAADE\uAADF\uAAF0\uAAF1\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB5B\uAB6A-\uAB6F\uABEB\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uE000-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB29\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBB2-\uFBD2\uFD3E-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFC-\uFDFF\uFE10-\uFE1F\uFE30-\uFE32\uFE35-\uFE4C\uFE50-\uFE6F\uFE75\uFEFD-\uFF0F\uFF1A-\uFF20\uFF3B-\uFF3E\uFF40\uFF5B-\uFF65\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFFF]|\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDD3F\uDD75-\uDDFC\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEE1-\uDEFF\uDF20-\uDF2C\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDF9F\uDFC4-\uDFC7\uDFD0\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56-\uDC5F\uDC77-\uDC7F\uDC9F-\uDCDF\uDCF3\uDCF6-\uDCFF\uDD16-\uDD1F\uDD3A-\uDD7F\uDDB8-\uDDBD\uDDC0-\uDDFF\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE36\uDE37\uDE3B-\uDE3E\uDE40-\uDE5F\uDE7D-\uDE7F\uDE9D-\uDEBF\uDEC8\uDEE7-\uDEFF\uDF36-\uDF3F\uDF56-\uDF5F\uDF73-\uDF7F\uDF92-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCFF\uDD28-\uDD2F\uDD3A-\uDE7F\uDEAA\uDEAD-\uDEAF\uDEB2-\uDEFF\uDF1D-\uDF26\uDF28-\uDF2F\uDF51-\uDFAF\uDFC5-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC47-\uDC65\uDC70-\uDC7E\uDCBB-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD40-\uDD43\uDD48-\uDD4F\uDD74\uDD75\uDD77-\uDD7F\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDFF\uDE12\uDE38-\uDE3D\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEA9-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC4B-\uDC4F\uDC5A-\uDC5D\uDC62-\uDC7F\uDCC6\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDC1-\uDDD7\uDDDE-\uDDFF\uDE41-\uDE43\uDE45-\uDE4F\uDE5A-\uDE7F\uDEB9-\uDEBF\uDECA-\uDEFF\uDF1B\uDF1C\uDF2C-\uDF2F\uDF3A-\uDFFF]|\uD806[\uDC3B-\uDC9F\uDCEA-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD36\uDD39\uDD3A\uDD44-\uDD4F\uDD5A-\uDD9F\uDDA8\uDDA9\uDDD8\uDDD9\uDDE2\uDDE5-\uDDFF\uDE3F-\uDE46\uDE48-\uDE4F\uDE9A-\uDE9C\uDE9E-\uDEBF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC41-\uDC4F\uDC5A-\uDC71\uDC90\uDC91\uDCA8\uDCB7-\uDCFF\uDD07\uDD0A\uDD37-\uDD39\uDD3B\uDD3E\uDD48-\uDD4F\uDD5A-\uDD5F\uDD66\uDD69\uDD8F\uDD92\uDD99-\uDD9F\uDDAA-\uDEDF\uDEF7-\uDFAF\uDFB1-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD824-\uD82B\uD82D\uD82E\uD830-\uD833\uD837\uD839\uD83D\uD83F\uD87B-\uD87D\uD87F\uD885-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDECF\uDEEE\uDEEF\uDEF5-\uDEFF\uDF37-\uDF3F\uDF44-\uDF4F\uDF5A-\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE80-\uDEFF\uDF4B-\uDF4E\uDF88-\uDF8E\uDFA0-\uDFDF\uDFE2\uDFE5-\uDFEF\uDFF2-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82C[\uDD1F-\uDD4F\uDD53-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A-\uDC9C\uDC9F-\uDFFF]|\uD834[\uDC00-\uDD64\uDD6A-\uDD6C\uDD73-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDE41\uDE45-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3\uDFCC\uDFCD]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDCFF\uDD2D-\uDD2F\uDD3E\uDD3F\uDD4A-\uDD4D\uDD4F-\uDEBF\uDEFA-\uDFFF]|\uD83A[\uDCC5-\uDCCF\uDCD7-\uDCFF\uDD4C-\uDD4F\uDD5A-\uDFFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDFFF]|\uD83C[\uDC00-\uDD2F\uDD4A-\uDD4F\uDD6A-\uDD6F\uDD8A-\uDFFF]|\uD83E[\uDC00-\uDFEF\uDFFA-\uDFFF]|\uD869[\uDEDE-\uDEFF]|\uD86D[\uDF35-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]/g;
var own = Object.hasOwnProperty, BananaSlug = class {
	constructor() {
		this.occurrences, this.reset();
	}
	slug(value, maintainCase) {
		let self$1 = this, result = slug(value, maintainCase === !0), originalSlug = result;
		for (; own.call(self$1.occurrences, result);) self$1.occurrences[originalSlug]++, result = originalSlug + "-" + self$1.occurrences[originalSlug];
		return self$1.occurrences[result] = 0, result;
	}
	reset() {
		this.occurrences = Object.create(null);
	}
};
function slug(value, maintainCase) {
	return typeof value == "string" ? (maintainCase || (value = value.toLowerCase()), value.replace(regex, "").replace(/ /g, "-")) : "";
}
function headingRank(node$1) {
	let name$1 = node$1.type === "element" ? node$1.tagName.toLowerCase() : "", code$4 = name$1.length === 2 && name$1.charCodeAt(0) === 104 ? name$1.charCodeAt(1) : 0;
	return code$4 > 48 && code$4 < 55 ? code$4 - 48 : void 0;
}
function toString$1(node$1) {
	return "children" in node$1 ? all(node$1) : "value" in node$1 ? node$1.value : "";
}
function one(node$1) {
	return node$1.type === "text" ? node$1.value : "children" in node$1 ? all(node$1) : "";
}
function all(node$1) {
	let index$2 = -1, result = [];
	for (; ++index$2 < node$1.children.length;) result[index$2] = one(node$1.children[index$2]);
	return result.join("");
}
var emptyOptions = {}, slugs = new BananaSlug();
function rehypeSlug(options) {
	let prefix = (options || emptyOptions).prefix || "";
	return function(tree) {
		slugs.reset(), visit(tree, "element", function(node$1) {
			headingRank(node$1) && !node$1.properties.id && (node$1.properties.id = prefix + slugs.slug(toString$1(node$1)));
		});
	};
}
function MarkdownRenderer({ content: content$2, className }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		className: cn("prose max-w-none", className),
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Markdown, {
			remarkPlugins: [remarkGfm],
			rehypePlugins: [rehypeHighlight, rehypeSlug],
			components: {
				a({ href, children, ...props }) {
					let isExternal = href?.startsWith("http");
					return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("a", {
						href,
						target: isExternal ? "_blank" : void 0,
						rel: isExternal ? "noopener noreferrer" : void 0,
						...props,
						children
					});
				},
				table({ children, ...props }) {
					return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						className: "overflow-x-auto my-6",
						children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("table", {
							...props,
							children
						})
					});
				}
			},
			children: content$2
		})
	});
}
function TableOfContents({ items, className }) {
	let [activeId, setActiveId] = useState("");
	useEffect(() => {
		let observer = new IntersectionObserver((entries) => {
			entries.forEach((entry) => {
				entry.isIntersecting && setActiveId(entry.target.id);
			});
		}, { rootMargin: "-80px 0px -80% 0px" });
		return items.forEach((item) => {
			let element$3 = document.getElementById(item.id);
			element$3 && observer.observe(element$3);
		}), () => observer.disconnect();
	}, [items]);
	let handleClick = (e, id) => {
		e.preventDefault();
		let element$3 = document.getElementById(id);
		if (element$3) {
			let offsetPosition = element$3.getBoundingClientRect().top + window.pageYOffset - 100;
			window.scrollTo({
				top: offsetPosition,
				behavior: "smooth"
			});
		}
	};
	return items.length === 0 ? null : /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("nav", {
		className: cn("space-y-1", className),
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
			className: "text-sm font-semibold text-foreground mb-3",
			children: "On this page"
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("ul", {
			className: "space-y-1 text-sm",
			children: items.map((item, index$2) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("li", { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("a", {
				href: `#${item.id}`,
				onClick: (e) => handleClick(e, item.id),
				className: cn("block py-1 transition-colors hover:text-foreground", item.level === 2 && "pl-0", item.level === 3 && "pl-4", item.level === 4 && "pl-8", activeId === item.id ? "text-primary font-medium" : "text-muted-foreground"),
				children: item.text
			}) }, `${item.id}-${index$2}`))
		})]
	});
}
function extractTocFromMarkdown(markdown$1) {
	let headingRegex = /^(#{2,4})\s+(.+)$/gm, items = [], match;
	for (; (match = headingRegex.exec(markdown$1)) !== null;) {
		let level = match[1].length, text$6 = match[2].trim(), id = text$6.toLowerCase().replace(/[^\w\s-]/g, "").replace(/\s+/g, "-");
		items.push({
			id,
			text: text$6,
			level
		});
	}
	return items;
}
function DocPage({ content: content$2, title, description, prevPage, nextPage, lastUpdated, className, docs: docs$1 }) {
	let tocItems = useMemo(() => extractTocFromMarkdown(content$2), [content$2]), [copied, setCopied] = useState(!1);
	return useEffect(() => {
		window.scrollTo({
			top: 0,
			behavior: "smooth"
		});
	}, [content$2, title]), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DocsLayout, {
		showToc: tocItems.length > 0,
		tocContent: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableOfContents, { items: tocItems }),
		docs: docs$1,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("article", {
			className: cn("min-w-0", className),
			children: [
				(title || description) && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("header", {
					className: "mb-8 relative pr-10",
					children: [
						title && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("h1", {
							className: "text-3xl font-bold tracking-tight text-foreground sm:text-4xl",
							children: title
						}),
						description && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
							className: "mt-2 text-lg text-muted-foreground",
							children: description
						}),
						/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Button, {
							variant: "ghost",
							size: "icon",
							onClick: async () => {
								await navigator.clipboard.writeText(content$2), setCopied(!0), setTimeout(() => setCopied(!1), 2e3);
							},
							className: "absolute right-0 top-0",
							"aria-label": "Copy content",
							children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Icon, {
								icon: copied ? Check : Copy,
								size: "sm"
							})
						})
					]
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(MarkdownRenderer, { content: content$2 }),
				(prevPage || nextPage || lastUpdated) && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("footer", {
					className: "mt-12 border-t border-border pt-6",
					children: [lastUpdated && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("p", {
						className: "text-sm text-muted-foreground mb-6",
						children: ["Last updated: ", lastUpdated]
					}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("nav", {
						className: "flex items-center justify-between gap-4",
						children: [prevPage ? /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Link, {
							to: prevPage.href,
							className: "group flex flex-col items-start gap-1 rounded-lg border border-border p-4 transition-colors hover:bg-accent",
							children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("span", {
								className: "flex items-center gap-1 text-xs text-muted-foreground",
								children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Icon, {
									icon: ChevronLeft,
									size: "xs"
								}), "Previous"]
							}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
								className: "font-medium group-hover:text-primary",
								children: prevPage.title
							})]
						}) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {}), nextPage && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Link, {
							to: nextPage.href,
							className: "group flex flex-col items-end gap-1 rounded-lg border border-border p-4 transition-colors hover:bg-accent",
							children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("span", {
								className: "flex items-center gap-1 text-xs text-muted-foreground",
								children: ["Next", /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Icon, {
									icon: ChevronRight,
									size: "xs"
								})]
							}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
								className: "font-medium group-hover:text-primary",
								children: nextPage.title
							})]
						})]
					})]
				})
			]
		})
	});
}
function FeatureCard$1({ title, description, href, icon }) {
	let content$2 = /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: cn("group rounded-xl border border-border bg-card p-6 transition-all", href && "hover:border-primary/50 hover:shadow-lg hover:shadow-primary/5"),
		children: [
			icon && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "mb-4 inline-flex h-10 w-10 items-center justify-center rounded-lg bg-primary/10 text-primary",
				children: icon
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("h3", {
				className: "font-semibold text-foreground mb-2",
				children: title
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
				className: "text-sm text-muted-foreground",
				children: description
			}),
			href && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "mt-4 flex items-center gap-1 text-sm font-medium text-primary",
				children: ["Learn more", /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Icon, {
					icon: ArrowRight,
					size: "sm",
					className: "transition-transform group-hover:translate-x-1"
				})]
			})
		]
	});
	return href ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Link, {
		to: href,
		children: content$2
	}) : content$2;
}
function HomePage({ title, description, features, primaryAction, secondaryAction, children }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DocsLayout, {
		showSidebar: !1,
		showToc: !1,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
			className: "py-12 lg:py-20",
			children: [
				/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
					className: "text-center max-w-3xl mx-auto mb-16",
					children: [
						/* @__PURE__ */ (0, import_jsx_runtime.jsx)("h1", {
							className: "text-4xl font-bold tracking-tight text-foreground sm:text-5xl lg:text-6xl",
							children: title
						}),
						/* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
							className: "mt-6 text-lg text-muted-foreground leading-relaxed",
							children: description
						}),
						(primaryAction || secondaryAction) && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
							className: "mt-8 flex flex-wrap items-center justify-center gap-4",
							children: [primaryAction && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Link, {
								to: primaryAction.href,
								className: "inline-flex items-center justify-center h-10 px-6 text-base rounded-md font-medium bg-primary text-primary-foreground hover:bg-primary/90 transition-colors",
								children: [primaryAction.label, /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Icon, {
									icon: ArrowRight,
									size: "sm",
									className: "ml-2"
								})]
							}), secondaryAction && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Link, {
								to: secondaryAction.href,
								className: "inline-flex items-center justify-center h-10 px-6 text-base rounded-md font-medium border border-input bg-background hover:bg-accent hover:text-accent-foreground transition-colors",
								children: secondaryAction.label
							})]
						})
					]
				}),
				features && features.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: "grid gap-6 sm:grid-cols-2 lg:grid-cols-3",
					children: features.map((feature, i$2) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FeatureCard$1, { ...feature }, i$2))
				}),
				children
			]
		})
	});
}
var containerSizes = {
	sm: "max-w-3xl",
	md: "max-w-5xl",
	lg: "max-w-6xl",
	xl: "max-w-7xl",
	full: "max-w-full"
};
function Container({ size = "xl", className, children, ...props }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		className: cn("mx-auto w-full px-4 sm:px-6 lg:px-8", containerSizes[size], className),
		...props,
		children
	});
}
var spacingStyles = {
	none: "",
	sm: "py-12 md:py-16",
	md: "py-16 md:py-24",
	lg: "py-24 md:py-32",
	xl: "py-32 md:py-40"
}, themeStyles = {
	light: "bg-background text-foreground",
	dark: "bg-foreground text-background",
	gradient: "bg-gradient-to-b from-background to-muted",
	muted: "bg-muted/50"
};
function Section({ spacing = "lg", theme, className, children, as: Component = "section", ...props }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		className: cn(spacingStyles[spacing], theme && themeStyles[theme], className),
		...props,
		children
	});
}
var gradientPresets = {
	"purple-blue": "from-purple-500 via-violet-500 to-blue-500",
	"cyan-blue": "from-cyan-400 via-blue-500 to-purple-600",
	"pink-purple": "from-pink-500 via-purple-500 to-indigo-500",
	"orange-red": "from-orange-500 via-red-500 to-pink-500",
	"green-cyan": "from-green-400 via-cyan-500 to-blue-500",
	"blue-purple": "from-blue-500 via-purple-500 to-pink-500",
	sunset: "from-orange-400 via-pink-500 to-purple-600",
	ocean: "from-cyan-500 via-blue-500 to-indigo-600",
	gray: "from-foreground via-foreground/80 to-foreground/60"
};
function GradientText({ children, gradient = "cyan-blue", customGradient, animate = !1, className, as: Component = "span", ...props }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		className: cn("bg-gradient-to-r bg-clip-text text-transparent", gradient === "custom" && customGradient ? customGradient : gradientPresets[gradient], animate && "animate-gradient bg-[length:200%_auto]", className),
		...props,
		children
	});
}
var alignStyles = {
	left: "text-left",
	center: "text-center mx-auto",
	right: "text-right ml-auto"
}, titleSizes = {
	sm: "text-2xl md:text-3xl",
	md: "text-3xl md:text-4xl",
	lg: "text-4xl md:text-5xl lg:text-6xl",
	xl: "text-5xl md:text-6xl lg:text-7xl"
}, subtitleSizes = {
	sm: "text-base md:text-lg",
	md: "text-lg md:text-xl",
	lg: "text-xl md:text-2xl",
	xl: "text-xl md:text-2xl"
};
function SectionTitle({ title, subtitle, label, labelGradient = "cyan-blue", align = "center", size = "lg", maxWidth = "max-w-3xl", className, titleClassName, subtitleClassName, labelClassName, ...props }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: cn(alignStyles[align], maxWidth, className),
		...props,
		children: [
			label && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(GradientText, {
				gradient: labelGradient,
				className: cn("mb-4 block text-sm font-semibold uppercase tracking-wider", labelClassName),
				children: label
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("h2", {
				className: cn("font-bold tracking-tight", titleSizes[size], titleClassName),
				children: title
			}),
			subtitle && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
				className: cn("mt-4 text-muted-foreground", subtitleSizes[size], subtitleClassName),
				children: subtitle
			})
		]
	});
}
var variantStyles$9 = {
	underline: {
		primary: "decoration-primary underline decoration-2 underline-offset-4",
		secondary: "decoration-secondary underline decoration-2 underline-offset-4",
		cyan: "decoration-cyan-500 underline decoration-2 underline-offset-4",
		purple: "decoration-purple-500 underline decoration-2 underline-offset-4",
		pink: "decoration-pink-500 underline decoration-2 underline-offset-4",
		green: "decoration-green-500 underline decoration-2 underline-offset-4"
	},
	background: {
		primary: "bg-primary/10 px-1 rounded",
		secondary: "bg-secondary/50 px-1 rounded",
		cyan: "bg-cyan-500/10 px-1 rounded",
		purple: "bg-purple-500/10 px-1 rounded",
		pink: "bg-pink-500/10 px-1 rounded",
		green: "bg-green-500/10 px-1 rounded"
	},
	box: {
		primary: "border border-primary/50 px-1.5 py-0.5 rounded",
		secondary: "border border-secondary px-1.5 py-0.5 rounded",
		cyan: "border border-cyan-500/50 px-1.5 py-0.5 rounded",
		purple: "border border-purple-500/50 px-1.5 py-0.5 rounded",
		pink: "border border-pink-500/50 px-1.5 py-0.5 rounded",
		green: "border border-green-500/50 px-1.5 py-0.5 rounded"
	},
	glow: {
		primary: "text-primary drop-shadow-[0_0_10px_hsl(var(--primary)/0.5)]",
		secondary: "text-secondary-foreground",
		cyan: "text-cyan-500 drop-shadow-[0_0_10px_rgba(6,182,212,0.5)]",
		purple: "text-purple-500 drop-shadow-[0_0_10px_rgba(168,85,247,0.5)]",
		pink: "text-pink-500 drop-shadow-[0_0_10px_rgba(236,72,153,0.5)]",
		green: "text-green-500 drop-shadow-[0_0_10px_rgba(34,197,94,0.5)]"
	}
};
function Highlight({ children, variant = "underline", color: color$1 = "primary", className, ...props }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
		className: cn(variantStyles$9[variant][color$1], className),
		...props,
		children
	});
}
var sizeStyles$3 = {
	sm: {
		title: "text-3xl md:text-4xl lg:text-5xl",
		subtitle: "text-lg md:text-xl",
		padding: "py-16 md:py-20"
	},
	md: {
		title: "text-4xl md:text-5xl lg:text-6xl",
		subtitle: "text-lg md:text-xl",
		padding: "py-20 md:py-28"
	},
	lg: {
		title: "text-4xl md:text-5xl lg:text-6xl xl:text-7xl",
		subtitle: "text-xl md:text-2xl",
		padding: "py-24 md:py-32"
	},
	xl: {
		title: "text-5xl md:text-6xl lg:text-7xl xl:text-8xl",
		subtitle: "text-xl md:text-2xl",
		padding: "py-32 md:py-40"
	}
}, actionVariantStyles$1 = {
	primary: "bg-primary text-primary-foreground hover:bg-primary/90 shadow-lg hover:shadow-xl transition-all",
	secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
	outline: "border border-border bg-transparent hover:bg-accent hover:text-accent-foreground",
	ghost: "hover:bg-accent hover:text-accent-foreground"
};
function Hero({ title, titleGradient, titleGradientPreset = "cyan-blue", subtitle, badge, actions, media, layout = "centered", size = "lg", containerSize = "xl", backgroundElement, className, titleClassName, subtitleClassName, contentAlign = "center", ...props }) {
	let styles = sizeStyles$3[size], centeredContentAlignment = {
		left: "text-left mr-auto max-w-4xl",
		center: "text-center mx-auto max-w-4xl",
		right: "text-right ml-auto max-w-4xl"
	}, centeredActionsAlignment = {
		left: "justify-start",
		center: "justify-center",
		right: "justify-end"
	}, renderTitle = () => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("h1", {
		className: cn("font-bold tracking-tight leading-tight", styles.title, titleClassName),
		children: [title, titleGradient && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("br", {}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(GradientText, {
			gradient: titleGradientPreset,
			className: styles.title,
			children: titleGradient
		})] })]
	}), renderContent = () => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: cn(layout === "centered" && centeredContentAlignment[contentAlign], layout !== "centered" && "max-w-xl"),
		children: [
			badge && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "mb-6",
				children: badge
			}),
			renderTitle(),
			subtitle && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
				className: cn("mt-6 text-muted-foreground leading-relaxed", styles.subtitle, subtitleClassName),
				children: subtitle
			}),
			actions && actions.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: cn("mt-8 flex flex-wrap gap-4", layout === "centered" && centeredActionsAlignment[contentAlign]),
				children: actions.map((action, index$2) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(action.href ? "a" : "button", {
					href: action.href,
					onClick: action.onClick,
					className: cn("inline-flex items-center justify-center gap-2 rounded-full px-6 py-3 text-sm font-medium transition-all", "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2", actionVariantStyles$1[action.variant || "primary"]),
					children: [
						action.icon && action.iconPosition !== "right" && action.icon,
						action.label,
						action.icon && action.iconPosition === "right" && action.icon
					]
				}, index$2))
			})
		]
	});
	return layout === "centered" ? /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("section", {
		className: cn("relative overflow-hidden", styles.padding, className),
		...props,
		children: [backgroundElement && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: "absolute inset-0 -z-10",
			children: backgroundElement
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Container, {
			size: containerSize,
			children: [renderContent(), media && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "mt-12 lg:mt-16",
				children: media
			})]
		})]
	}) : /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("section", {
		className: cn("relative overflow-hidden", styles.padding, className),
		...props,
		children: [backgroundElement && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: "absolute inset-0 -z-10",
			children: backgroundElement
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Container, {
			size: containerSize,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: cn("grid items-center gap-12 lg:grid-cols-2 lg:gap-16", layout === "split-reverse" && "lg:grid-flow-dense"),
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: layout === "split-reverse" ? "lg:col-start-2" : "",
					children: renderContent()
				}), media && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: layout === "split-reverse" ? "lg:col-start-1" : "",
					children: media
				})]
			})
		})]
	});
}
var variantStyles$8 = {
	default: "bg-secondary text-secondary-foreground",
	outline: "border border-border bg-transparent",
	gradient: "bg-gradient-to-r from-primary/10 to-purple-500/10 border border-primary/20",
	glow: "bg-primary/10 border border-primary/20 shadow-[0_0_20px_rgba(var(--primary)/0.3)]"
};
function HeroBadge({ children, variant = "default", icon, href, showArrow = !1, className, ...props }) {
	let content$2 = /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
		icon && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
			className: "mr-2",
			children: icon
		}),
		/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { children }),
		showArrow && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ChevronRight, { className: "ml-1 h-3 w-3" })
	] }), baseStyles = cn("inline-flex items-center rounded-full px-4 py-1.5 text-sm font-medium transition-colors", variantStyles$8[variant], href && "cursor-pointer hover:bg-accent/80", className);
	return href ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("a", {
		href,
		className: baseStyles,
		...props,
		children: content$2
	}) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		className: baseStyles,
		...props,
		children: content$2
	});
}
function HeroBackground({ variant = "gradient", className, primaryColor = "rgba(6, 182, 212, 0.15)", secondaryColor = "rgba(168, 85, 247, 0.15)" }) {
	switch (variant) {
		case "gradient": return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: cn("absolute inset-0", className),
			style: { background: `radial-gradient(ellipse 80% 50% at 50% -20%, ${primaryColor}, transparent)` }
		});
		case "grid": return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
			className: cn("absolute inset-0", className),
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "absolute inset-0",
				style: {
					backgroundImage: "linear-gradient(to right, hsl(var(--border)) 1px, transparent 1px), linear-gradient(to bottom, hsl(var(--border)) 1px, transparent 1px)",
					backgroundSize: "4rem 4rem"
				}
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "absolute inset-0",
				style: { background: `radial-gradient(ellipse 80% 50% at 50% 0%, ${primaryColor}, transparent)` }
			})]
		});
		case "dots": return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
			className: cn("absolute inset-0", className),
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "absolute inset-0 opacity-50",
				style: {
					backgroundImage: "radial-gradient(circle at 1px 1px, hsl(var(--muted-foreground)) 1px, transparent 0)",
					backgroundSize: "2rem 2rem"
				}
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "absolute inset-0",
				style: { background: `radial-gradient(ellipse 60% 40% at 50% 0%, ${primaryColor}, transparent)` }
			})]
		});
		case "radial": return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: cn("absolute inset-0", className),
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "absolute inset-0",
				style: { background: `
                radial-gradient(circle at 20% 20%, ${primaryColor} 0%, transparent 40%),
                radial-gradient(circle at 80% 80%, ${secondaryColor} 0%, transparent 40%)
              ` }
			})
		});
		case "mesh": return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: cn("absolute inset-0 overflow-hidden", className),
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "absolute -inset-[100%] animate-spin-slow",
				style: {
					background: `
                radial-gradient(circle at 25% 25%, ${primaryColor} 0%, transparent 50%),
                radial-gradient(circle at 75% 75%, ${secondaryColor} 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(168, 85, 247, 0.1) 0%, transparent 50%)
              `,
					animationDuration: "60s"
				}
			})
		});
		case "aurora": return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: cn("absolute inset-0 overflow-hidden", className),
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "absolute -top-1/2 left-1/2 -translate-x-1/2 w-[200%] aspect-[16/9]",
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: "absolute inset-0 blur-3xl",
					style: { background: `
                  linear-gradient(135deg, ${primaryColor} 0%, transparent 50%),
                  linear-gradient(225deg, ${secondaryColor} 0%, transparent 50%),
                  linear-gradient(315deg, rgba(59, 130, 246, 0.2) 0%, transparent 50%)
                ` }
				})
			})
		});
		case "waves": return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: cn("absolute inset-0 overflow-hidden", className),
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("svg", {
				className: "absolute bottom-0 w-full h-1/2",
				viewBox: "0 0 1440 320",
				preserveAspectRatio: "none",
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("linearGradient", {
					id: "waveGradient",
					x1: "0%",
					y1: "0%",
					x2: "100%",
					y2: "0%",
					children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("stop", {
						offset: "0%",
						stopColor: primaryColor
					}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("stop", {
						offset: "100%",
						stopColor: secondaryColor
					})]
				}) }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", {
					fill: "url(#waveGradient)",
					d: "M0,160L48,176C96,192,192,224,288,213.3C384,203,480,149,576,138.7C672,128,768,160,864,181.3C960,203,1056,213,1152,197.3C1248,181,1344,139,1392,117.3L1440,96L1440,320L1392,320C1344,320,1248,320,1152,320C1056,320,960,320,864,320C768,320,672,320,576,320C480,320,384,320,288,320C192,320,96,320,48,320L0,320Z"
				})]
			})
		});
		default: return null;
	}
}
var variantStyles$7 = {
	default: "bg-card",
	bordered: "bg-card border border-border",
	elevated: "bg-card shadow-lg hover:shadow-xl transition-shadow",
	glass: "bg-white/5 backdrop-blur-xl border border-white/10",
	gradient: "bg-gradient-to-br from-card to-muted border border-border"
}, sizeStyles$2 = {
	sm: {
		padding: "p-4",
		icon: "w-8 h-8",
		title: "text-base",
		desc: "text-sm"
	},
	md: {
		padding: "p-6",
		icon: "w-10 h-10",
		title: "text-lg",
		desc: "text-base"
	},
	lg: {
		padding: "p-8",
		icon: "w-12 h-12",
		title: "text-xl",
		desc: "text-base"
	}
};
function FeatureCard({ icon, title, description, variant = "bordered", size = "md", iconBackground, href, action, className, ...props }) {
	let styles = sizeStyles$2[size], content$2 = /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
		icon && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: cn("flex items-center justify-center rounded-xl mb-4", styles.icon, iconBackground || "bg-primary/10 text-primary"),
			children: icon
		}),
		/* @__PURE__ */ (0, import_jsx_runtime.jsx)("h3", {
			className: cn("font-semibold text-foreground mb-2", styles.title),
			children: title
		}),
		/* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
			className: cn("text-muted-foreground leading-relaxed", styles.desc),
			children: description
		}),
		action && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: "mt-4",
			children: action
		})
	] }), baseStyles = cn("rounded-xl transition-all", styles.padding, variantStyles$7[variant], href && "cursor-pointer hover:border-primary/50", className);
	return href ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("a", {
		href,
		className: baseStyles,
		...props,
		children: content$2
	}) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		className: baseStyles,
		...props,
		children: content$2
	});
}
var columnStyles$5 = {
	2: "grid-cols-1 md:grid-cols-2",
	3: "grid-cols-1 md:grid-cols-2 lg:grid-cols-3",
	4: "grid-cols-1 sm:grid-cols-2 lg:grid-cols-4",
	6: "grid-cols-2 sm:grid-cols-3 lg:grid-cols-6"
}, gapStyles = {
	sm: "gap-4",
	md: "gap-6",
	lg: "gap-8"
};
function FeatureGrid({ title, subtitle, label, labelGradient, titleAlign = "center", titleSize = "lg", columns = 3, gap = "md", containerSize = "xl", children, className, ...props }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("section", {
		className: cn("py-16 md:py-24", className),
		...props,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Container, {
			size: containerSize,
			children: [(title || subtitle || label) && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SectionTitle, {
				title,
				subtitle,
				label,
				labelGradient,
				align: titleAlign,
				size: titleSize,
				className: "mb-12 md:mb-16"
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: cn("grid", columnStyles$5[columns], gapStyles[gap]),
				children
			})]
		})
	});
}
function FeatureShowcase({ label, labelGradient = "purple-blue", title, description, features, media, layout = "left", containerSize = "xl", action, className, ...props }) {
	let contentOrder = layout === "left" ? "order-1" : "order-1 lg:order-2", mediaOrder = layout === "left" ? "order-2" : "order-2 lg:order-1";
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("section", {
		className: cn("py-16 md:py-24", className),
		...props,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Container, {
			size: containerSize,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "grid items-center gap-12 lg:grid-cols-2 lg:gap-16",
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
					className: contentOrder,
					children: [
						label && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(GradientText, {
							gradient: labelGradient,
							className: "mb-4 block text-sm font-semibold uppercase tracking-wider",
							children: label
						}),
						/* @__PURE__ */ (0, import_jsx_runtime.jsx)("h2", {
							className: "text-3xl font-bold tracking-tight md:text-4xl lg:text-5xl",
							children: title
						}),
						description && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
							className: "mt-4 text-lg text-muted-foreground leading-relaxed",
							children: description
						}),
						features && features.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
							className: "mt-8 grid gap-6 sm:grid-cols-2",
							children: features.map((feature, index$2) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
								className: "flex gap-4",
								children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
									className: "flex h-10 w-10 shrink-0 items-center justify-center rounded-lg bg-primary/10 text-primary",
									children: feature.icon
								}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("h3", {
									className: "font-semibold",
									children: feature.title
								}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
									className: "mt-1 text-sm text-muted-foreground",
									children: feature.description
								})] })]
							}, index$2))
						}),
						action && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
							className: "mt-8",
							children: action
						})
					]
				}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: mediaOrder,
					children: media
				})]
			})
		})
	});
}
var columnStyles$4 = {
	1: "grid-cols-1",
	2: "grid-cols-1 sm:grid-cols-2",
	3: "grid-cols-1 sm:grid-cols-2 lg:grid-cols-3"
};
function FeatureList({ items, variant = "checkmark", columns = 1, iconColor = "text-primary", className, ...props }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("ul", {
		className: cn("grid gap-3", columnStyles$4[columns], className),
		...props,
		children: items.map((item, index$2) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("li", {
			className: "flex items-start gap-3",
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("span", {
				className: cn("mt-0.5 shrink-0", iconColor),
				children: [
					variant === "checkmark" && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Check, { className: "h-5 w-5" }),
					variant === "numbered" && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
						className: "flex h-6 w-6 items-center justify-center rounded-full bg-primary/10 text-xs font-semibold",
						children: index$2 + 1
					}),
					variant === "icon" && item.icon,
					variant === "default" && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { className: "block h-1.5 w-1.5 rounded-full bg-current mt-2" })
				]
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
				className: "text-muted-foreground",
				children: item.text
			})]
		}, index$2))
	});
}
var variantColorStyles = {
	filled: {
		primary: "bg-primary/10 text-primary",
		secondary: "bg-secondary text-secondary-foreground",
		cyan: "bg-cyan-500/10 text-cyan-500",
		purple: "bg-purple-500/10 text-purple-500",
		pink: "bg-pink-500/10 text-pink-500",
		green: "bg-green-500/10 text-green-500",
		orange: "bg-orange-500/10 text-orange-500"
	},
	outlined: {
		primary: "border border-primary/30 text-primary",
		secondary: "border border-border text-secondary-foreground",
		cyan: "border border-cyan-500/30 text-cyan-500",
		purple: "border border-purple-500/30 text-purple-500",
		pink: "border border-pink-500/30 text-pink-500",
		green: "border border-green-500/30 text-green-500",
		orange: "border border-orange-500/30 text-orange-500"
	},
	gradient: {
		primary: "bg-gradient-to-br from-primary/20 to-primary/5 text-primary border border-primary/10",
		secondary: "bg-gradient-to-br from-secondary to-secondary/50 text-secondary-foreground border border-border",
		cyan: "bg-gradient-to-br from-cyan-500/20 to-cyan-500/5 text-cyan-500 border border-cyan-500/10",
		purple: "bg-gradient-to-br from-purple-500/20 to-purple-500/5 text-purple-500 border border-purple-500/10",
		pink: "bg-gradient-to-br from-pink-500/20 to-pink-500/5 text-pink-500 border border-pink-500/10",
		green: "bg-gradient-to-br from-green-500/20 to-green-500/5 text-green-500 border border-green-500/10",
		orange: "bg-gradient-to-br from-orange-500/20 to-orange-500/5 text-orange-500 border border-orange-500/10"
	},
	glass: {
		primary: "bg-primary/5 backdrop-blur-xl border border-primary/20 text-primary",
		secondary: "bg-white/5 backdrop-blur-xl border border-white/10 text-secondary-foreground",
		cyan: "bg-cyan-500/5 backdrop-blur-xl border border-cyan-500/20 text-cyan-500",
		purple: "bg-purple-500/5 backdrop-blur-xl border border-purple-500/20 text-purple-500",
		pink: "bg-pink-500/5 backdrop-blur-xl border border-pink-500/20 text-pink-500",
		green: "bg-green-500/5 backdrop-blur-xl border border-green-500/20 text-green-500",
		orange: "bg-orange-500/5 backdrop-blur-xl border border-orange-500/20 text-orange-500"
	}
}, sizeStyles$1 = {
	sm: {
		box: "w-8 h-8 rounded-lg",
		icon: "w-4 h-4"
	},
	md: {
		box: "w-10 h-10 rounded-lg",
		icon: "w-5 h-5"
	},
	lg: {
		box: "w-12 h-12 rounded-xl",
		icon: "w-6 h-6"
	},
	xl: {
		box: "w-14 h-14 rounded-xl",
		icon: "w-7 h-7"
	}
};
function IconBox({ icon, variant = "filled", size = "md", color: color$1 = "primary", className, ...props }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		className: cn("flex items-center justify-center", sizeStyles$1[size].box, variantColorStyles[variant][color$1], className),
		...props,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: sizeStyles$1[size].icon,
			children: icon
		})
	});
}
var columnStyles$3 = {
	4: "grid-cols-2 sm:grid-cols-4",
	5: "grid-cols-2 sm:grid-cols-3 lg:grid-cols-5",
	6: "grid-cols-2 sm:grid-cols-3 lg:grid-cols-6",
	8: "grid-cols-2 sm:grid-cols-4 lg:grid-cols-8"
}, variantStyles$6 = {
	default: "",
	muted: "opacity-60 grayscale hover:opacity-100 hover:grayscale-0 transition-all",
	bordered: "border border-border rounded-lg p-4",
	cards: "bg-card border border-border rounded-xl p-6 hover:border-primary/50 transition-colors"
};
function LogoCloud({ title, logos, variant = "default", layout = "inline", containerSize = "xl", columns = 6, className, ...props }) {
	let renderLogo = (logo, index$2) => {
		let content$2 = /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: cn("flex items-center justify-center h-12", variant !== "default" && variantStyles$6[variant]),
			children: logo.logo
		});
		return logo.href ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("a", {
			href: logo.href,
			target: "_blank",
			rel: "noopener noreferrer",
			className: "flex items-center justify-center",
			title: logo.name,
			children: content$2
		}, index$2) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: "flex items-center justify-center",
			title: logo.name,
			children: content$2
		}, index$2);
	};
	return layout === "scroll" ? /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("section", {
		className: cn("py-12 overflow-hidden", className),
		...props,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Container, {
			size: containerSize,
			children: title && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
				className: "text-center text-sm font-medium text-muted-foreground uppercase tracking-wider mb-8",
				children: title
			})
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: "relative",
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "flex animate-scroll gap-12 hover:[animation-play-state:paused]",
				children: [...logos, ...logos].map((logo, index$2) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: "flex-shrink-0",
					children: renderLogo(logo, index$2)
				}, index$2))
			})
		})]
	}) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)("section", {
		className: cn("py-12", className),
		...props,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Container, {
			size: containerSize,
			children: [title && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
				className: "text-center text-sm font-medium text-muted-foreground uppercase tracking-wider mb-8",
				children: title
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: cn(layout === "grid" && `grid ${columnStyles$3[columns]} gap-8 items-center`, layout === "inline" && "flex flex-wrap items-center justify-center gap-x-12 gap-y-8"),
				children: logos.map((logo, index$2) => renderLogo(logo, index$2))
			})]
		})
	});
}
var variantStyles$5 = {
	default: {
		wrapper: "bg-[#1a1b26] border border-[#2a2b3d] rounded-xl overflow-hidden shadow-2xl",
		header: "bg-[#1a1b26] border-b border-[#2a2b3d]",
		body: "bg-[#1a1b26]"
	},
	minimal: {
		wrapper: "bg-card border border-border rounded-xl overflow-hidden",
		header: "bg-muted/50 border-b border-border",
		body: "bg-card"
	},
	gradient: {
		wrapper: "bg-gradient-to-br from-[#1a1b26] to-[#2d2e42] border border-[#3a3b52] rounded-xl overflow-hidden shadow-2xl",
		header: "bg-black/20 border-b border-white/5",
		body: ""
	},
	glass: {
		wrapper: "bg-white/5 backdrop-blur-xl border border-white/10 rounded-2xl overflow-hidden shadow-[0_20px_80px_rgba(15,23,42,0.25)]",
		header: "bg-white/10 border-b border-white/10",
		body: "bg-transparent"
	}
};
function CodeWindow({ code: code$4, language: language$1 = "typescript", filename, showLineNumbers = !0, highlightLines = [], variant = "default", showCopy = !0, header, className, ...props }) {
	let [copied, setCopied] = useState(!1), styles = variantStyles$5[variant], lines = code$4.split("\n"), handleCopy = async () => {
		await navigator.clipboard.writeText(code$4), setCopied(!0), setTimeout(() => setCopied(!1), 2e3);
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: cn(styles.wrapper, className),
		...props,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
			className: cn("flex items-center justify-between px-4 py-3", styles.header),
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "flex items-center gap-3",
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
						className: "flex gap-1.5",
						children: [
							/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { className: "w-3 h-3 rounded-full bg-red-500/80" }),
							/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { className: "w-3 h-3 rounded-full bg-yellow-500/80" }),
							/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { className: "w-3 h-3 rounded-full bg-green-500/80" })
						]
					}),
					filename && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
						className: "text-sm text-muted-foreground font-mono",
						children: filename
					}),
					header
				]
			}), showCopy && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("button", {
				onClick: handleCopy,
				className: "p-1.5 rounded-md hover:bg-white/10 transition-colors text-muted-foreground hover:text-foreground",
				"aria-label": "Copy code",
				children: copied ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Check, { className: "w-4 h-4" }) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Copy, { className: "w-4 h-4" })
			})]
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: cn("p-4 overflow-x-auto", styles.body),
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("pre", {
				className: "text-sm font-mono",
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("code", {
					className: `language-${language$1}`,
					children: lines.map((line, index$2) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
						className: cn("flex", highlightLines.includes(index$2 + 1) && "bg-primary/10 -mx-4 px-4"),
						children: [showLineNumbers && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
							className: "select-none w-8 text-right pr-4 text-muted-foreground/50",
							children: index$2 + 1
						}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
							className: "flex-1",
							dangerouslySetInnerHTML: { __html: highlightSyntax(line, language$1) }
						})]
					}, index$2))
				})
			})
		})]
	});
}
function highlightSyntax(line, language$1) {
	let patterns = {
		typescript: [
			{
				pattern: /(\/\/.*$)/gm,
				className: "text-gray-500"
			},
			{
				pattern: /\b(import|export|from|const|let|var|function|return|if|else|for|while|class|interface|type|extends|implements|new|this|async|await|try|catch|throw)\b/g,
				className: "text-purple-400"
			},
			{
				pattern: /\b(true|false|null|undefined)\b/g,
				className: "text-orange-400"
			},
			{
				pattern: /(['"`])((?:\\.|(?!\1)[^\\])*)\1/g,
				className: "text-green-400"
			},
			{
				pattern: /\b(\d+)\b/g,
				className: "text-orange-400"
			},
			{
				pattern: /\b([A-Z][a-zA-Z0-9]*)\b/g,
				className: "text-yellow-400"
			}
		],
		javascript: [
			{
				pattern: /(\/\/.*$)/gm,
				className: "text-gray-500"
			},
			{
				pattern: /\b(import|export|from|const|let|var|function|return|if|else|for|while|class|new|this|async|await|try|catch|throw)\b/g,
				className: "text-purple-400"
			},
			{
				pattern: /\b(true|false|null|undefined)\b/g,
				className: "text-orange-400"
			},
			{
				pattern: /(['"`])((?:\\.|(?!\1)[^\\])*)\1/g,
				className: "text-green-400"
			},
			{
				pattern: /\b(\d+)\b/g,
				className: "text-orange-400"
			}
		],
		python: [
			{
				pattern: /(#.*$)/gm,
				className: "text-gray-500"
			},
			{
				pattern: /\b(import|from|def|return|if|else|elif|for|while|class|with|as|try|except|raise|async|await|True|False|None)\b/g,
				className: "text-purple-400"
			},
			{
				pattern: /(['"])((?:\\.|(?!\1)[^\\])*)\1/g,
				className: "text-green-400"
			},
			{
				pattern: /\b(\d+)\b/g,
				className: "text-orange-400"
			}
		],
		go: [
			{
				pattern: /(\/\/.*$)/gm,
				className: "text-gray-500"
			},
			{
				pattern: /\b(package|import|func|return|if|else|for|range|struct|interface|type|var|const|defer|go|chan|select|case|default|nil|true|false)\b/g,
				className: "text-purple-400"
			},
			{
				pattern: /(['"`])((?:\\.|(?!\1)[^\\])*)\1/g,
				className: "text-green-400"
			},
			{
				pattern: /\b(\d+)\b/g,
				className: "text-orange-400"
			}
		]
	}, result = escapeHtml(line), langPatterns = patterns[language$1] || patterns.typescript;
	for (let { pattern, className } of langPatterns) result = result.replace(pattern, (match) => `<span class="${className}">${match}</span>`);
	return result;
}
function escapeHtml(text$6) {
	return text$6.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
function CodeTabs({ tabs, defaultTab = 0, variant = "default", showLineNumbers = !0, className, ...props }) {
	let [activeTab, setActiveTab] = useState(defaultTab), variantBg = {
		default: "bg-[#1a1b26]",
		minimal: "bg-card",
		gradient: "bg-gradient-to-br from-[#1a1b26] to-[#2d2e42]"
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: cn("rounded-xl overflow-hidden border", variant === "default" && "border-[#2a2b3d]", variant === "minimal" && "border-border", variant === "gradient" && "border-[#3a3b52]", className),
		...props,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: cn("flex items-center border-b overflow-x-auto", variantBg[variant], variant === "default" && "border-[#2a2b3d]", variant === "minimal" && "border-border", variant === "gradient" && "border-white/5"),
			children: tabs.map((tab$1, index$2) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("button", {
				onClick: () => setActiveTab(index$2),
				className: cn("px-4 py-3 text-sm font-medium whitespace-nowrap transition-colors", "border-b-2 -mb-px", activeTab === index$2 ? "border-primary text-foreground" : "border-transparent text-muted-foreground hover:text-foreground"),
				children: tab$1.label
			}, index$2))
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CodeWindow, {
			code: tabs[activeTab].code,
			language: tabs[activeTab].language,
			filename: tabs[activeTab].filename,
			variant,
			showLineNumbers,
			showCopy: !0,
			className: "rounded-none border-0"
		})]
	});
}
function CodeComparison({ before, after, variant = "default", showLineNumbers = !0, className, ...props }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: cn("grid gap-4 md:grid-cols-2", className),
		...props,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
			className: "space-y-2",
			children: [before.label && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
				className: "text-sm font-medium text-muted-foreground",
				children: before.label
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CodeWindow, {
				code: before.code,
				language: before.language,
				variant,
				showLineNumbers
			})]
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
			className: "space-y-2",
			children: [after.label && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
				className: "text-sm font-medium text-muted-foreground",
				children: after.label
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CodeWindow, {
				code: after.code,
				language: after.language,
				variant,
				showLineNumbers
			})]
		})]
	});
}
function APIResponse({ status = 200, statusText = "OK", response, className, ...props }) {
	let statusColor = status >= 200 && status < 300 ? "text-green-500" : status >= 400 ? "text-red-500" : "text-yellow-500", formatJSON = (obj) => JSON.stringify(obj, null, 2), highlightJSON = (json$1) => json$1.replace(/"([^"]+)":/g, "<span class=\"text-purple-400\">\"$1\"</span>:").replace(/: "([^"]+)"/g, ": <span class=\"text-green-400\">\"$1\"</span>").replace(/: (\d+)/g, ": <span class=\"text-orange-400\">$1</span>").replace(/: (true|false|null)/g, ": <span class=\"text-orange-400\">$1</span>");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: cn("bg-[#1a1b26] border border-[#2a2b3d] rounded-xl overflow-hidden", className),
		...props,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
			className: "flex items-center justify-between px-4 py-2 bg-[#1a1b26] border-b border-[#2a2b3d]",
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
				className: "text-sm text-muted-foreground font-mono",
				children: "Response"
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("span", {
				className: cn("text-sm font-medium", statusColor),
				children: [
					"HTTP ",
					status,
					" ",
					statusText && `- ${statusText}`
				]
			})]
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: "p-4 overflow-x-auto",
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("pre", {
				className: "text-sm font-mono",
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("code", { dangerouslySetInnerHTML: { __html: highlightJSON(formatJSON(response)) } })
			})
		})]
	});
}
var actionVariantStyles = {
	primary: "bg-primary text-primary-foreground hover:bg-primary/90 shadow-lg",
	secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
	outline: "border border-border bg-transparent hover:bg-accent",
	ghost: "hover:bg-accent hover:text-accent-foreground"
};
function CTASection({ title, description, actions, variant = "centered", gradient, containerSize = "lg", backgroundElement, media, className, ...props }) {
	let renderActions = () => actions?.map((action, index$2) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(action.href ? "a" : "button", {
		href: action.href,
		onClick: action.onClick,
		className: cn("inline-flex items-center justify-center gap-2 rounded-full px-6 py-3 text-sm font-medium transition-all", actionVariantStyles[action.variant || "primary"]),
		children: [action.icon && action.icon, action.label]
	}, index$2));
	return variant === "card" ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("section", {
		className: cn("py-16 md:py-24", className),
		...props,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Container, {
			size: containerSize,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "relative overflow-hidden rounded-2xl bg-muted/50 border border-border p-8 md:p-12 lg:p-16",
				children: [backgroundElement && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: "absolute inset-0 -z-10",
					children: backgroundElement
				}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
					className: "text-center max-w-2xl mx-auto",
					children: [
						/* @__PURE__ */ (0, import_jsx_runtime.jsx)("h2", {
							className: "text-3xl font-bold tracking-tight md:text-4xl lg:text-5xl",
							children: gradient ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(GradientText, {
								gradient,
								children: title
							}) : title
						}),
						description && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
							className: "mt-4 text-lg text-muted-foreground",
							children: description
						}),
						actions && actions.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
							className: "mt-8 flex flex-wrap justify-center gap-4",
							children: renderActions()
						})
					]
				})]
			})
		})
	}) : variant === "split" ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("section", {
		className: cn("py-16 md:py-24", className),
		...props,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Container, {
			size: containerSize,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "flex flex-col items-center justify-between gap-8 lg:flex-row",
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
					className: "max-w-xl",
					children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("h2", {
						className: "text-3xl font-bold tracking-tight md:text-4xl",
						children: gradient ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(GradientText, {
							gradient,
							children: title
						}) : title
					}), description && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
						className: "mt-4 text-lg text-muted-foreground",
						children: description
					})]
				}), actions && actions.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: "flex flex-wrap gap-4",
					children: renderActions()
				})]
			})
		})
	}) : /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("section", {
		className: cn("relative py-16 md:py-24", className),
		...props,
		children: [backgroundElement && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: "absolute inset-0 -z-10",
			children: backgroundElement
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Container, {
			size: containerSize,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "text-center max-w-3xl mx-auto",
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)("h2", {
						className: "text-3xl font-bold tracking-tight md:text-4xl lg:text-5xl",
						children: gradient ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(GradientText, {
							gradient,
							children: title
						}) : title
					}),
					description && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
						className: "mt-4 text-lg text-muted-foreground",
						children: description
					}),
					actions && actions.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						className: "mt-8 flex flex-wrap justify-center gap-4",
						children: renderActions()
					}),
					media && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						className: "mt-12",
						children: media
					})
				]
			})
		})]
	});
}
var variantStyles$4 = {
	default: "bg-primary text-primary-foreground",
	gradient: "bg-gradient-to-r from-primary via-purple-500 to-pink-500 text-white",
	dark: "bg-gray-900 text-white",
	accent: "bg-accent text-accent-foreground border-b border-border"
};
function CTABanner({ children, variant = "default", action, dismissible = !1, onDismiss, icon, className, ...props }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		className: cn("py-2.5 px-4", variantStyles$4[variant], className),
		...props,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
			className: "flex items-center justify-center gap-4 max-w-7xl mx-auto",
			children: [
				icon && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
					className: "shrink-0",
					children: icon
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
					className: "text-sm font-medium text-center",
					children
				}),
				action && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
					className: "shrink-0",
					children: action
				}),
				dismissible && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("button", {
					onClick: onDismiss,
					className: "shrink-0 p-1 rounded hover:bg-white/20 transition-colors ml-2",
					"aria-label": "Dismiss",
					children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(X, { className: "w-4 h-4" })
				})
			]
		})
	});
}
var variantStyles$3 = {
	default: "bg-background/95 backdrop-blur-md",
	transparent: "bg-transparent",
	bordered: "bg-background/95 backdrop-blur-md border-b border-border"
}, breakpointStyles = {
	sm: {
		desktop: "sm:flex",
		mobile: "sm:hidden"
	},
	md: {
		desktop: "md:flex",
		mobile: "md:hidden"
	},
	lg: {
		desktop: "lg:flex",
		mobile: "lg:hidden"
	}
};
function Navbar({ logo, links = [], actions, variant = "bordered", sticky = !0, mobileBreakpoint = "lg", className, ...props }) {
	let [mobileMenuOpen, setMobileMenuOpen] = useState(!1), [openDropdown, setOpenDropdown] = useState(null), bp = breakpointStyles[mobileBreakpoint], renderLink = (link$2, index$2) => {
		if (link$2.children && link$2.children.length > 0) {
			let isOpen = openDropdown === link$2.label;
			return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "relative",
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("button", {
					onClick: () => setOpenDropdown(isOpen ? null : link$2.label),
					className: cn("flex items-center gap-1 text-sm font-medium text-muted-foreground", "hover:text-foreground transition-colors py-2"),
					children: [link$2.label, /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ChevronDown, { className: cn("h-4 w-4 transition-transform", isOpen && "rotate-180") })]
				}), isOpen && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: "absolute top-full left-0 mt-2 w-48 rounded-xl bg-card border border-border shadow-lg py-2 z-50",
					children: link$2.children.map((child, childIndex) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("a", {
						href: child.href,
						onClick: child.onClick,
						className: "block px-4 py-2 text-sm text-muted-foreground hover:text-foreground hover:bg-accent transition-colors",
						children: child.label
					}, childIndex))
				})]
			}, index$2);
		}
		return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("a", {
			href: link$2.href,
			onClick: link$2.onClick,
			className: "text-sm font-medium text-muted-foreground hover:text-foreground transition-colors py-2",
			children: link$2.label
		}, index$2);
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("header", {
		className: cn("z-50 w-full", sticky && "sticky top-0", variantStyles$3[variant], className),
		...props,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Container, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("nav", {
			className: "flex h-16 items-center justify-between",
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "flex items-center gap-8",
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: "flex-shrink-0",
					children: logo
				}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: cn("hidden items-center gap-6", bp.desktop),
					children: links.map((link$2, index$2) => renderLink(link$2, index$2))
				})]
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "flex items-center gap-4",
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: cn("hidden", bp.desktop),
					children: actions
				}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("button", {
					className: cn("p-2 rounded-lg hover:bg-accent", bp.mobile),
					onClick: () => setMobileMenuOpen(!mobileMenuOpen),
					"aria-label": "Toggle menu",
					children: mobileMenuOpen ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(X, { className: "h-5 w-5" }) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Menu, { className: "h-5 w-5" })
				})]
			})]
		}) }), mobileMenuOpen && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: cn("border-t border-border bg-background", bp.mobile),
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Container, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "py-4 space-y-4",
				children: [links.map((link$2, index$2) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { children: link$2.children ? /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
					className: "space-y-2",
					children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
						className: "text-sm font-medium text-foreground",
						children: link$2.label
					}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						className: "pl-4 space-y-2",
						children: link$2.children.map((child, childIndex) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("a", {
							href: child.href,
							onClick: () => {
								child.onClick?.(), setMobileMenuOpen(!1);
							},
							className: "block text-sm text-muted-foreground hover:text-foreground",
							children: child.label
						}, childIndex))
					})]
				}) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)("a", {
					href: link$2.href,
					onClick: () => {
						link$2.onClick?.(), setMobileMenuOpen(!1);
					},
					className: "block text-sm font-medium text-muted-foreground hover:text-foreground",
					children: link$2.label
				}) }, index$2)), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: "pt-4 border-t border-border",
					children: actions
				})]
			}) })
		})]
	});
}
var variantStyles$2 = {
	primary: "bg-primary text-primary-foreground hover:bg-primary/90 shadow-sm",
	secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
	outline: "border border-border bg-transparent hover:bg-accent",
	ghost: "hover:bg-accent hover:text-accent-foreground"
}, sizeStyles = {
	sm: "h-8 px-3 text-xs",
	md: "h-9 px-4 text-sm",
	lg: "h-10 px-5 text-sm"
};
function NavButton({ variant = "primary", size = "md", href, icon, showArrow = !1, children, className, ...props }) {
	let content$2 = /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
		icon && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
			className: "mr-2",
			children: icon
		}),
		children,
		showArrow && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ChevronRight, { className: "ml-1 h-4 w-4" })
	] }), baseStyles = cn("inline-flex items-center justify-center rounded-full font-medium transition-all", "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring", variantStyles$2[variant], sizeStyles[size], className);
	return href ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("a", {
		href,
		className: baseStyles,
		children: content$2
	}) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)("button", {
		className: baseStyles,
		...props,
		children: content$2
	});
}
var variantStyles$1 = {
	default: "bg-card",
	bordered: "bg-card border border-border",
	elevated: "bg-card shadow-lg",
	glass: "bg-white/5 backdrop-blur-xl border border-white/10"
};
function TestimonialCard({ quote, author, rating, variant = "bordered", showQuoteIcon = !1, logo, className, ...props }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: cn("rounded-xl p-6 md:p-8", variantStyles$1[variant], className),
		...props,
		children: [
			showQuoteIcon && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Quote, { className: "h-8 w-8 text-primary/20 mb-4" }),
			rating && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "flex gap-1 mb-4",
				children: Array.from({ length: 5 }).map((_, i$2) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Star, { className: cn("h-4 w-4", i$2 < rating ? "text-yellow-500 fill-yellow-500" : "text-muted") }, i$2))
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("blockquote", {
				className: "text-lg leading-relaxed text-foreground mb-6",
				children: [
					"\"",
					quote,
					"\""
				]
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "flex items-center justify-between",
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
					className: "flex items-center gap-4",
					children: [author.avatar && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						className: "h-12 w-12 rounded-full overflow-hidden bg-muted flex-shrink-0",
						children: typeof author.avatar == "string" ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("img", {
							src: author.avatar,
							alt: author.name,
							className: "h-full w-full object-cover"
						}) : author.avatar
					}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
						className: "font-semibold text-foreground",
						children: author.name
					}), (author.title || author.company) && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("p", {
						className: "text-sm text-muted-foreground",
						children: [
							author.title,
							author.title && author.company && " at ",
							author.company
						]
					})] })]
				}), logo && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: "flex-shrink-0 opacity-60",
					children: logo
				})]
			})
		]
	});
}
var columnStyles$2 = {
	1: "grid-cols-1",
	2: "grid-cols-1 md:grid-cols-2",
	3: "grid-cols-1 md:grid-cols-2 lg:grid-cols-3"
};
function TestimonialGrid({ title, subtitle, label, labelGradient, titleAlign = "center", titleSize = "lg", columns = 3, layout = "grid", containerSize = "xl", children, className, ...props }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("section", {
		className: cn("py-16 md:py-24", className),
		...props,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Container, {
			size: containerSize,
			children: [(title || subtitle || label) && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SectionTitle, {
				title,
				subtitle,
				label,
				labelGradient,
				align: titleAlign,
				size: titleSize,
				className: "mb-12 md:mb-16"
			}), layout === "masonry" ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "columns-1 md:columns-2 lg:columns-3 gap-6 space-y-6",
				children
			}) : layout === "carousel" ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "flex gap-6 overflow-x-auto pb-4 snap-x snap-mandatory scrollbar-thin",
				children
			}) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: cn("grid gap-6", columnStyles$2[columns]),
				children
			})]
		})
	});
}
function TestimonialHighlight({ quote, author, containerSize = "md", logo, className, ...props }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("section", {
		className: cn("py-16 md:py-24", className),
		...props,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Container, {
			size: containerSize,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "text-center",
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Quote, { className: "h-12 w-12 text-primary/20 mx-auto mb-8" }),
					/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("blockquote", {
						className: "text-2xl md:text-3xl lg:text-4xl font-medium leading-relaxed text-foreground mb-8",
						children: [
							"\"",
							quote,
							"\""
						]
					}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
						className: "flex flex-col items-center gap-4",
						children: [
							author.avatar && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
								className: "h-16 w-16 rounded-full overflow-hidden bg-muted",
								children: typeof author.avatar == "string" ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("img", {
									src: author.avatar,
									alt: author.name,
									className: "h-full w-full object-cover"
								}) : author.avatar
							}),
							/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
								className: "text-center",
								children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
									className: "font-semibold text-lg text-foreground",
									children: author.name
								}), (author.title || author.company) && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("p", {
									className: "text-muted-foreground",
									children: [
										author.title,
										author.title && author.company && " at ",
										author.company
									]
								})]
							}),
							logo && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
								className: "mt-4 opacity-60",
								children: logo
							})
						]
					})
				]
			})
		})
	});
}
var variantStyles = {
	default: "bg-card border border-border",
	featured: "bg-card border-2 border-primary shadow-lg shadow-primary/10 relative",
	bordered: "bg-transparent border border-border"
};
function PricingCard({ name: name$1, description, price, priceDescription, features, action, variant = "default", badge, popular = !1, className, ...props }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: cn("rounded-2xl p-6 md:p-8 flex flex-col", variantStyles[popular ? "featured" : variant], className),
		...props,
		children: [
			(badge || popular) && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "absolute -top-3 left-1/2 -translate-x-1/2",
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
					className: "bg-primary text-primary-foreground text-xs font-semibold px-3 py-1 rounded-full",
					children: badge || "Most Popular"
				})
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "mb-6",
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("h3", {
					className: "text-xl font-semibold text-foreground",
					children: name$1
				}), description && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
					className: "mt-2 text-sm text-muted-foreground",
					children: description
				})]
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "mb-6",
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: "flex items-baseline gap-1",
					children: typeof price == "string" ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
						className: "text-4xl font-bold text-foreground",
						children: price
					}) : price
				}), priceDescription && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
					className: "mt-1 text-sm text-muted-foreground",
					children: priceDescription
				})]
			}),
			action && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "mb-6",
				children: action
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("ul", {
				className: "space-y-3 flex-1",
				children: features.map((feature, index$2) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("li", {
					className: cn("flex items-start gap-3 text-sm", !feature.included && "opacity-50"),
					children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Check, { className: cn("h-5 w-5 flex-shrink-0", feature.included ? "text-primary" : "text-muted-foreground") }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
						className: feature.included ? "text-foreground" : "text-muted-foreground",
						children: feature.text
					})]
				}, index$2))
			})
		]
	});
}
var columnStyles$1 = {
	2: "grid-cols-1 md:grid-cols-2",
	3: "grid-cols-1 md:grid-cols-2 lg:grid-cols-3",
	4: "grid-cols-1 sm:grid-cols-2 lg:grid-cols-4"
};
function PricingGrid({ title, subtitle, label, labelGradient, titleAlign = "center", titleSize = "lg", columns = 3, containerSize = "xl", toggle, children, className, ...props }) {
	let [activeToggle, setActiveToggle] = useState(toggle?.defaultValue || toggle?.options[0]?.value);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("section", {
		className: cn("py-16 md:py-24", className),
		...props,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Container, {
			size: containerSize,
			children: [
				(title || subtitle || label) && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SectionTitle, {
					title,
					subtitle,
					label,
					labelGradient,
					align: titleAlign,
					size: titleSize,
					className: "mb-8"
				}),
				toggle && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: "flex justify-center mb-12",
					children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						className: "inline-flex items-center gap-2 p-1 bg-muted rounded-full",
						children: toggle.options.map((option) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("button", {
							onClick: () => {
								setActiveToggle(option.value), toggle.onChange?.(option.value);
							},
							className: cn("relative px-4 py-2 text-sm font-medium rounded-full transition-all", activeToggle === option.value ? "bg-background text-foreground shadow-sm" : "text-muted-foreground hover:text-foreground"),
							children: [option.label, option.discount && activeToggle === option.value && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
								className: "absolute -top-2 -right-2 bg-primary text-primary-foreground text-xs px-1.5 py-0.5 rounded-full",
								children: option.discount
							})]
						}, option.value))
					})
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: cn("grid gap-6 lg:gap-8 items-start", columnStyles$1[columns]),
					children
				})
			]
		})
	});
}
function Footer({ logo, description, sections: sections$1 = [], socialLinks = [], copyright, bottomLinks = [], containerSize = "xl", variant = "default", newsletter, className, ...props }) {
	return variant === "minimal" ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("footer", {
		className: cn("border-t border-border py-8", className),
		...props,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Container, {
			size: containerSize,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "flex flex-col items-center justify-between gap-4 md:flex-row",
				children: [
					logo && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { children: logo }),
					socialLinks.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						className: "flex items-center gap-4",
						children: socialLinks.map((link$2, index$2) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("a", {
							href: link$2.href,
							target: "_blank",
							rel: "noopener noreferrer",
							className: "text-muted-foreground hover:text-foreground transition-colors",
							"aria-label": link$2.label,
							children: link$2.icon
						}, index$2))
					}),
					copyright && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
						className: "text-sm text-muted-foreground",
						children: copyright
					})
				]
			})
		})
	}) : variant === "centered" ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("footer", {
		className: cn("border-t border-border py-12", className),
		...props,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Container, {
			size: containerSize,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "flex flex-col items-center text-center gap-8",
				children: [
					logo && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { children: logo }),
					description && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
						className: "max-w-md text-muted-foreground",
						children: description
					}),
					sections$1.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("nav", {
						className: "flex flex-wrap justify-center gap-x-8 gap-y-2",
						children: sections$1.flatMap((section) => section.links.map((link$2, index$2) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("a", {
							href: link$2.href,
							className: "text-sm text-muted-foreground hover:text-foreground transition-colors",
							children: link$2.label
						}, `${section.title}-${index$2}`)))
					}),
					socialLinks.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						className: "flex items-center gap-4",
						children: socialLinks.map((link$2, index$2) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("a", {
							href: link$2.href,
							target: "_blank",
							rel: "noopener noreferrer",
							className: "text-muted-foreground hover:text-foreground transition-colors",
							"aria-label": link$2.label,
							children: link$2.icon
						}, index$2))
					}),
					copyright && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
						className: "text-sm text-muted-foreground",
						children: copyright
					})
				]
			})
		})
	}) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)("footer", {
		className: cn("border-t border-border", className),
		...props,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Container, {
			size: containerSize,
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "py-12 lg:py-16",
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
					className: "grid gap-8 lg:grid-cols-6",
					children: [
						/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
							className: "lg:col-span-2",
							children: [
								logo && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
									className: "mb-4",
									children: logo
								}),
								description && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
									className: "text-sm text-muted-foreground max-w-xs mb-6",
									children: description
								}),
								socialLinks.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
									className: "flex items-center gap-4",
									children: socialLinks.map((link$2, index$2) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("a", {
										href: link$2.href,
										target: "_blank",
										rel: "noopener noreferrer",
										className: "text-muted-foreground hover:text-foreground transition-colors",
										"aria-label": link$2.label,
										children: link$2.icon
									}, index$2))
								})
							]
						}),
						sections$1.map((section, index$2) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("h3", {
							className: "font-semibold text-foreground mb-4",
							children: section.title
						}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("ul", {
							className: "space-y-3",
							children: section.links.map((link$2, linkIndex) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("li", { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("a", {
								href: link$2.href,
								className: "text-sm text-muted-foreground hover:text-foreground transition-colors",
								children: link$2.label
							}) }, linkIndex))
						})] }, index$2)),
						newsletter && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
							className: "lg:col-span-2",
							children: [
								newsletter.title && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("h3", {
									className: "font-semibold text-foreground mb-2",
									children: newsletter.title
								}),
								newsletter.description && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
									className: "text-sm text-muted-foreground mb-4",
									children: newsletter.description
								}),
								/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("form", {
									onSubmit: (e) => {
										e.preventDefault();
										let email = e.target.elements.namedItem("email").value;
										newsletter.onSubmit?.(email);
									},
									className: "flex gap-2",
									children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("input", {
										type: "email",
										name: "email",
										placeholder: newsletter.placeholder || "Enter your email",
										className: "flex-1 px-3 py-2 text-sm bg-background border border-border rounded-lg focus:outline-none focus:ring-2 focus:ring-primary",
										required: !0
									}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("button", {
										type: "submit",
										className: "px-4 py-2 text-sm font-medium bg-primary text-primary-foreground rounded-lg hover:bg-primary/90 transition-colors",
										children: newsletter.buttonText || "Subscribe"
									})]
								})
							]
						})
					]
				})
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "border-t border-border py-6",
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
					className: "flex flex-col items-center justify-between gap-4 md:flex-row",
					children: [copyright && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
						className: "text-sm text-muted-foreground",
						children: copyright
					}), bottomLinks.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("nav", {
						className: "flex flex-wrap items-center gap-6",
						children: bottomLinks.map((link$2, index$2) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("a", {
							href: link$2.href,
							className: "text-sm text-muted-foreground hover:text-foreground transition-colors",
							children: link$2.label
						}, index$2))
					})]
				})
			})]
		})
	});
}
var columnStyles = {
	2: "grid-cols-2",
	3: "grid-cols-2 lg:grid-cols-3",
	4: "grid-cols-2 lg:grid-cols-4",
	5: "grid-cols-2 sm:grid-cols-3 lg:grid-cols-5"
};
function StatsSection({ title, subtitle, label, labelGradient, titleAlign = "center", stats, columns = 4, variant = "default", containerSize = "xl", className, ...props }) {
	let renderStat = (stat, index$2) => {
		let baseContent = /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
			stat.icon && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "mb-2 text-primary",
				children: stat.icon
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "text-3xl md:text-4xl lg:text-5xl font-bold text-foreground mb-2",
				children: stat.value
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "text-sm font-medium text-muted-foreground",
				children: stat.label
			}),
			stat.description && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "text-xs text-muted-foreground/70 mt-1",
				children: stat.description
			})
		] });
		switch (variant) {
			case "bordered": return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: cn("text-center p-6 border-l border-border first:border-l-0", "lg:first:border-l-0"),
				children: baseContent
			}, index$2);
			case "cards": return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "text-center p-6 bg-card border border-border rounded-xl",
				children: baseContent
			}, index$2);
			case "minimal": return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "text-center",
				children: baseContent
			}, index$2);
			default: return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "text-center p-6",
				children: baseContent
			}, index$2);
		}
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("section", {
		className: cn("py-16 md:py-24", className),
		...props,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Container, {
			size: containerSize,
			children: [(title || subtitle || label) && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SectionTitle, {
				title,
				subtitle,
				label,
				labelGradient,
				align: titleAlign,
				className: "mb-12"
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: cn("grid gap-8", columnStyles[columns], variant === "bordered" && "divide-x-0 lg:divide-x divide-border"),
				children: stats.map((stat, index$2) => renderStat(stat, index$2))
			})]
		})
	});
}
var nodeCode = "// Get a user's access token and\n// profile data from an Identity Provider\n\nimport WorkOS from '@workos-inc/node';\n\nconst workos = new WorkOS('sk_example_123456789');\n\nconst profile = await workos.sso.getProfileAndToken({\n  code: '01E2RJ4C05B52KKZ8FSRDAP23J',\n  clientID: 'client_123456789',\n});", pythonCode = "# Get a user's access token and\n# profile data from an Identity Provider\n\nfrom workos import WorkOS\n\nworkos = WorkOS(api_key='sk_example_123456789')\n\nprofile = workos.sso.get_profile_and_token(\n    code='01E2RJ4C05B52KKZ8FSRDAP23J',\n    client_id='client_123456789'\n)", goCode = "// Get a user's access token and\n// profile data from an Identity Provider\n\npackage main\n\nimport (\n    \"github.com/workos/workos-go/v4/pkg/sso\"\n)\n\nfunc main() {\n    sso.SetAPIKey(\"sk_example_123456789\")\n\n    profile, _ := sso.GetProfileAndToken(\n        ctx,\n        sso.GetProfileAndTokenOpts{\n            Code: \"01E2RJ4C05B52KKZ8FSRDAP23J\",\n        },\n    )\n}", apiResponse = {
	access_token: "01DMEK0J53CVMC32CK5SE0KZ8Q",
	profile: {
		id: "prof_01DMC79VCBZ0NY2099737PSVF1",
		connection_id: "conn_01E4ZCR3C56J083X43JQX3JK5",
		connection_type: "okta",
		email: "alan@foo-corp.com",
		first_name: "Alan",
		last_name: "Turing",
		idp_id: "00u1a0ufowBJlzPlk357",
		object: "profile"
	}
};
function LogoPlaceholder({ name: name$1 }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		className: "text-lg font-bold text-muted-foreground/60 tracking-tight",
		children: name$1
	});
}
function LandingPage() {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: "min-h-screen bg-background",
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(CTABanner, {
				variant: "accent",
				action: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("a", {
					href: "#",
					className: "hover:text-foreground flex items-center gap-1 text-sm font-medium",
					children: ["Learn more ", /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ChevronRight, { className: "w-4 h-4" })]
				}),
				children: "Announcing our $50M Series B funding"
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Navbar, {
				logo: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("a", {
					href: "/",
					className: "flex items-center gap-2 font-bold text-xl",
					children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						className: "w-8 h-8 bg-primary rounded-lg flex items-center justify-center",
						children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Sparkles, { className: "w-5 h-5 text-primary-foreground" })
					}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { children: "Acme" })]
				}),
				links: [
					{
						label: "Products",
						children: [
							{
								label: "Authentication",
								href: "#"
							},
							{
								label: "User Management",
								href: "#"
							},
							{
								label: "Directory Sync",
								href: "#"
							},
							{
								label: "Audit Logs",
								href: "#"
							}
						]
					},
					{
						label: "Developers",
						children: [
							{
								label: "Documentation",
								href: "#"
							},
							{
								label: "API Reference",
								href: "#"
							},
							{
								label: "SDKs",
								href: "#"
							},
							{
								label: "Changelog",
								href: "#"
							}
						]
					},
					{
						label: "Pricing",
						href: "#pricing"
					},
					{
						label: "Blog",
						href: "#"
					}
				],
				actions: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
					className: "flex items-center gap-3",
					children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(NavButton, {
						variant: "ghost",
						href: "#",
						children: "Sign in"
					}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(NavButton, {
						variant: "primary",
						href: "#",
						showArrow: !0,
						children: "Dashboard"
					})]
				})
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Hero, {
				size: "xl",
				layout: "centered",
				contentAlign: "left",
				className: "pt-20 md:pt-28",
				badge: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(HeroBadge, {
					variant: "outline",
					showArrow: !0,
					href: "#",
					children: "New: Multi-tenant authentication is here"
				}),
				title: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
					"Your app,",
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)("br", {}),
					"Enterprise Ready."
				] }),
				subtitle: "Start selling to enterprise customers with just a few lines of code. Implement features like single sign-on in minutes instead of months.",
				actions: [{
					label: "Get started",
					href: "#",
					variant: "primary"
				}, {
					label: "Talk to an expert",
					href: "#",
					variant: "ghost",
					icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ChevronRight, { className: "w-4 h-4" }),
					iconPosition: "right"
				}],
				backgroundElement: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(HeroBackground, {
					variant: "radial",
					primaryColor: "rgba(0, 0, 0, 0.05)",
					secondaryColor: "rgba(0, 0, 0, 0.05)"
				})
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(LogoCloud, {
				title: "Trusted by",
				variant: "muted",
				logos: [
					{
						name: "OpenAI",
						logo: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(LogoPlaceholder, { name: "OpenAI" })
					},
					{
						name: "Anthropic",
						logo: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(LogoPlaceholder, { name: "Anthropic" })
					},
					{
						name: "Cursor",
						logo: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(LogoPlaceholder, { name: "Cursor" })
					},
					{
						name: "Perplexity",
						logo: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(LogoPlaceholder, { name: "Perplexity" })
					},
					{
						name: "Vercel",
						logo: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(LogoPlaceholder, { name: "Vercel" })
					},
					{
						name: "Stripe",
						logo: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(LogoPlaceholder, { name: "Stripe" })
					}
				]
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Section, {
				theme: "muted",
				spacing: "xl",
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Container, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(SectionTitle, {
					label: "Developer-first design",
					title: "A unified platform with modern APIs",
					align: "center",
					className: "mb-16"
				}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
					className: "grid gap-12 lg:grid-cols-2 items-start",
					children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { children: [
						/* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
							className: "text-lg text-muted-foreground mb-8",
							children: "WorkOS provides a single, elegant interface that abstracts dozens of enterprise integrations."
						}),
						/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
							className: "flex flex-wrap gap-4 mb-12",
							children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(NavButton, {
								variant: "primary",
								href: "#",
								children: "Read the docs"
							}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(NavButton, {
								variant: "ghost",
								href: "#",
								icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Key, { className: "w-4 h-4" }),
								children: "Get your API key"
							})]
						}),
						/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
							className: "grid gap-6 sm:grid-cols-2",
							children: [
								{
									icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Terminal, { className: "w-5 h-5" }),
									title: "RESTful APIs",
									description: "JSON responses and normalized objects"
								},
								{
									icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Layers, { className: "w-5 h-5" }),
									title: "Dashboard",
									description: "Seamlessly integrates into your application"
								},
								{
									icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Zap, { className: "w-5 h-5" }),
									title: "Realtime updates",
									description: "Directory services with webhook events"
								},
								{
									icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CodeXml, { className: "w-5 h-5" }),
									title: "Modern SDKs",
									description: "Node.js, Ruby, Python, .NET, Go and more"
								},
								{
									icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Globe, { className: "w-5 h-5" }),
									title: "Multiple environments",
									description: "Map to your application development process"
								},
								{
									icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Building2, { className: "w-5 h-5" }),
									title: "20+ enterprise services",
									description: "With a single integration point"
								}
							].map((feature, index$2) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
								className: "flex gap-4",
								children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(IconBox, {
									icon: feature.icon,
									variant: "outlined",
									color: "primary",
									size: "md"
								}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("h4", {
									className: "font-medium text-foreground",
									children: feature.title
								}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
									className: "text-sm text-muted-foreground",
									children: feature.description
								})] })]
							}, index$2))
						})
					] }), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
						className: "space-y-4",
						children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(CodeTabs, { tabs: [
							{
								label: "Node.js",
								code: nodeCode,
								language: "typescript"
							},
							{
								label: "Python",
								code: pythonCode,
								language: "python"
							},
							{
								label: "Go",
								code: goCode,
								language: "go"
							}
						] }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(APIResponse, {
							status: 200,
							response: apiResponse
						})]
					})]
				})] })
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FeatureShowcase, {
				label: "The all-in-one solution",
				title: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
					"Enterprise SSO",
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)("br", {}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
						className: "text-muted-foreground",
						children: "(and a whole lot more)"
					})
				] }),
				description: "WorkOS is a set of building blocks for quickly adding enterprise features to your app. You'll be shipping quickly with a market-proven solution for your customers.",
				layout: "left",
				action: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(NavButton, {
					variant: "primary",
					href: "#",
					children: "Add Single Sign-On to your app"
				}),
				features: [
					{
						icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Lock, { className: "w-5 h-5" }),
						title: "Auth for all SSO providers",
						description: "Support any SAML or OIDC identity provider with a single integration"
					},
					{
						icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Users, { className: "w-5 h-5" }),
						title: "Complete User Management",
						description: "Manage users and organizations, set policies, and support all auth types"
					},
					{
						icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Globe, { className: "w-5 h-5" }),
						title: "Social authentication",
						description: "Sign in to your app with Microsoft, Google, and more"
					},
					{
						icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(UserCheck, { className: "w-5 h-5" }),
						title: "AuthKit",
						description: "Flexible authentication UI powered by WorkOS and Radix"
					}
				],
				media: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
					className: "relative",
					children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { className: "absolute inset-0 bg-primary/5 rounded-3xl blur-3xl" }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						className: "relative bg-card border border-border rounded-2xl p-8 shadow-2xl transform rotate-3 hover:rotate-0 transition-transform duration-500",
						children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
							className: "text-center",
							children: [
								/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
									className: "w-16 h-16 mx-auto mb-4 bg-primary/10 rounded-2xl flex items-center justify-center",
									children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Shield, { className: "w-8 h-8 text-primary" })
								}),
								/* @__PURE__ */ (0, import_jsx_runtime.jsx)("h3", {
									className: "font-semibold text-lg mb-2",
									children: "Sign in to Super App"
								}),
								/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
									className: "space-y-3 text-left",
									children: [
										/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("label", {
											className: "text-xs text-muted-foreground",
											children: "Email"
										}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
											className: "mt-1 px-3 py-2 bg-muted rounded-lg text-sm text-muted-foreground",
											children: "Your email address"
										})] }),
										/* @__PURE__ */ (0, import_jsx_runtime.jsx)("button", {
											className: "w-full py-2 bg-primary text-primary-foreground rounded-lg font-medium",
											children: "Continue"
										}),
										/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("p", {
											className: "text-xs text-center text-muted-foreground",
											children: ["Don't have an account? ", /* @__PURE__ */ (0, import_jsx_runtime.jsx)("a", {
												href: "#",
												className: "text-primary hover:underline",
												children: "Get started"
											})]
										})
									]
								})
							]
						})
					})]
				})
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FeatureGrid, {
				label: "Additional Products",
				title: "Everything you need to scale",
				subtitle: "From authentication to audit logs, we've got you covered with enterprise-grade features.",
				columns: 3,
				className: "bg-muted/30",
				children: [
					{
						icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Key, { className: "w-5 h-5" }),
						title: "Single Sign-On",
						description: "Integrate your existing auth stack with any SAML or OIDC identity provider."
					},
					{
						icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Users, { className: "w-5 h-5" }),
						title: "Directory Sync",
						description: "Add user lifecycle management for SCIM and HRIS providers to your existing stack."
					},
					{
						icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Building2, { className: "w-5 h-5" }),
						title: "Admin Portal",
						description: "Enable IT admins to have a self-serve onboarding experience."
					},
					{
						icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Shield, { className: "w-5 h-5" }),
						title: "Audit Logs",
						description: "Stream and store security events for compliance and debugging."
					},
					{
						icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Lock, { className: "w-5 h-5" }),
						title: "Fine-grained Authorization",
						description: "Implement role-based access control with our permissions API."
					},
					{
						icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Zap, { className: "w-5 h-5" }),
						title: "Webhooks",
						description: "Real-time event notifications for all account activity."
					}
				].map((feature, index$2) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FeatureCard, {
					icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(IconBox, {
						icon: feature.icon,
						variant: "gradient",
						color: "primary"
					}),
					title: feature.title,
					description: feature.description,
					variant: "bordered"
				}, index$2))
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(StatsSection, {
				title: "Trusted by thousands of companies worldwide",
				stats: [
					{
						value: "10M+",
						label: "API Requests",
						description: "per day"
					},
					{
						value: "99.99%",
						label: "Uptime SLA",
						description: "guaranteed"
					},
					{
						value: "500+",
						label: "Enterprise Customers",
						description: "and growing"
					},
					{
						value: "<50ms",
						label: "Response Time",
						description: "p95 latency"
					}
				],
				variant: "bordered",
				columns: 4
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(TestimonialGrid, {
				label: "What our customers say",
				title: "Loved by developers worldwide",
				subtitle: "See what engineering teams are saying about building with our platform.",
				columns: 3,
				className: "bg-muted/30",
				children: [
					{
						quote: "We went from zero to enterprise-ready SSO in just two days. The documentation is fantastic and the support team is incredibly responsive.",
						author: {
							name: "Sarah Chen",
							title: "CTO",
							company: "TechStartup",
							avatar: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
								className: "w-full h-full bg-primary/10 flex items-center justify-center text-primary font-semibold",
								children: "SC"
							})
						},
						rating: 5
					},
					{
						quote: "The API is beautifully designed. It feels like the engineers actually thought about the developer experience from day one.",
						author: {
							name: "Marcus Johnson",
							title: "Lead Engineer",
							company: "ScaleUp Inc",
							avatar: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
								className: "w-full h-full bg-secondary flex items-center justify-center text-secondary-foreground font-semibold",
								children: "MJ"
							})
						},
						rating: 5
					},
					{
						quote: "Finally, an auth solution that doesn't make me want to pull my hair out. Clean, simple, and it just works.",
						author: {
							name: "Emily Rodriguez",
							title: "Founder",
							company: "DevTools Co",
							avatar: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
								className: "w-full h-full bg-primary text-primary-foreground flex items-center justify-center font-semibold",
								children: "ER"
							})
						},
						rating: 5
					}
				].map((testimonial, index$2) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TestimonialCard, {
					quote: testimonial.quote,
					author: testimonial.author,
					rating: testimonial.rating,
					variant: "bordered"
				}, index$2))
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(PricingGrid, {
				id: "pricing",
				label: "Pricing",
				title: "Simple, transparent pricing",
				subtitle: "Start for free, then scale as you grow. No hidden fees.",
				columns: 3,
				toggle: {
					options: [{
						label: "Monthly",
						value: "monthly"
					}, {
						label: "Annual",
						value: "annual",
						discount: "-20%"
					}],
					defaultValue: "annual"
				},
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)(PricingCard, {
						name: "Starter",
						description: "Perfect for side projects and small teams",
						price: "$0",
						priceDescription: "Free forever",
						features: [
							{
								text: "Up to 1,000 monthly active users",
								included: !0
							},
							{
								text: "Basic SSO (Google, GitHub)",
								included: !0
							},
							{
								text: "Community support",
								included: !0
							},
							{
								text: "Custom domains",
								included: !1
							},
							{
								text: "Audit logs",
								included: !1
							},
							{
								text: "SLA",
								included: !1
							}
						],
						action: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(NavButton, {
							variant: "outline",
							href: "#",
							className: "w-full",
							children: "Get started free"
						})
					}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)(PricingCard, {
						name: "Pro",
						description: "For growing teams that need more",
						price: "$49",
						priceDescription: "per month, billed annually",
						popular: !0,
						features: [
							{
								text: "Up to 10,000 monthly active users",
								included: !0
							},
							{
								text: "Enterprise SSO (SAML, OIDC)",
								included: !0
							},
							{
								text: "Priority support",
								included: !0
							},
							{
								text: "Custom domains",
								included: !0
							},
							{
								text: "Audit logs",
								included: !0
							},
							{
								text: "SLA",
								included: !1
							}
						],
						action: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(NavButton, {
							variant: "primary",
							href: "#",
							className: "w-full",
							children: "Start free trial"
						})
					}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)(PricingCard, {
						name: "Enterprise",
						description: "For organizations with advanced needs",
						price: "Custom",
						priceDescription: "Contact us for pricing",
						features: [
							{
								text: "Unlimited monthly active users",
								included: !0
							},
							{
								text: "All SSO providers",
								included: !0
							},
							{
								text: "Dedicated support",
								included: !0
							},
							{
								text: "Custom domains",
								included: !0
							},
							{
								text: "Audit logs",
								included: !0
							},
							{
								text: "99.99% SLA",
								included: !0
							}
						],
						action: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(NavButton, {
							variant: "outline",
							href: "#",
							className: "w-full",
							children: "Contact sales"
						})
					})
				]
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(CTASection, {
				variant: "card",
				title: "Ready to get started?",
				description: "Join thousands of companies building enterprise-ready applications with our platform.",
				actions: [{
					label: "Start building for free",
					href: "#",
					variant: "primary"
				}, {
					label: "Talk to sales",
					href: "#",
					variant: "outline"
				}]
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Footer, {
				logo: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("a", {
					href: "/",
					className: "flex items-center gap-2 font-bold text-xl",
					children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						className: "w-8 h-8 bg-primary rounded-lg flex items-center justify-center",
						children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Sparkles, { className: "w-5 h-5 text-primary-foreground" })
					}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { children: "Acme" })]
				}),
				description: "Enterprise-ready authentication and user management for modern applications.",
				sections: [
					{
						title: "Product",
						links: [
							{
								label: "Features",
								href: "#"
							},
							{
								label: "Pricing",
								href: "#pricing"
							},
							{
								label: "Security",
								href: "#"
							},
							{
								label: "Enterprise",
								href: "#"
							}
						]
					},
					{
						title: "Developers",
						links: [
							{
								label: "Documentation",
								href: "#"
							},
							{
								label: "API Reference",
								href: "#"
							},
							{
								label: "SDKs",
								href: "#"
							},
							{
								label: "Status",
								href: "#"
							}
						]
					},
					{
						title: "Company",
						links: [
							{
								label: "About",
								href: "#"
							},
							{
								label: "Blog",
								href: "#"
							},
							{
								label: "Careers",
								href: "#"
							},
							{
								label: "Contact",
								href: "#"
							}
						]
					}
				],
				socialLinks: [
					{
						label: "GitHub",
						href: "#",
						icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Github, { className: "w-5 h-5" })
					},
					{
						label: "Twitter",
						href: "#",
						icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Twitter, { className: "w-5 h-5" })
					},
					{
						label: "LinkedIn",
						href: "#",
						icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Linkedin, { className: "w-5 h-5" })
					}
				],
				copyright: `Â© ${(/* @__PURE__ */ new Date()).getFullYear()} Acme Inc. All rights reserved.`,
				bottomLinks: [
					{
						label: "Privacy Policy",
						href: "#"
					},
					{
						label: "Terms of Service",
						href: "#"
					},
					{
						label: "Cookie Settings",
						href: "#"
					}
				]
			})
		]
	});
}
function SearchDialog({ results: externalResults, onSearch }) {
	let { searchOpen, setSearchOpen, config } = useDocs(), [query, setQuery] = useState(""), [results, setResults] = useState([]), [selectedIndex, setSelectedIndex] = useState(0), inputRef = useRef(null), navigate = useNavigate();
	return useEffect(() => {
		searchOpen && (inputRef.current?.focus(), setQuery(""), setResults([]), setSelectedIndex(0));
	}, [searchOpen]), useEffect(() => {
		let flattenResults = (items, searchQuery) => {
			if (!items) return [];
			let normalizedQuery = searchQuery.toLowerCase().trim();
			if (!normalizedQuery) return items.map((item) => ({
				...item,
				type: "doc"
			}));
			let filtered = [];
			return items.forEach((item) => {
				let docMatches = item.title.toLowerCase().includes(normalizedQuery) || item.excerpt?.toLowerCase().includes(normalizedQuery), headingMatches = (item.headings || []).filter((heading$2) => heading$2.title.toLowerCase().includes(normalizedQuery));
				(docMatches || headingMatches.length > 0) && (filtered.push({
					...item,
					type: "doc"
				}), headingMatches.forEach((match) => filtered.push(match)));
			}), filtered;
		};
		query && onSearch ? (setResults(flattenResults(onSearch(query), query)), setSelectedIndex(0)) : externalResults ? (setResults(flattenResults(externalResults, query)), setSelectedIndex(0)) : setResults([]);
	}, [
		query,
		onSearch,
		externalResults
	]), searchOpen ? (console.log("SearchDialog - rendering, results length:", results.length), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: "fixed inset-0 z-50",
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: "fixed inset-0 bg-background/80 backdrop-blur-sm",
			onClick: () => setSearchOpen(!1)
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: "fixed left-1/2 top-[20%] w-full max-w-lg -translate-x-1/2 px-4",
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "overflow-hidden rounded-xl border border-border bg-popover shadow-2xl",
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
						className: "flex items-center border-b border-border px-4",
						children: [
							/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Icon, {
								icon: Search,
								className: "text-muted-foreground"
							}),
							/* @__PURE__ */ (0, import_jsx_runtime.jsx)("input", {
								ref: inputRef,
								type: "text",
								value: query,
								onChange: (e) => setQuery(e.target.value),
								onKeyDown: (e) => {
									switch (e.key) {
										case "ArrowDown":
											e.preventDefault(), setSelectedIndex((i$2) => Math.min(i$2 + 1, results.length - 1));
											break;
										case "ArrowUp":
											e.preventDefault(), setSelectedIndex((i$2) => Math.max(i$2 - 1, 0));
											break;
										case "Enter":
											e.preventDefault(), results[selectedIndex] && (navigate(results[selectedIndex].href), setSearchOpen(!1));
											break;
									}
								},
								placeholder: config.search?.placeholder || "Search documentation...",
								className: "flex-1 bg-transparent px-4 py-4 text-sm outline-none placeholder:text-muted-foreground"
							}),
							/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Button, {
								variant: "ghost",
								size: "icon",
								onClick: () => setSearchOpen(!1),
								className: "h-8 w-8",
								children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Icon, {
									icon: X,
									size: "sm"
								})
							})
						]
					}),
					results.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						className: "max-h-80 overflow-y-auto p-2",
						children: results.map((result, i$2) => {
							let isHeading = result.type === "heading";
							return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("button", {
								onClick: () => {
									navigate(result.href), setSearchOpen(!1);
								},
								className: cn("flex w-full items-start gap-3 rounded-lg px-3 py-2 text-left transition-colors", isHeading && "ml-6 border-l border-border/60 pl-4", selectedIndex === i$2 ? "bg-accent text-accent-foreground" : "hover:bg-accent/50"),
								children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Icon, {
									icon: isHeading ? Hash : FileText,
									className: "mt-0.5 text-muted-foreground"
								}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
									className: "flex-1 min-w-0",
									children: [
										/* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
											className: cn("text-sm truncate", isHeading ? "font-medium" : "font-semibold"),
											children: result.title
										}),
										!isHeading && result.section && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
											className: "text-xs text-muted-foreground",
											children: result.section
										}),
										isHeading && "parentTitle" in result && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
											className: "text-xs text-muted-foreground",
											children: result.parentTitle
										}),
										!isHeading && result.excerpt && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
											className: "text-xs text-muted-foreground truncate mt-0.5",
											children: result.excerpt
										})
									]
								})]
							}, i$2);
						})
					}),
					query && results.length === 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
						className: "p-8 text-center text-sm text-muted-foreground",
						children: [
							"No results found for \"",
							query,
							"\""
						]
					}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
						className: "flex items-center justify-between border-t border-border px-4 py-2 text-xs text-muted-foreground",
						children: [
							/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
								className: "flex items-center gap-2",
								children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("kbd", {
									className: "rounded border border-border bg-muted px-1.5 py-0.5",
									children: "â†‘â†“"
								}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { children: "Navigate" })]
							}),
							/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
								className: "flex items-center gap-2",
								children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("kbd", {
									className: "rounded border border-border bg-muted px-1.5 py-0.5",
									children: "â†µ"
								}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { children: "Select" })]
							}),
							/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
								className: "flex items-center gap-2",
								children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("kbd", {
									className: "rounded border border-border bg-muted px-1.5 py-0.5",
									children: "Esc"
								}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { children: "Close" })]
							})
						]
					})
				]
			})
		})]
	})) : null;
}
function DynamicDocPage({ docs: docs$1 }) {
	let { "*": path$1 } = useParams(), slug$1 = path$1 ? `/${path$1}` : "/", doc = docs$1.find((d) => d.slug === slug$1);
	if (!doc) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DocPage, {
		content: "# Not Found\\n\\nThis page does not exist.",
		title: "Not Found"
	});
	let currentIndex = docs$1.findIndex((d) => d.slug === slug$1), prevDoc = currentIndex > 0 ? docs$1[currentIndex - 1] : null, nextDoc = currentIndex < docs$1.length - 1 ? docs$1[currentIndex + 1] : null;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DocPage, {
		content: doc.content,
		title: doc.meta.title || doc.path,
		description: doc.meta.description,
		prevPage: prevDoc ? {
			title: prevDoc.meta.title || prevDoc.path,
			href: prevDoc.slug
		} : void 0,
		nextPage: nextDoc ? {
			title: nextDoc.meta.title || nextDoc.path,
			href: nextDoc.slug
		} : void 0,
		docs: docs$1
	});
}
function HomeRoute({ docs: docs$1, config, homePage }) {
	return docs$1.find((d) => d.slug === "/") ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(HomePage, {
		title: config.name,
		description: config.description,
		primaryAction: docs$1[1] ? {
			label: "Get Started",
			href: docs$1[1].slug
		} : void 0,
		secondaryAction: docs$1[2] ? {
			label: "View Docs",
			href: docs$1[2].slug
		} : void 0,
		features: homePage?.features || []
	}) : null;
}
function Docs({ config, docs: docs$1, homePage, basePath = "" }) {
	let navigation = useMemo(() => {
		if (config.navigation && config.navigation.length > 0) return config.navigation;
		let nav = [];
		return docs$1.forEach((doc) => {
			let parts = doc.path.split("/");
			if (parts.length === 1) return;
			let section = parts[0], existingSection = nav.find((n) => n.title === section);
			existingSection ? existingSection.children && existingSection.children.push({
				title: doc.meta.title || doc.path,
				href: `${basePath}${doc.slug}`
			}) : nav.push({
				title: section,
				children: [{
					title: doc.meta.title || doc.path,
					href: `${basePath}${doc.slug}`
				}]
			});
		}), nav;
	}, [docs$1, basePath]), searchResults = useMemo(() => docs$1.map((doc) => {
		let section = doc.path.split("/")[0], parentTitle = doc.meta.title || doc.path, headings = extractTocFromMarkdown(doc.content).map((heading$2) => ({
			title: heading$2.text,
			href: `${basePath}${doc.slug}#${heading$2.id}`,
			section,
			parentTitle,
			headingLevel: heading$2.level,
			type: "heading"
		}));
		return {
			title: parentTitle,
			href: `${basePath}${doc.slug}`,
			excerpt: doc.content.substring(0, 160).replace(/^#+\s+/gm, "").substring(0, 160),
			section,
			headings
		};
	}), [docs$1, basePath]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(DocsProvider, {
		config: {
			...config,
			navigation
		},
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(SearchDialog, { results: searchResults }), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Routes, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Route, {
			path: "/",
			element: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(HomeRoute, {
				docs: docs$1,
				config,
				homePage
			})
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Route, {
			path: "/*",
			element: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DynamicDocPage, { docs: docs$1 })
		})] })]
	});
}
var calloutConfig = {
	info: {
		icon: Info,
		className: "border-blue-500/30 bg-blue-500/5 text-blue-600 dark:text-blue-400",
		title: "Info"
	},
	warning: {
		icon: TriangleAlert,
		className: "border-yellow-500/30 bg-yellow-500/5 text-yellow-600 dark:text-yellow-400",
		title: "Warning"
	},
	danger: {
		icon: CircleAlert,
		className: "border-red-500/30 bg-red-500/5 text-red-600 dark:text-red-400",
		title: "Danger"
	},
	success: {
		icon: CircleCheckBig,
		className: "border-green-500/30 bg-green-500/5 text-green-600 dark:text-green-400",
		title: "Success"
	},
	tip: {
		icon: Lightbulb,
		className: "border-purple-500/30 bg-purple-500/5 text-purple-600 dark:text-purple-400",
		title: "Tip"
	}
};
function Callout({ variant = "info", title, children, className }) {
	let config = calloutConfig[variant];
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		className: cn("my-6 rounded-lg border-l-4 p-4", config.className, className),
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
			className: "flex items-start gap-3",
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Icon, {
				icon: config.icon,
				size: "lg",
				className: "mt-0.5 shrink-0"
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "flex-1 min-w-0",
				children: [(title || config.title) && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
					className: "font-semibold mb-1",
					children: title || config.title
				}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: "text-sm text-foreground/80",
					children
				})]
			})]
		})
	});
}
function CodeBlock({ code: code$4, language: language$1 = "text", filename, showLineNumbers = !1, highlightLines = [], className }) {
	let [copied, setCopied] = useState(!1), handleCopy = async () => {
		await navigator.clipboard.writeText(code$4), setCopied(!0), setTimeout(() => setCopied(!1), 2e3);
	}, lines = code$4.split("\n");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: cn("group relative my-6 rounded-lg overflow-hidden", "border border-border", className),
		children: [filename && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
			className: "flex items-center gap-2 border-b border-border bg-muted/50 px-4 py-2 text-sm",
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Icon, {
				icon: Terminal,
				size: "sm",
				className: "text-muted-foreground"
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
				className: "font-mono text-muted-foreground",
				children: filename
			})]
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
			className: "relative",
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Button, {
				variant: "ghost",
				size: "icon",
				onClick: handleCopy,
				className: "absolute right-2 top-2 opacity-0 group-hover:opacity-100 transition-opacity",
				"aria-label": "Copy code",
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Icon, {
					icon: copied ? Check : Copy,
					size: "sm"
				})
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("pre", {
				className: cn("overflow-x-auto bg-code p-4 text-sm", showLineNumbers && "pl-0"),
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("code", {
					className: `language-${language$1}`,
					children: showLineNumbers ? lines.map((line, i$2) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
						className: cn("flex", highlightLines.includes(i$2 + 1) && "bg-primary/10 -mx-4 px-4"),
						children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
							className: "w-12 shrink-0 select-none text-right pr-4 text-muted-foreground",
							children: i$2 + 1
						}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
							className: "flex-1",
							children: line || " "
						})]
					}, i$2)) : code$4
				})
			})]
		})]
	});
}
var require___vite_browser_external = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {};
})), require_kind_of = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var toString = Object.prototype.toString;
	module.exports = function(val) {
		if (val === void 0) return "undefined";
		if (val === null) return "null";
		var type = typeof val;
		if (type === "boolean") return "boolean";
		if (type === "string") return "string";
		if (type === "number") return "number";
		if (type === "symbol") return "symbol";
		if (type === "function") return isGeneratorFn(val) ? "generatorfunction" : "function";
		if (isArray(val)) return "array";
		if (isBuffer$1(val)) return "buffer";
		if (isArguments(val)) return "arguments";
		if (isDate(val)) return "date";
		if (isError(val)) return "error";
		if (isRegexp(val)) return "regexp";
		switch (ctorName(val)) {
			case "Symbol": return "symbol";
			case "Promise": return "promise";
			case "WeakMap": return "weakmap";
			case "WeakSet": return "weakset";
			case "Map": return "map";
			case "Set": return "set";
			case "Int8Array": return "int8array";
			case "Uint8Array": return "uint8array";
			case "Uint8ClampedArray": return "uint8clampedarray";
			case "Int16Array": return "int16array";
			case "Uint16Array": return "uint16array";
			case "Int32Array": return "int32array";
			case "Uint32Array": return "uint32array";
			case "Float32Array": return "float32array";
			case "Float64Array": return "float64array";
		}
		if (isGeneratorObj(val)) return "generator";
		switch (type = toString.call(val), type) {
			case "[object Object]": return "object";
			case "[object Map Iterator]": return "mapiterator";
			case "[object Set Iterator]": return "setiterator";
			case "[object String Iterator]": return "stringiterator";
			case "[object Array Iterator]": return "arrayiterator";
		}
		return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
	};
	function ctorName(val) {
		return typeof val.constructor == "function" ? val.constructor.name : null;
	}
	function isArray(val) {
		return Array.isArray ? Array.isArray(val) : val instanceof Array;
	}
	function isError(val) {
		return val instanceof Error || typeof val.message == "string" && val.constructor && typeof val.constructor.stackTraceLimit == "number";
	}
	function isDate(val) {
		return val instanceof Date ? !0 : typeof val.toDateString == "function" && typeof val.getDate == "function" && typeof val.setDate == "function";
	}
	function isRegexp(val) {
		return val instanceof RegExp ? !0 : typeof val.flags == "string" && typeof val.ignoreCase == "boolean" && typeof val.multiline == "boolean" && typeof val.global == "boolean";
	}
	function isGeneratorFn(name$1, val) {
		return ctorName(name$1) === "GeneratorFunction";
	}
	function isGeneratorObj(val) {
		return typeof val.throw == "function" && typeof val.return == "function" && typeof val.next == "function";
	}
	function isArguments(val) {
		try {
			if (typeof val.length == "number" && typeof val.callee == "function") return !0;
		} catch (err) {
			if (err.message.indexOf("callee") !== -1) return !0;
		}
		return !1;
	}
	function isBuffer$1(val) {
		return val.constructor && typeof val.constructor.isBuffer == "function" ? val.constructor.isBuffer(val) : !1;
	}
})), require_is_extendable = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function(val) {
		return val != null && (typeof val == "object" || typeof val == "function");
	};
})), require_extend_shallow = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isObject$1 = require_is_extendable();
	module.exports = function(o) {
		isObject$1(o) || (o = {});
		for (var len$1 = arguments.length, i$2 = 1; i$2 < len$1; i$2++) {
			var obj = arguments[i$2];
			isObject$1(obj) && assign(o, obj);
		}
		return o;
	};
	function assign(a, b) {
		for (var key in b) hasOwn(b, key) && (a[key] = b[key]);
	}
	function hasOwn(obj, key) {
		return Object.prototype.hasOwnProperty.call(obj, key);
	}
})), require_section_matter = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var typeOf$3 = require_kind_of(), extend$1 = require_extend_shallow();
	module.exports = function(input, options) {
		typeof options == "function" && (options = { parse: options });
		var file = toObject(input), opts = extend$1({}, {
			section_delimiter: "---",
			parse: identity
		}, options), delim = opts.section_delimiter, lines = file.content.split(/\r?\n/), sections$1 = null, section = createSection(), content$2 = [], stack = [];
		function initSections(val) {
			file.content = val, sections$1 = [], content$2 = [];
		}
		function closeSection(val) {
			stack.length && (section.key = getKey(stack[0], delim), section.content = val, opts.parse(section, sections$1), sections$1.push(section), section = createSection(), content$2 = [], stack = []);
		}
		for (var i$2 = 0; i$2 < lines.length; i$2++) {
			var line = lines[i$2], len$1 = stack.length, ln = line.trim();
			if (isDelimiter(ln, delim)) {
				if (ln.length === 3 && i$2 !== 0) {
					if (len$1 === 0 || len$1 === 2) {
						content$2.push(line);
						continue;
					}
					stack.push(ln), section.data = content$2.join("\n"), content$2 = [];
					continue;
				}
				sections$1 === null && initSections(content$2.join("\n")), len$1 === 2 && closeSection(content$2.join("\n")), stack.push(ln);
				continue;
			}
			content$2.push(line);
		}
		return sections$1 === null ? initSections(content$2.join("\n")) : closeSection(content$2.join("\n")), file.sections = sections$1, file;
	};
	function isDelimiter(line, delim) {
		return !(line.slice(0, delim.length) !== delim || line.charAt(delim.length + 1) === delim.slice(-1));
	}
	function toObject(input) {
		if (typeOf$3(input) !== "object" && (input = { content: input }), typeof input.content != "string" && !isBuffer(input.content)) throw TypeError("expected a buffer or string");
		return input.content = input.content.toString(), input.sections = [], input;
	}
	function getKey(val, delim) {
		return val ? val.slice(delim.length).trim() : "";
	}
	function createSection() {
		return {
			key: "",
			data: "",
			content: ""
		};
	}
	function identity(val) {
		return val;
	}
	function isBuffer(val) {
		return val && val.constructor && typeof val.constructor.isBuffer == "function" ? val.constructor.isBuffer(val) : !1;
	}
})), require_common = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function isNothing(subject) {
		return subject == null;
	}
	function isObject(subject) {
		return typeof subject == "object" && !!subject;
	}
	function toArray(sequence) {
		return Array.isArray(sequence) ? sequence : isNothing(sequence) ? [] : [sequence];
	}
	function extend(target, source$2) {
		var index$2, length, key, sourceKeys;
		if (source$2) for (sourceKeys = Object.keys(source$2), index$2 = 0, length = sourceKeys.length; index$2 < length; index$2 += 1) key = sourceKeys[index$2], target[key] = source$2[key];
		return target;
	}
	function repeat(string$2, count) {
		var result = "", cycle;
		for (cycle = 0; cycle < count; cycle += 1) result += string$2;
		return result;
	}
	function isNegativeZero(number$1) {
		return number$1 === 0 && 1 / number$1 == -Infinity;
	}
	module.exports.isNothing = isNothing, module.exports.isObject = isObject, module.exports.toArray = toArray, module.exports.repeat = repeat, module.exports.isNegativeZero = isNegativeZero, module.exports.extend = extend;
})), require_exception = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function YAMLException$4(reason, mark$1) {
		Error.call(this), this.name = "YAMLException", this.reason = reason, this.mark = mark$1, this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : ""), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = (/* @__PURE__ */ Error()).stack || "";
	}
	YAMLException$4.prototype = Object.create(Error.prototype), YAMLException$4.prototype.constructor = YAMLException$4, YAMLException$4.prototype.toString = function(compact) {
		var result = this.name + ": ";
		return result += this.reason || "(unknown reason)", !compact && this.mark && (result += " " + this.mark.toString()), result;
	}, module.exports = YAMLException$4;
})), require_mark = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var common$5 = require_common();
	function Mark$1(name$1, buffer, position$2, line, column) {
		this.name = name$1, this.buffer = buffer, this.position = position$2, this.line = line, this.column = column;
	}
	Mark$1.prototype.getSnippet = function(indent$1, maxLength) {
		var head, start, tail, end, snippet;
		if (!this.buffer) return null;
		for (indent$1 ||= 4, maxLength ||= 75, head = "", start = this.position; start > 0 && "\0\r\nÂ…\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) === -1;) if (--start, this.position - start > maxLength / 2 - 1) {
			head = " ... ", start += 5;
			break;
		}
		for (tail = "", end = this.position; end < this.buffer.length && "\0\r\nÂ…\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1;) if (end += 1, end - this.position > maxLength / 2 - 1) {
			tail = " ... ", end -= 5;
			break;
		}
		return snippet = this.buffer.slice(start, end), common$5.repeat(" ", indent$1) + head + snippet + tail + "\n" + common$5.repeat(" ", indent$1 + this.position - start + head.length) + "^";
	}, Mark$1.prototype.toString = function(compact) {
		var snippet, where = "";
		return this.name && (where += "in \"" + this.name + "\" "), where += "at line " + (this.line + 1) + ", column " + (this.column + 1), compact || (snippet = this.getSnippet(), snippet && (where += ":\n" + snippet)), where;
	}, module.exports = Mark$1;
})), require_type = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var YAMLException$3 = require_exception(), TYPE_CONSTRUCTOR_OPTIONS = [
		"kind",
		"resolve",
		"construct",
		"instanceOf",
		"predicate",
		"represent",
		"defaultStyle",
		"styleAliases"
	], YAML_NODE_KINDS = [
		"scalar",
		"sequence",
		"mapping"
	];
	function compileStyleAliases(map$2) {
		var result = {};
		return map$2 !== null && Object.keys(map$2).forEach(function(style) {
			map$2[style].forEach(function(alias) {
				result[String(alias)] = style;
			});
		}), result;
	}
	function Type$17(tag, options) {
		if (options ||= {}, Object.keys(options).forEach(function(name$1) {
			if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name$1) === -1) throw new YAMLException$3("Unknown option \"" + name$1 + "\" is met in definition of \"" + tag + "\" YAML type.");
		}), this.tag = tag, this.kind = options.kind || null, this.resolve = options.resolve || function() {
			return !0;
		}, this.construct = options.construct || function(data) {
			return data;
		}, this.instanceOf = options.instanceOf || null, this.predicate = options.predicate || null, this.represent = options.represent || null, this.defaultStyle = options.defaultStyle || null, this.styleAliases = compileStyleAliases(options.styleAliases || null), YAML_NODE_KINDS.indexOf(this.kind) === -1) throw new YAMLException$3("Unknown kind \"" + this.kind + "\" is specified for \"" + tag + "\" YAML type.");
	}
	module.exports = Type$17;
})), require_schema = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var common$4 = require_common(), YAMLException$2 = require_exception(), Type$16 = require_type();
	function compileList(schema, name$1, result) {
		var exclude = [];
		return schema.include.forEach(function(includedSchema) {
			result = compileList(includedSchema, name$1, result);
		}), schema[name$1].forEach(function(currentType) {
			result.forEach(function(previousType, previousIndex) {
				previousType.tag === currentType.tag && previousType.kind === currentType.kind && exclude.push(previousIndex);
			}), result.push(currentType);
		}), result.filter(function(type, index$2) {
			return exclude.indexOf(index$2) === -1;
		});
	}
	function compileMap() {
		var result = {
			scalar: {},
			sequence: {},
			mapping: {},
			fallback: {}
		}, index$2, length;
		function collectType(type) {
			result[type.kind][type.tag] = result.fallback[type.tag] = type;
		}
		for (index$2 = 0, length = arguments.length; index$2 < length; index$2 += 1) arguments[index$2].forEach(collectType);
		return result;
	}
	function Schema$5(definition$2) {
		this.include = definition$2.include || [], this.implicit = definition$2.implicit || [], this.explicit = definition$2.explicit || [], this.implicit.forEach(function(type) {
			if (type.loadKind && type.loadKind !== "scalar") throw new YAMLException$2("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
		}), this.compiledImplicit = compileList(this, "implicit", []), this.compiledExplicit = compileList(this, "explicit", []), this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
	}
	Schema$5.DEFAULT = null, Schema$5.create = function() {
		var schemas, types;
		switch (arguments.length) {
			case 1:
				schemas = Schema$5.DEFAULT, types = arguments[0];
				break;
			case 2:
				schemas = arguments[0], types = arguments[1];
				break;
			default: throw new YAMLException$2("Wrong number of arguments for Schema.create function");
		}
		if (schemas = common$4.toArray(schemas), types = common$4.toArray(types), !schemas.every(function(schema) {
			return schema instanceof Schema$5;
		})) throw new YAMLException$2("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
		if (!types.every(function(type) {
			return type instanceof Type$16;
		})) throw new YAMLException$2("Specified list of YAML types (or a single Type object) contains a non-Type object.");
		return new Schema$5({
			include: schemas,
			explicit: types
		});
	}, module.exports = Schema$5;
})), require_str = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = new (require_type())("tag:yaml.org,2002:str", {
		kind: "scalar",
		construct: function(data) {
			return data === null ? "" : data;
		}
	});
})), require_seq = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = new (require_type())("tag:yaml.org,2002:seq", {
		kind: "sequence",
		construct: function(data) {
			return data === null ? [] : data;
		}
	});
})), require_map = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = new (require_type())("tag:yaml.org,2002:map", {
		kind: "mapping",
		construct: function(data) {
			return data === null ? {} : data;
		}
	});
})), require_failsafe = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = new (require_schema())({ explicit: [
		require_str(),
		require_seq(),
		require_map()
	] });
})), require_null = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Type$12 = require_type();
	function resolveYamlNull(data) {
		if (data === null) return !0;
		var max = data.length;
		return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
	}
	function constructYamlNull() {
		return null;
	}
	function isNull(object) {
		return object === null;
	}
	module.exports = new Type$12("tag:yaml.org,2002:null", {
		kind: "scalar",
		resolve: resolveYamlNull,
		construct: constructYamlNull,
		predicate: isNull,
		represent: {
			canonical: function() {
				return "~";
			},
			lowercase: function() {
				return "null";
			},
			uppercase: function() {
				return "NULL";
			},
			camelcase: function() {
				return "Null";
			}
		},
		defaultStyle: "lowercase"
	});
})), require_bool = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Type$11 = require_type();
	function resolveYamlBoolean(data) {
		if (data === null) return !1;
		var max = data.length;
		return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
	}
	function constructYamlBoolean(data) {
		return data === "true" || data === "True" || data === "TRUE";
	}
	function isBoolean(object) {
		return Object.prototype.toString.call(object) === "[object Boolean]";
	}
	module.exports = new Type$11("tag:yaml.org,2002:bool", {
		kind: "scalar",
		resolve: resolveYamlBoolean,
		construct: constructYamlBoolean,
		predicate: isBoolean,
		represent: {
			lowercase: function(object) {
				return object ? "true" : "false";
			},
			uppercase: function(object) {
				return object ? "TRUE" : "FALSE";
			},
			camelcase: function(object) {
				return object ? "True" : "False";
			}
		},
		defaultStyle: "lowercase"
	});
})), require_int = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var common$3 = require_common(), Type$10 = require_type();
	function isHexCode(c$1) {
		return 48 <= c$1 && c$1 <= 57 || 65 <= c$1 && c$1 <= 70 || 97 <= c$1 && c$1 <= 102;
	}
	function isOctCode(c$1) {
		return 48 <= c$1 && c$1 <= 55;
	}
	function isDecCode(c$1) {
		return 48 <= c$1 && c$1 <= 57;
	}
	function resolveYamlInteger(data) {
		if (data === null) return !1;
		var max = data.length, index$2 = 0, hasDigits = !1, ch;
		if (!max) return !1;
		if (ch = data[index$2], (ch === "-" || ch === "+") && (ch = data[++index$2]), ch === "0") {
			if (index$2 + 1 === max) return !0;
			if (ch = data[++index$2], ch === "b") {
				for (index$2++; index$2 < max; index$2++) if (ch = data[index$2], ch !== "_") {
					if (ch !== "0" && ch !== "1") return !1;
					hasDigits = !0;
				}
				return hasDigits && ch !== "_";
			}
			if (ch === "x") {
				for (index$2++; index$2 < max; index$2++) if (ch = data[index$2], ch !== "_") {
					if (!isHexCode(data.charCodeAt(index$2))) return !1;
					hasDigits = !0;
				}
				return hasDigits && ch !== "_";
			}
			for (; index$2 < max; index$2++) if (ch = data[index$2], ch !== "_") {
				if (!isOctCode(data.charCodeAt(index$2))) return !1;
				hasDigits = !0;
			}
			return hasDigits && ch !== "_";
		}
		if (ch === "_") return !1;
		for (; index$2 < max; index$2++) if (ch = data[index$2], ch !== "_") {
			if (ch === ":") break;
			if (!isDecCode(data.charCodeAt(index$2))) return !1;
			hasDigits = !0;
		}
		return !hasDigits || ch === "_" ? !1 : ch === ":" ? /^(:[0-5]?[0-9])+$/.test(data.slice(index$2)) : !0;
	}
	function constructYamlInteger(data) {
		var value = data, sign = 1, ch, base, digits = [];
		return value.indexOf("_") !== -1 && (value = value.replace(/_/g, "")), ch = value[0], (ch === "-" || ch === "+") && (ch === "-" && (sign = -1), value = value.slice(1), ch = value[0]), value === "0" ? 0 : ch === "0" ? value[1] === "b" ? sign * parseInt(value.slice(2), 2) : value[1] === "x" ? sign * parseInt(value, 16) : sign * parseInt(value, 8) : value.indexOf(":") === -1 ? sign * parseInt(value, 10) : (value.split(":").forEach(function(v) {
			digits.unshift(parseInt(v, 10));
		}), value = 0, base = 1, digits.forEach(function(d) {
			value += d * base, base *= 60;
		}), sign * value);
	}
	function isInteger(object) {
		return Object.prototype.toString.call(object) === "[object Number]" && object % 1 == 0 && !common$3.isNegativeZero(object);
	}
	module.exports = new Type$10("tag:yaml.org,2002:int", {
		kind: "scalar",
		resolve: resolveYamlInteger,
		construct: constructYamlInteger,
		predicate: isInteger,
		represent: {
			binary: function(obj) {
				return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
			},
			octal: function(obj) {
				return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
			},
			decimal: function(obj) {
				return obj.toString(10);
			},
			hexadecimal: function(obj) {
				return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
			}
		},
		defaultStyle: "decimal",
		styleAliases: {
			binary: [2, "bin"],
			octal: [8, "oct"],
			decimal: [10, "dec"],
			hexadecimal: [16, "hex"]
		}
	});
})), require_float = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var common$2 = require_common(), Type$9 = require_type(), YAML_FLOAT_PATTERN = /* @__PURE__ */ RegExp("^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
	function resolveYamlFloat(data) {
		return !(data === null || !YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === "_");
	}
	function constructYamlFloat(data) {
		var value = data.replace(/_/g, "").toLowerCase(), sign = value[0] === "-" ? -1 : 1, base, digits = [];
		return "+-".indexOf(value[0]) >= 0 && (value = value.slice(1)), value === ".inf" ? sign === 1 ? Infinity : -Infinity : value === ".nan" ? NaN : value.indexOf(":") >= 0 ? (value.split(":").forEach(function(v) {
			digits.unshift(parseFloat(v, 10));
		}), value = 0, base = 1, digits.forEach(function(d) {
			value += d * base, base *= 60;
		}), sign * value) : sign * parseFloat(value, 10);
	}
	var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
	function representYamlFloat(object, style) {
		var res;
		if (isNaN(object)) switch (style) {
			case "lowercase": return ".nan";
			case "uppercase": return ".NAN";
			case "camelcase": return ".NaN";
		}
		else if (object === Infinity) switch (style) {
			case "lowercase": return ".inf";
			case "uppercase": return ".INF";
			case "camelcase": return ".Inf";
		}
		else if (object === -Infinity) switch (style) {
			case "lowercase": return "-.inf";
			case "uppercase": return "-.INF";
			case "camelcase": return "-.Inf";
		}
		else if (common$2.isNegativeZero(object)) return "-0.0";
		return res = object.toString(10), SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
	}
	function isFloat(object) {
		return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 != 0 || common$2.isNegativeZero(object));
	}
	module.exports = new Type$9("tag:yaml.org,2002:float", {
		kind: "scalar",
		resolve: resolveYamlFloat,
		construct: constructYamlFloat,
		predicate: isFloat,
		represent: representYamlFloat,
		defaultStyle: "lowercase"
	});
})), require_json = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = new (require_schema())({
		include: [require_failsafe()],
		implicit: [
			require_null(),
			require_bool(),
			require_int(),
			require_float()
		]
	});
})), require_core = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = new (require_schema())({ include: [require_json()] });
})), require_timestamp = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Type$8 = require_type(), YAML_DATE_REGEXP = /* @__PURE__ */ RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"), YAML_TIMESTAMP_REGEXP = /* @__PURE__ */ RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
	function resolveYamlTimestamp(data) {
		return data === null ? !1 : YAML_DATE_REGEXP.exec(data) !== null || YAML_TIMESTAMP_REGEXP.exec(data) !== null;
	}
	function constructYamlTimestamp(data) {
		var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
		if (match = YAML_DATE_REGEXP.exec(data), match === null && (match = YAML_TIMESTAMP_REGEXP.exec(data)), match === null) throw Error("Date resolve error");
		if (year = +match[1], month = match[2] - 1, day = +match[3], !match[4]) return new Date(Date.UTC(year, month, day));
		if (hour = +match[4], minute = +match[5], second = +match[6], match[7]) {
			for (fraction = match[7].slice(0, 3); fraction.length < 3;) fraction += "0";
			fraction = +fraction;
		}
		return match[9] && (tz_hour = +match[10], tz_minute = +(match[11] || 0), delta = (tz_hour * 60 + tz_minute) * 6e4, match[9] === "-" && (delta = -delta)), date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction)), delta && date.setTime(date.getTime() - delta), date;
	}
	function representYamlTimestamp(object) {
		return object.toISOString();
	}
	module.exports = new Type$8("tag:yaml.org,2002:timestamp", {
		kind: "scalar",
		resolve: resolveYamlTimestamp,
		construct: constructYamlTimestamp,
		instanceOf: Date,
		represent: representYamlTimestamp
	});
})), require_merge = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Type$7 = require_type();
	function resolveYamlMerge(data) {
		return data === "<<" || data === null;
	}
	module.exports = new Type$7("tag:yaml.org,2002:merge", {
		kind: "scalar",
		resolve: resolveYamlMerge
	});
})), require_base64_js = /* @__PURE__ */ __commonJSMin(((exports) => {
	exports.byteLength = byteLength$1, exports.toByteArray = toByteArray, exports.fromByteArray = fromByteArray;
	for (var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i$1 = 0, len = code.length; i$1 < len; ++i$1) lookup[i$1] = code[i$1], revLookup[code.charCodeAt(i$1)] = i$1;
	revLookup[45] = 62, revLookup[95] = 63;
	function getLens(b64) {
		var len$1 = b64.length;
		if (len$1 % 4 > 0) throw Error("Invalid string. Length must be a multiple of 4");
		var validLen = b64.indexOf("=");
		validLen === -1 && (validLen = len$1);
		var placeHoldersLen = validLen === len$1 ? 0 : 4 - validLen % 4;
		return [validLen, placeHoldersLen];
	}
	function byteLength$1(b64) {
		var lens = getLens(b64), validLen = lens[0], placeHoldersLen = lens[1];
		return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
	}
	function _byteLength(b64, validLen, placeHoldersLen) {
		return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
	}
	function toByteArray(b64) {
		var tmp, lens = getLens(b64), validLen = lens[0], placeHoldersLen = lens[1], arr = new Arr(_byteLength(b64, validLen, placeHoldersLen)), curByte = 0, len$1 = placeHoldersLen > 0 ? validLen - 4 : validLen, i$2;
		for (i$2 = 0; i$2 < len$1; i$2 += 4) tmp = revLookup[b64.charCodeAt(i$2)] << 18 | revLookup[b64.charCodeAt(i$2 + 1)] << 12 | revLookup[b64.charCodeAt(i$2 + 2)] << 6 | revLookup[b64.charCodeAt(i$2 + 3)], arr[curByte++] = tmp >> 16 & 255, arr[curByte++] = tmp >> 8 & 255, arr[curByte++] = tmp & 255;
		return placeHoldersLen === 2 && (tmp = revLookup[b64.charCodeAt(i$2)] << 2 | revLookup[b64.charCodeAt(i$2 + 1)] >> 4, arr[curByte++] = tmp & 255), placeHoldersLen === 1 && (tmp = revLookup[b64.charCodeAt(i$2)] << 10 | revLookup[b64.charCodeAt(i$2 + 1)] << 4 | revLookup[b64.charCodeAt(i$2 + 2)] >> 2, arr[curByte++] = tmp >> 8 & 255, arr[curByte++] = tmp & 255), arr;
	}
	function tripletToBase64(num) {
		return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
	}
	function encodeChunk(uint8, start, end) {
		for (var tmp, output = [], i$2 = start; i$2 < end; i$2 += 3) tmp = (uint8[i$2] << 16 & 16711680) + (uint8[i$2 + 1] << 8 & 65280) + (uint8[i$2 + 2] & 255), output.push(tripletToBase64(tmp));
		return output.join("");
	}
	function fromByteArray(uint8) {
		for (var tmp, len$1 = uint8.length, extraBytes = len$1 % 3, parts = [], maxChunkLength = 16383, i$2 = 0, len2 = len$1 - extraBytes; i$2 < len2; i$2 += maxChunkLength) parts.push(encodeChunk(uint8, i$2, i$2 + maxChunkLength > len2 ? len2 : i$2 + maxChunkLength));
		return extraBytes === 1 ? (tmp = uint8[len$1 - 1], parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==")) : extraBytes === 2 && (tmp = (uint8[len$1 - 2] << 8) + uint8[len$1 - 1], parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=")), parts.join("");
	}
})), require_ieee754 = /* @__PURE__ */ __commonJSMin(((exports) => {
	exports.read = function(buffer, offset, isLE, mLen, nBytes) {
		var e, m, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i$2 = isLE ? nBytes - 1 : 0, d = isLE ? -1 : 1, s = buffer[offset + i$2];
		for (i$2 += d, e = s & (1 << -nBits) - 1, s >>= -nBits, nBits += eLen; nBits > 0; e = e * 256 + buffer[offset + i$2], i$2 += d, nBits -= 8);
		for (m = e & (1 << -nBits) - 1, e >>= -nBits, nBits += mLen; nBits > 0; m = m * 256 + buffer[offset + i$2], i$2 += d, nBits -= 8);
		if (e === 0) e = 1 - eBias;
		else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
		else m += 2 ** mLen, e -= eBias;
		return (s ? -1 : 1) * m * 2 ** (e - mLen);
	}, exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
		var e, m, c$1, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = mLen === 23 ? 2 ** -24 - 2 ** -77 : 0, i$2 = isLE ? 0 : nBytes - 1, d = isLE ? 1 : -1, s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
		for (value = Math.abs(value), isNaN(value) || value === Infinity ? (m = isNaN(value) ? 1 : 0, e = eMax) : (e = Math.floor(Math.log(value) / Math.LN2), value * (c$1 = 2 ** -e) < 1 && (e--, c$1 *= 2), e + eBias >= 1 ? value += rt / c$1 : value += rt * 2 ** (1 - eBias), value * c$1 >= 2 && (e++, c$1 /= 2), e + eBias >= eMax ? (m = 0, e = eMax) : e + eBias >= 1 ? (m = (value * c$1 - 1) * 2 ** mLen, e += eBias) : (m = value * 2 ** (eBias - 1) * 2 ** mLen, e = 0)); mLen >= 8; buffer[offset + i$2] = m & 255, i$2 += d, m /= 256, mLen -= 8);
		for (e = e << mLen | m, eLen += mLen; eLen > 0; buffer[offset + i$2] = e & 255, i$2 += d, e /= 256, eLen -= 8);
		buffer[offset + i$2 - d] |= s * 128;
	};
})), require_buffer = /* @__PURE__ */ __commonJSMin(((exports) => {
	var base64 = require_base64_js(), ieee754 = require_ieee754(), customInspectSymbol = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
	exports.Buffer = Buffer$2, exports.SlowBuffer = SlowBuffer, exports.INSPECT_MAX_BYTES = 50;
	var K_MAX_LENGTH = 2147483647;
	exports.kMaxLength = K_MAX_LENGTH, Buffer$2.TYPED_ARRAY_SUPPORT = typedArraySupport(), !Buffer$2.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
	function typedArraySupport() {
		try {
			let arr = new Uint8Array(1), proto = { foo: function() {
				return 42;
			} };
			return Object.setPrototypeOf(proto, Uint8Array.prototype), Object.setPrototypeOf(arr, proto), arr.foo() === 42;
		} catch {
			return !1;
		}
	}
	Object.defineProperty(Buffer$2.prototype, "parent", {
		enumerable: !0,
		get: function() {
			if (Buffer$2.isBuffer(this)) return this.buffer;
		}
	}), Object.defineProperty(Buffer$2.prototype, "offset", {
		enumerable: !0,
		get: function() {
			if (Buffer$2.isBuffer(this)) return this.byteOffset;
		}
	});
	function createBuffer(length) {
		if (length > K_MAX_LENGTH) throw RangeError("The value \"" + length + "\" is invalid for option \"size\"");
		let buf = new Uint8Array(length);
		return Object.setPrototypeOf(buf, Buffer$2.prototype), buf;
	}
	function Buffer$2(arg, encodingOrOffset, length) {
		if (typeof arg == "number") {
			if (typeof encodingOrOffset == "string") throw TypeError("The \"string\" argument must be of type string. Received type number");
			return allocUnsafe(arg);
		}
		return from(arg, encodingOrOffset, length);
	}
	Buffer$2.poolSize = 8192;
	function from(value, encodingOrOffset, length) {
		if (typeof value == "string") return fromString(value, encodingOrOffset);
		if (ArrayBuffer.isView(value)) return fromArrayView(value);
		if (value == null) throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
		if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
		if (typeof value == "number") throw TypeError("The \"value\" argument must not be of type number. Received type number");
		let valueOf = value.valueOf && value.valueOf();
		if (valueOf != null && valueOf !== value) return Buffer$2.from(valueOf, encodingOrOffset, length);
		let b = fromObject(value);
		if (b) return b;
		if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] == "function") return Buffer$2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
		throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
	}
	Buffer$2.from = function(value, encodingOrOffset, length) {
		return from(value, encodingOrOffset, length);
	}, Object.setPrototypeOf(Buffer$2.prototype, Uint8Array.prototype), Object.setPrototypeOf(Buffer$2, Uint8Array);
	function assertSize(size) {
		if (typeof size != "number") throw TypeError("\"size\" argument must be of type number");
		if (size < 0) throw RangeError("The value \"" + size + "\" is invalid for option \"size\"");
	}
	function alloc(size, fill, encoding) {
		return assertSize(size), size <= 0 || fill === void 0 ? createBuffer(size) : typeof encoding == "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
	}
	Buffer$2.alloc = function(size, fill, encoding) {
		return alloc(size, fill, encoding);
	};
	function allocUnsafe(size) {
		return assertSize(size), createBuffer(size < 0 ? 0 : checked(size) | 0);
	}
	Buffer$2.allocUnsafe = function(size) {
		return allocUnsafe(size);
	}, Buffer$2.allocUnsafeSlow = function(size) {
		return allocUnsafe(size);
	};
	function fromString(string$2, encoding) {
		if ((typeof encoding != "string" || encoding === "") && (encoding = "utf8"), !Buffer$2.isEncoding(encoding)) throw TypeError("Unknown encoding: " + encoding);
		let length = byteLength(string$2, encoding) | 0, buf = createBuffer(length), actual = buf.write(string$2, encoding);
		return actual !== length && (buf = buf.slice(0, actual)), buf;
	}
	function fromArrayLike(array) {
		let length = array.length < 0 ? 0 : checked(array.length) | 0, buf = createBuffer(length);
		for (let i$2 = 0; i$2 < length; i$2 += 1) buf[i$2] = array[i$2] & 255;
		return buf;
	}
	function fromArrayView(arrayView) {
		if (isInstance(arrayView, Uint8Array)) {
			let copy = new Uint8Array(arrayView);
			return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
		}
		return fromArrayLike(arrayView);
	}
	function fromArrayBuffer(array, byteOffset, length) {
		if (byteOffset < 0 || array.byteLength < byteOffset) throw RangeError("\"offset\" is outside of buffer bounds");
		if (array.byteLength < byteOffset + (length || 0)) throw RangeError("\"length\" is outside of buffer bounds");
		let buf;
		return buf = byteOffset === void 0 && length === void 0 ? new Uint8Array(array) : length === void 0 ? new Uint8Array(array, byteOffset) : new Uint8Array(array, byteOffset, length), Object.setPrototypeOf(buf, Buffer$2.prototype), buf;
	}
	function fromObject(obj) {
		if (Buffer$2.isBuffer(obj)) {
			let len$1 = checked(obj.length) | 0, buf = createBuffer(len$1);
			return buf.length === 0 || obj.copy(buf, 0, 0, len$1), buf;
		}
		if (obj.length !== void 0) return typeof obj.length != "number" || numberIsNaN(obj.length) ? createBuffer(0) : fromArrayLike(obj);
		if (obj.type === "Buffer" && Array.isArray(obj.data)) return fromArrayLike(obj.data);
	}
	function checked(length) {
		if (length >= K_MAX_LENGTH) throw RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
		return length | 0;
	}
	function SlowBuffer(length) {
		return +length != length && (length = 0), Buffer$2.alloc(+length);
	}
	Buffer$2.isBuffer = function(b) {
		return b != null && b._isBuffer === !0 && b !== Buffer$2.prototype;
	}, Buffer$2.compare = function(a, b) {
		if (isInstance(a, Uint8Array) && (a = Buffer$2.from(a, a.offset, a.byteLength)), isInstance(b, Uint8Array) && (b = Buffer$2.from(b, b.offset, b.byteLength)), !Buffer$2.isBuffer(a) || !Buffer$2.isBuffer(b)) throw TypeError("The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array");
		if (a === b) return 0;
		let x = a.length, y = b.length;
		for (let i$2 = 0, len$1 = Math.min(x, y); i$2 < len$1; ++i$2) if (a[i$2] !== b[i$2]) {
			x = a[i$2], y = b[i$2];
			break;
		}
		return x < y ? -1 : y < x ? 1 : 0;
	}, Buffer$2.isEncoding = function(encoding) {
		switch (String(encoding).toLowerCase()) {
			case "hex":
			case "utf8":
			case "utf-8":
			case "ascii":
			case "latin1":
			case "binary":
			case "base64":
			case "ucs2":
			case "ucs-2":
			case "utf16le":
			case "utf-16le": return !0;
			default: return !1;
		}
	}, Buffer$2.concat = function(list$3, length) {
		if (!Array.isArray(list$3)) throw TypeError("\"list\" argument must be an Array of Buffers");
		if (list$3.length === 0) return Buffer$2.alloc(0);
		let i$2;
		if (length === void 0) for (length = 0, i$2 = 0; i$2 < list$3.length; ++i$2) length += list$3[i$2].length;
		let buffer = Buffer$2.allocUnsafe(length), pos = 0;
		for (i$2 = 0; i$2 < list$3.length; ++i$2) {
			let buf = list$3[i$2];
			if (isInstance(buf, Uint8Array)) pos + buf.length > buffer.length ? (Buffer$2.isBuffer(buf) || (buf = Buffer$2.from(buf)), buf.copy(buffer, pos)) : Uint8Array.prototype.set.call(buffer, buf, pos);
			else if (Buffer$2.isBuffer(buf)) buf.copy(buffer, pos);
			else throw TypeError("\"list\" argument must be an Array of Buffers");
			pos += buf.length;
		}
		return buffer;
	};
	function byteLength(string$2, encoding) {
		if (Buffer$2.isBuffer(string$2)) return string$2.length;
		if (ArrayBuffer.isView(string$2) || isInstance(string$2, ArrayBuffer)) return string$2.byteLength;
		if (typeof string$2 != "string") throw TypeError("The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type " + typeof string$2);
		let len$1 = string$2.length, mustMatch = arguments.length > 2 && arguments[2] === !0;
		if (!mustMatch && len$1 === 0) return 0;
		let loweredCase = !1;
		for (;;) switch (encoding) {
			case "ascii":
			case "latin1":
			case "binary": return len$1;
			case "utf8":
			case "utf-8": return utf8ToBytes(string$2).length;
			case "ucs2":
			case "ucs-2":
			case "utf16le":
			case "utf-16le": return len$1 * 2;
			case "hex": return len$1 >>> 1;
			case "base64": return base64ToBytes(string$2).length;
			default:
				if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string$2).length;
				encoding = ("" + encoding).toLowerCase(), loweredCase = !0;
		}
	}
	Buffer$2.byteLength = byteLength;
	function slowToString(encoding, start, end) {
		let loweredCase = !1;
		if ((start === void 0 || start < 0) && (start = 0), start > this.length || ((end === void 0 || end > this.length) && (end = this.length), end <= 0) || (end >>>= 0, start >>>= 0, end <= start)) return "";
		for (encoding ||= "utf8";;) switch (encoding) {
			case "hex": return hexSlice(this, start, end);
			case "utf8":
			case "utf-8": return utf8Slice(this, start, end);
			case "ascii": return asciiSlice(this, start, end);
			case "latin1":
			case "binary": return latin1Slice(this, start, end);
			case "base64": return base64Slice(this, start, end);
			case "ucs2":
			case "ucs-2":
			case "utf16le":
			case "utf-16le": return utf16leSlice(this, start, end);
			default:
				if (loweredCase) throw TypeError("Unknown encoding: " + encoding);
				encoding = (encoding + "").toLowerCase(), loweredCase = !0;
		}
	}
	Buffer$2.prototype._isBuffer = !0;
	function swap(b, n, m) {
		let i$2 = b[n];
		b[n] = b[m], b[m] = i$2;
	}
	Buffer$2.prototype.swap16 = function() {
		let len$1 = this.length;
		if (len$1 % 2 != 0) throw RangeError("Buffer size must be a multiple of 16-bits");
		for (let i$2 = 0; i$2 < len$1; i$2 += 2) swap(this, i$2, i$2 + 1);
		return this;
	}, Buffer$2.prototype.swap32 = function() {
		let len$1 = this.length;
		if (len$1 % 4 != 0) throw RangeError("Buffer size must be a multiple of 32-bits");
		for (let i$2 = 0; i$2 < len$1; i$2 += 4) swap(this, i$2, i$2 + 3), swap(this, i$2 + 1, i$2 + 2);
		return this;
	}, Buffer$2.prototype.swap64 = function() {
		let len$1 = this.length;
		if (len$1 % 8 != 0) throw RangeError("Buffer size must be a multiple of 64-bits");
		for (let i$2 = 0; i$2 < len$1; i$2 += 8) swap(this, i$2, i$2 + 7), swap(this, i$2 + 1, i$2 + 6), swap(this, i$2 + 2, i$2 + 5), swap(this, i$2 + 3, i$2 + 4);
		return this;
	}, Buffer$2.prototype.toString = function() {
		let length = this.length;
		return length === 0 ? "" : arguments.length === 0 ? utf8Slice(this, 0, length) : slowToString.apply(this, arguments);
	}, Buffer$2.prototype.toLocaleString = Buffer$2.prototype.toString, Buffer$2.prototype.equals = function(b) {
		if (!Buffer$2.isBuffer(b)) throw TypeError("Argument must be a Buffer");
		return this === b ? !0 : Buffer$2.compare(this, b) === 0;
	}, Buffer$2.prototype.inspect = function() {
		let str = "", max = exports.INSPECT_MAX_BYTES;
		return str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim(), this.length > max && (str += " ... "), "<Buffer " + str + ">";
	}, customInspectSymbol && (Buffer$2.prototype[customInspectSymbol] = Buffer$2.prototype.inspect), Buffer$2.prototype.compare = function(target, start, end, thisStart, thisEnd) {
		if (isInstance(target, Uint8Array) && (target = Buffer$2.from(target, target.offset, target.byteLength)), !Buffer$2.isBuffer(target)) throw TypeError("The \"target\" argument must be one of type Buffer or Uint8Array. Received type " + typeof target);
		if (start === void 0 && (start = 0), end === void 0 && (end = target ? target.length : 0), thisStart === void 0 && (thisStart = 0), thisEnd === void 0 && (thisEnd = this.length), start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw RangeError("out of range index");
		if (thisStart >= thisEnd && start >= end) return 0;
		if (thisStart >= thisEnd) return -1;
		if (start >= end) return 1;
		if (start >>>= 0, end >>>= 0, thisStart >>>= 0, thisEnd >>>= 0, this === target) return 0;
		let x = thisEnd - thisStart, y = end - start, len$1 = Math.min(x, y), thisCopy = this.slice(thisStart, thisEnd), targetCopy = target.slice(start, end);
		for (let i$2 = 0; i$2 < len$1; ++i$2) if (thisCopy[i$2] !== targetCopy[i$2]) {
			x = thisCopy[i$2], y = targetCopy[i$2];
			break;
		}
		return x < y ? -1 : y < x ? 1 : 0;
	};
	function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
		if (buffer.length === 0) return -1;
		if (typeof byteOffset == "string" ? (encoding = byteOffset, byteOffset = 0) : byteOffset > 2147483647 ? byteOffset = 2147483647 : byteOffset < -2147483648 && (byteOffset = -2147483648), byteOffset = +byteOffset, numberIsNaN(byteOffset) && (byteOffset = dir ? 0 : buffer.length - 1), byteOffset < 0 && (byteOffset = buffer.length + byteOffset), byteOffset >= buffer.length) {
			if (dir) return -1;
			byteOffset = buffer.length - 1;
		} else if (byteOffset < 0) if (dir) byteOffset = 0;
		else return -1;
		if (typeof val == "string" && (val = Buffer$2.from(val, encoding)), Buffer$2.isBuffer(val)) return val.length === 0 ? -1 : arrayIndexOf(buffer, val, byteOffset, encoding, dir);
		if (typeof val == "number") return val &= 255, typeof Uint8Array.prototype.indexOf == "function" ? dir ? Uint8Array.prototype.indexOf.call(buffer, val, byteOffset) : Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset) : arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
		throw TypeError("val must be string, number or Buffer");
	}
	function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
		let indexSize = 1, arrLength = arr.length, valLength = val.length;
		if (encoding !== void 0 && (encoding = String(encoding).toLowerCase(), encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le")) {
			if (arr.length < 2 || val.length < 2) return -1;
			indexSize = 2, arrLength /= 2, valLength /= 2, byteOffset /= 2;
		}
		function read(buf, i$3) {
			return indexSize === 1 ? buf[i$3] : buf.readUInt16BE(i$3 * indexSize);
		}
		let i$2;
		if (dir) {
			let foundIndex = -1;
			for (i$2 = byteOffset; i$2 < arrLength; i$2++) if (read(arr, i$2) === read(val, foundIndex === -1 ? 0 : i$2 - foundIndex)) {
				if (foundIndex === -1 && (foundIndex = i$2), i$2 - foundIndex + 1 === valLength) return foundIndex * indexSize;
			} else foundIndex !== -1 && (i$2 -= i$2 - foundIndex), foundIndex = -1;
		} else for (byteOffset + valLength > arrLength && (byteOffset = arrLength - valLength), i$2 = byteOffset; i$2 >= 0; i$2--) {
			let found = !0;
			for (let j = 0; j < valLength; j++) if (read(arr, i$2 + j) !== read(val, j)) {
				found = !1;
				break;
			}
			if (found) return i$2;
		}
		return -1;
	}
	Buffer$2.prototype.includes = function(val, byteOffset, encoding) {
		return this.indexOf(val, byteOffset, encoding) !== -1;
	}, Buffer$2.prototype.indexOf = function(val, byteOffset, encoding) {
		return bidirectionalIndexOf(this, val, byteOffset, encoding, !0);
	}, Buffer$2.prototype.lastIndexOf = function(val, byteOffset, encoding) {
		return bidirectionalIndexOf(this, val, byteOffset, encoding, !1);
	};
	function hexWrite(buf, string$2, offset, length) {
		offset = Number(offset) || 0;
		let remaining = buf.length - offset;
		length ? (length = Number(length), length > remaining && (length = remaining)) : length = remaining;
		let strLen = string$2.length;
		length > strLen / 2 && (length = strLen / 2);
		let i$2;
		for (i$2 = 0; i$2 < length; ++i$2) {
			let parsed = parseInt(string$2.substr(i$2 * 2, 2), 16);
			if (numberIsNaN(parsed)) return i$2;
			buf[offset + i$2] = parsed;
		}
		return i$2;
	}
	function utf8Write(buf, string$2, offset, length) {
		return blitBuffer(utf8ToBytes(string$2, buf.length - offset), buf, offset, length);
	}
	function asciiWrite(buf, string$2, offset, length) {
		return blitBuffer(asciiToBytes(string$2), buf, offset, length);
	}
	function base64Write(buf, string$2, offset, length) {
		return blitBuffer(base64ToBytes(string$2), buf, offset, length);
	}
	function ucs2Write(buf, string$2, offset, length) {
		return blitBuffer(utf16leToBytes(string$2, buf.length - offset), buf, offset, length);
	}
	Buffer$2.prototype.write = function(string$2, offset, length, encoding) {
		if (offset === void 0) encoding = "utf8", length = this.length, offset = 0;
		else if (length === void 0 && typeof offset == "string") encoding = offset, length = this.length, offset = 0;
		else if (isFinite(offset)) offset >>>= 0, isFinite(length) ? (length >>>= 0, encoding === void 0 && (encoding = "utf8")) : (encoding = length, length = void 0);
		else throw Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
		let remaining = this.length - offset;
		if ((length === void 0 || length > remaining) && (length = remaining), string$2.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw RangeError("Attempt to write outside buffer bounds");
		encoding ||= "utf8";
		let loweredCase = !1;
		for (;;) switch (encoding) {
			case "hex": return hexWrite(this, string$2, offset, length);
			case "utf8":
			case "utf-8": return utf8Write(this, string$2, offset, length);
			case "ascii":
			case "latin1":
			case "binary": return asciiWrite(this, string$2, offset, length);
			case "base64": return base64Write(this, string$2, offset, length);
			case "ucs2":
			case "ucs-2":
			case "utf16le":
			case "utf-16le": return ucs2Write(this, string$2, offset, length);
			default:
				if (loweredCase) throw TypeError("Unknown encoding: " + encoding);
				encoding = ("" + encoding).toLowerCase(), loweredCase = !0;
		}
	}, Buffer$2.prototype.toJSON = function() {
		return {
			type: "Buffer",
			data: Array.prototype.slice.call(this._arr || this, 0)
		};
	};
	function base64Slice(buf, start, end) {
		return start === 0 && end === buf.length ? base64.fromByteArray(buf) : base64.fromByteArray(buf.slice(start, end));
	}
	function utf8Slice(buf, start, end) {
		end = Math.min(buf.length, end);
		let res = [], i$2 = start;
		for (; i$2 < end;) {
			let firstByte = buf[i$2], codePoint = null, bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
			if (i$2 + bytesPerSequence <= end) {
				let secondByte, thirdByte, fourthByte, tempCodePoint;
				switch (bytesPerSequence) {
					case 1:
						firstByte < 128 && (codePoint = firstByte);
						break;
					case 2:
						secondByte = buf[i$2 + 1], (secondByte & 192) == 128 && (tempCodePoint = (firstByte & 31) << 6 | secondByte & 63, tempCodePoint > 127 && (codePoint = tempCodePoint));
						break;
					case 3:
						secondByte = buf[i$2 + 1], thirdByte = buf[i$2 + 2], (secondByte & 192) == 128 && (thirdByte & 192) == 128 && (tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63, tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343) && (codePoint = tempCodePoint));
						break;
					case 4: secondByte = buf[i$2 + 1], thirdByte = buf[i$2 + 2], fourthByte = buf[i$2 + 3], (secondByte & 192) == 128 && (thirdByte & 192) == 128 && (fourthByte & 192) == 128 && (tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63, tempCodePoint > 65535 && tempCodePoint < 1114112 && (codePoint = tempCodePoint));
				}
			}
			codePoint === null ? (codePoint = 65533, bytesPerSequence = 1) : codePoint > 65535 && (codePoint -= 65536, res.push(codePoint >>> 10 & 1023 | 55296), codePoint = 56320 | codePoint & 1023), res.push(codePoint), i$2 += bytesPerSequence;
		}
		return decodeCodePointsArray(res);
	}
	var MAX_ARGUMENTS_LENGTH = 4096;
	function decodeCodePointsArray(codePoints) {
		let len$1 = codePoints.length;
		if (len$1 <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints);
		let res = "", i$2 = 0;
		for (; i$2 < len$1;) res += String.fromCharCode.apply(String, codePoints.slice(i$2, i$2 += MAX_ARGUMENTS_LENGTH));
		return res;
	}
	function asciiSlice(buf, start, end) {
		let ret = "";
		end = Math.min(buf.length, end);
		for (let i$2 = start; i$2 < end; ++i$2) ret += String.fromCharCode(buf[i$2] & 127);
		return ret;
	}
	function latin1Slice(buf, start, end) {
		let ret = "";
		end = Math.min(buf.length, end);
		for (let i$2 = start; i$2 < end; ++i$2) ret += String.fromCharCode(buf[i$2]);
		return ret;
	}
	function hexSlice(buf, start, end) {
		let len$1 = buf.length;
		(!start || start < 0) && (start = 0), (!end || end < 0 || end > len$1) && (end = len$1);
		let out = "";
		for (let i$2 = start; i$2 < end; ++i$2) out += hexSliceLookupTable[buf[i$2]];
		return out;
	}
	function utf16leSlice(buf, start, end) {
		let bytes = buf.slice(start, end), res = "";
		for (let i$2 = 0; i$2 < bytes.length - 1; i$2 += 2) res += String.fromCharCode(bytes[i$2] + bytes[i$2 + 1] * 256);
		return res;
	}
	Buffer$2.prototype.slice = function(start, end) {
		let len$1 = this.length;
		start = ~~start, end = end === void 0 ? len$1 : ~~end, start < 0 ? (start += len$1, start < 0 && (start = 0)) : start > len$1 && (start = len$1), end < 0 ? (end += len$1, end < 0 && (end = 0)) : end > len$1 && (end = len$1), end < start && (end = start);
		let newBuf = this.subarray(start, end);
		return Object.setPrototypeOf(newBuf, Buffer$2.prototype), newBuf;
	};
	function checkOffset(offset, ext, length) {
		if (offset % 1 != 0 || offset < 0) throw RangeError("offset is not uint");
		if (offset + ext > length) throw RangeError("Trying to access beyond buffer length");
	}
	Buffer$2.prototype.readUintLE = Buffer$2.prototype.readUIntLE = function(offset, byteLength$2, noAssert) {
		offset >>>= 0, byteLength$2 >>>= 0, noAssert || checkOffset(offset, byteLength$2, this.length);
		let val = this[offset], mul = 1, i$2 = 0;
		for (; ++i$2 < byteLength$2 && (mul *= 256);) val += this[offset + i$2] * mul;
		return val;
	}, Buffer$2.prototype.readUintBE = Buffer$2.prototype.readUIntBE = function(offset, byteLength$2, noAssert) {
		offset >>>= 0, byteLength$2 >>>= 0, noAssert || checkOffset(offset, byteLength$2, this.length);
		let val = this[offset + --byteLength$2], mul = 1;
		for (; byteLength$2 > 0 && (mul *= 256);) val += this[offset + --byteLength$2] * mul;
		return val;
	}, Buffer$2.prototype.readUint8 = Buffer$2.prototype.readUInt8 = function(offset, noAssert) {
		return offset >>>= 0, noAssert || checkOffset(offset, 1, this.length), this[offset];
	}, Buffer$2.prototype.readUint16LE = Buffer$2.prototype.readUInt16LE = function(offset, noAssert) {
		return offset >>>= 0, noAssert || checkOffset(offset, 2, this.length), this[offset] | this[offset + 1] << 8;
	}, Buffer$2.prototype.readUint16BE = Buffer$2.prototype.readUInt16BE = function(offset, noAssert) {
		return offset >>>= 0, noAssert || checkOffset(offset, 2, this.length), this[offset] << 8 | this[offset + 1];
	}, Buffer$2.prototype.readUint32LE = Buffer$2.prototype.readUInt32LE = function(offset, noAssert) {
		return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
	}, Buffer$2.prototype.readUint32BE = Buffer$2.prototype.readUInt32BE = function(offset, noAssert) {
		return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
	}, Buffer$2.prototype.readBigUInt64LE = defineBigIntMethod(function(offset) {
		offset >>>= 0, validateNumber(offset, "offset");
		let first = this[offset], last = this[offset + 7];
		(first === void 0 || last === void 0) && boundsError(offset, this.length - 8);
		let lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24, hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
		return BigInt(lo) + (BigInt(hi) << BigInt(32));
	}), Buffer$2.prototype.readBigUInt64BE = defineBigIntMethod(function(offset) {
		offset >>>= 0, validateNumber(offset, "offset");
		let first = this[offset], last = this[offset + 7];
		(first === void 0 || last === void 0) && boundsError(offset, this.length - 8);
		let hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset], lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
		return (BigInt(hi) << BigInt(32)) + BigInt(lo);
	}), Buffer$2.prototype.readIntLE = function(offset, byteLength$2, noAssert) {
		offset >>>= 0, byteLength$2 >>>= 0, noAssert || checkOffset(offset, byteLength$2, this.length);
		let val = this[offset], mul = 1, i$2 = 0;
		for (; ++i$2 < byteLength$2 && (mul *= 256);) val += this[offset + i$2] * mul;
		return mul *= 128, val >= mul && (val -= 2 ** (8 * byteLength$2)), val;
	}, Buffer$2.prototype.readIntBE = function(offset, byteLength$2, noAssert) {
		offset >>>= 0, byteLength$2 >>>= 0, noAssert || checkOffset(offset, byteLength$2, this.length);
		let i$2 = byteLength$2, mul = 1, val = this[offset + --i$2];
		for (; i$2 > 0 && (mul *= 256);) val += this[offset + --i$2] * mul;
		return mul *= 128, val >= mul && (val -= 2 ** (8 * byteLength$2)), val;
	}, Buffer$2.prototype.readInt8 = function(offset, noAssert) {
		return offset >>>= 0, noAssert || checkOffset(offset, 1, this.length), this[offset] & 128 ? (255 - this[offset] + 1) * -1 : this[offset];
	}, Buffer$2.prototype.readInt16LE = function(offset, noAssert) {
		offset >>>= 0, noAssert || checkOffset(offset, 2, this.length);
		let val = this[offset] | this[offset + 1] << 8;
		return val & 32768 ? val | 4294901760 : val;
	}, Buffer$2.prototype.readInt16BE = function(offset, noAssert) {
		offset >>>= 0, noAssert || checkOffset(offset, 2, this.length);
		let val = this[offset + 1] | this[offset] << 8;
		return val & 32768 ? val | 4294901760 : val;
	}, Buffer$2.prototype.readInt32LE = function(offset, noAssert) {
		return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
	}, Buffer$2.prototype.readInt32BE = function(offset, noAssert) {
		return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
	}, Buffer$2.prototype.readBigInt64LE = defineBigIntMethod(function(offset) {
		offset >>>= 0, validateNumber(offset, "offset");
		let first = this[offset], last = this[offset + 7];
		(first === void 0 || last === void 0) && boundsError(offset, this.length - 8);
		let val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
		return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
	}), Buffer$2.prototype.readBigInt64BE = defineBigIntMethod(function(offset) {
		offset >>>= 0, validateNumber(offset, "offset");
		let first = this[offset], last = this[offset + 7];
		(first === void 0 || last === void 0) && boundsError(offset, this.length - 8);
		let val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
		return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
	}), Buffer$2.prototype.readFloatLE = function(offset, noAssert) {
		return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), ieee754.read(this, offset, !0, 23, 4);
	}, Buffer$2.prototype.readFloatBE = function(offset, noAssert) {
		return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), ieee754.read(this, offset, !1, 23, 4);
	}, Buffer$2.prototype.readDoubleLE = function(offset, noAssert) {
		return offset >>>= 0, noAssert || checkOffset(offset, 8, this.length), ieee754.read(this, offset, !0, 52, 8);
	}, Buffer$2.prototype.readDoubleBE = function(offset, noAssert) {
		return offset >>>= 0, noAssert || checkOffset(offset, 8, this.length), ieee754.read(this, offset, !1, 52, 8);
	};
	function checkInt(buf, value, offset, ext, max, min) {
		if (!Buffer$2.isBuffer(buf)) throw TypeError("\"buffer\" argument must be a Buffer instance");
		if (value > max || value < min) throw RangeError("\"value\" argument is out of bounds");
		if (offset + ext > buf.length) throw RangeError("Index out of range");
	}
	Buffer$2.prototype.writeUintLE = Buffer$2.prototype.writeUIntLE = function(value, offset, byteLength$2, noAssert) {
		if (value = +value, offset >>>= 0, byteLength$2 >>>= 0, !noAssert) {
			let maxBytes = 2 ** (8 * byteLength$2) - 1;
			checkInt(this, value, offset, byteLength$2, maxBytes, 0);
		}
		let mul = 1, i$2 = 0;
		for (this[offset] = value & 255; ++i$2 < byteLength$2 && (mul *= 256);) this[offset + i$2] = value / mul & 255;
		return offset + byteLength$2;
	}, Buffer$2.prototype.writeUintBE = Buffer$2.prototype.writeUIntBE = function(value, offset, byteLength$2, noAssert) {
		if (value = +value, offset >>>= 0, byteLength$2 >>>= 0, !noAssert) {
			let maxBytes = 2 ** (8 * byteLength$2) - 1;
			checkInt(this, value, offset, byteLength$2, maxBytes, 0);
		}
		let i$2 = byteLength$2 - 1, mul = 1;
		for (this[offset + i$2] = value & 255; --i$2 >= 0 && (mul *= 256);) this[offset + i$2] = value / mul & 255;
		return offset + byteLength$2;
	}, Buffer$2.prototype.writeUint8 = Buffer$2.prototype.writeUInt8 = function(value, offset, noAssert) {
		return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 1, 255, 0), this[offset] = value & 255, offset + 1;
	}, Buffer$2.prototype.writeUint16LE = Buffer$2.prototype.writeUInt16LE = function(value, offset, noAssert) {
		return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 2, 65535, 0), this[offset] = value & 255, this[offset + 1] = value >>> 8, offset + 2;
	}, Buffer$2.prototype.writeUint16BE = Buffer$2.prototype.writeUInt16BE = function(value, offset, noAssert) {
		return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 2, 65535, 0), this[offset] = value >>> 8, this[offset + 1] = value & 255, offset + 2;
	}, Buffer$2.prototype.writeUint32LE = Buffer$2.prototype.writeUInt32LE = function(value, offset, noAssert) {
		return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 4, 4294967295, 0), this[offset + 3] = value >>> 24, this[offset + 2] = value >>> 16, this[offset + 1] = value >>> 8, this[offset] = value & 255, offset + 4;
	}, Buffer$2.prototype.writeUint32BE = Buffer$2.prototype.writeUInt32BE = function(value, offset, noAssert) {
		return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 4, 4294967295, 0), this[offset] = value >>> 24, this[offset + 1] = value >>> 16, this[offset + 2] = value >>> 8, this[offset + 3] = value & 255, offset + 4;
	};
	function wrtBigUInt64LE(buf, value, offset, min, max) {
		checkIntBI(value, min, max, buf, offset, 7);
		let lo = Number(value & BigInt(4294967295));
		buf[offset++] = lo, lo >>= 8, buf[offset++] = lo, lo >>= 8, buf[offset++] = lo, lo >>= 8, buf[offset++] = lo;
		let hi = Number(value >> BigInt(32) & BigInt(4294967295));
		return buf[offset++] = hi, hi >>= 8, buf[offset++] = hi, hi >>= 8, buf[offset++] = hi, hi >>= 8, buf[offset++] = hi, offset;
	}
	function wrtBigUInt64BE(buf, value, offset, min, max) {
		checkIntBI(value, min, max, buf, offset, 7);
		let lo = Number(value & BigInt(4294967295));
		buf[offset + 7] = lo, lo >>= 8, buf[offset + 6] = lo, lo >>= 8, buf[offset + 5] = lo, lo >>= 8, buf[offset + 4] = lo;
		let hi = Number(value >> BigInt(32) & BigInt(4294967295));
		return buf[offset + 3] = hi, hi >>= 8, buf[offset + 2] = hi, hi >>= 8, buf[offset + 1] = hi, hi >>= 8, buf[offset] = hi, offset + 8;
	}
	Buffer$2.prototype.writeBigUInt64LE = defineBigIntMethod(function(value, offset = 0) {
		return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
	}), Buffer$2.prototype.writeBigUInt64BE = defineBigIntMethod(function(value, offset = 0) {
		return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
	}), Buffer$2.prototype.writeIntLE = function(value, offset, byteLength$2, noAssert) {
		if (value = +value, offset >>>= 0, !noAssert) {
			let limit = 2 ** (8 * byteLength$2 - 1);
			checkInt(this, value, offset, byteLength$2, limit - 1, -limit);
		}
		let i$2 = 0, mul = 1, sub = 0;
		for (this[offset] = value & 255; ++i$2 < byteLength$2 && (mul *= 256);) value < 0 && sub === 0 && this[offset + i$2 - 1] !== 0 && (sub = 1), this[offset + i$2] = (value / mul >> 0) - sub & 255;
		return offset + byteLength$2;
	}, Buffer$2.prototype.writeIntBE = function(value, offset, byteLength$2, noAssert) {
		if (value = +value, offset >>>= 0, !noAssert) {
			let limit = 2 ** (8 * byteLength$2 - 1);
			checkInt(this, value, offset, byteLength$2, limit - 1, -limit);
		}
		let i$2 = byteLength$2 - 1, mul = 1, sub = 0;
		for (this[offset + i$2] = value & 255; --i$2 >= 0 && (mul *= 256);) value < 0 && sub === 0 && this[offset + i$2 + 1] !== 0 && (sub = 1), this[offset + i$2] = (value / mul >> 0) - sub & 255;
		return offset + byteLength$2;
	}, Buffer$2.prototype.writeInt8 = function(value, offset, noAssert) {
		return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 1, 127, -128), value < 0 && (value = 255 + value + 1), this[offset] = value & 255, offset + 1;
	}, Buffer$2.prototype.writeInt16LE = function(value, offset, noAssert) {
		return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 2, 32767, -32768), this[offset] = value & 255, this[offset + 1] = value >>> 8, offset + 2;
	}, Buffer$2.prototype.writeInt16BE = function(value, offset, noAssert) {
		return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 2, 32767, -32768), this[offset] = value >>> 8, this[offset + 1] = value & 255, offset + 2;
	}, Buffer$2.prototype.writeInt32LE = function(value, offset, noAssert) {
		return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 4, 2147483647, -2147483648), this[offset] = value & 255, this[offset + 1] = value >>> 8, this[offset + 2] = value >>> 16, this[offset + 3] = value >>> 24, offset + 4;
	}, Buffer$2.prototype.writeInt32BE = function(value, offset, noAssert) {
		return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 4, 2147483647, -2147483648), value < 0 && (value = 4294967295 + value + 1), this[offset] = value >>> 24, this[offset + 1] = value >>> 16, this[offset + 2] = value >>> 8, this[offset + 3] = value & 255, offset + 4;
	}, Buffer$2.prototype.writeBigInt64LE = defineBigIntMethod(function(value, offset = 0) {
		return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
	}), Buffer$2.prototype.writeBigInt64BE = defineBigIntMethod(function(value, offset = 0) {
		return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
	});
	function checkIEEE754(buf, value, offset, ext, max, min) {
		if (offset + ext > buf.length || offset < 0) throw RangeError("Index out of range");
	}
	function writeFloat(buf, value, offset, littleEndian, noAssert) {
		return value = +value, offset >>>= 0, noAssert || checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22), ieee754.write(buf, value, offset, littleEndian, 23, 4), offset + 4;
	}
	Buffer$2.prototype.writeFloatLE = function(value, offset, noAssert) {
		return writeFloat(this, value, offset, !0, noAssert);
	}, Buffer$2.prototype.writeFloatBE = function(value, offset, noAssert) {
		return writeFloat(this, value, offset, !1, noAssert);
	};
	function writeDouble(buf, value, offset, littleEndian, noAssert) {
		return value = +value, offset >>>= 0, noAssert || checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292), ieee754.write(buf, value, offset, littleEndian, 52, 8), offset + 8;
	}
	Buffer$2.prototype.writeDoubleLE = function(value, offset, noAssert) {
		return writeDouble(this, value, offset, !0, noAssert);
	}, Buffer$2.prototype.writeDoubleBE = function(value, offset, noAssert) {
		return writeDouble(this, value, offset, !1, noAssert);
	}, Buffer$2.prototype.copy = function(target, targetStart, start, end) {
		if (!Buffer$2.isBuffer(target)) throw TypeError("argument should be a Buffer");
		if (start ||= 0, !end && end !== 0 && (end = this.length), targetStart >= target.length && (targetStart = target.length), targetStart ||= 0, end > 0 && end < start && (end = start), end === start || target.length === 0 || this.length === 0) return 0;
		if (targetStart < 0) throw RangeError("targetStart out of bounds");
		if (start < 0 || start >= this.length) throw RangeError("Index out of range");
		if (end < 0) throw RangeError("sourceEnd out of bounds");
		end > this.length && (end = this.length), target.length - targetStart < end - start && (end = target.length - targetStart + start);
		let len$1 = end - start;
		return this === target && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(targetStart, start, end) : Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart), len$1;
	}, Buffer$2.prototype.fill = function(val, start, end, encoding) {
		if (typeof val == "string") {
			if (typeof start == "string" ? (encoding = start, start = 0, end = this.length) : typeof end == "string" && (encoding = end, end = this.length), encoding !== void 0 && typeof encoding != "string") throw TypeError("encoding must be a string");
			if (typeof encoding == "string" && !Buffer$2.isEncoding(encoding)) throw TypeError("Unknown encoding: " + encoding);
			if (val.length === 1) {
				let code$4 = val.charCodeAt(0);
				(encoding === "utf8" && code$4 < 128 || encoding === "latin1") && (val = code$4);
			}
		} else typeof val == "number" ? val &= 255 : typeof val == "boolean" && (val = Number(val));
		if (start < 0 || this.length < start || this.length < end) throw RangeError("Out of range index");
		if (end <= start) return this;
		start >>>= 0, end = end === void 0 ? this.length : end >>> 0, val ||= 0;
		let i$2;
		if (typeof val == "number") for (i$2 = start; i$2 < end; ++i$2) this[i$2] = val;
		else {
			let bytes = Buffer$2.isBuffer(val) ? val : Buffer$2.from(val, encoding), len$1 = bytes.length;
			if (len$1 === 0) throw TypeError("The value \"" + val + "\" is invalid for argument \"value\"");
			for (i$2 = 0; i$2 < end - start; ++i$2) this[i$2 + start] = bytes[i$2 % len$1];
		}
		return this;
	};
	var errors = {};
	function E(sym, getMessage, Base) {
		errors[sym] = class extends Base {
			constructor() {
				super(), Object.defineProperty(this, "message", {
					value: getMessage.apply(this, arguments),
					writable: !0,
					configurable: !0
				}), this.name = `${this.name} [${sym}]`, this.stack, delete this.name;
			}
			get code() {
				return sym;
			}
			set code(value) {
				Object.defineProperty(this, "code", {
					configurable: !0,
					enumerable: !0,
					value,
					writable: !0
				});
			}
			toString() {
				return `${this.name} [${sym}]: ${this.message}`;
			}
		};
	}
	E("ERR_BUFFER_OUT_OF_BOUNDS", function(name$1) {
		return name$1 ? `${name$1} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
	}, RangeError), E("ERR_INVALID_ARG_TYPE", function(name$1, actual) {
		return `The "${name$1}" argument must be of type number. Received type ${typeof actual}`;
	}, TypeError), E("ERR_OUT_OF_RANGE", function(str, range, input) {
		let msg = `The value of "${str}" is out of range.`, received = input;
		return Number.isInteger(input) && Math.abs(input) > 2 ** 32 ? received = addNumericalSeparator(String(input)) : typeof input == "bigint" && (received = String(input), (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) && (received = addNumericalSeparator(received)), received += "n"), msg += ` It must be ${range}. Received ${received}`, msg;
	}, RangeError);
	function addNumericalSeparator(val) {
		let res = "", i$2 = val.length, start = val[0] === "-" ? 1 : 0;
		for (; i$2 >= start + 4; i$2 -= 3) res = `_${val.slice(i$2 - 3, i$2)}${res}`;
		return `${val.slice(0, i$2)}${res}`;
	}
	function checkBounds(buf, offset, byteLength$2) {
		validateNumber(offset, "offset"), (buf[offset] === void 0 || buf[offset + byteLength$2] === void 0) && boundsError(offset, buf.length - (byteLength$2 + 1));
	}
	function checkIntBI(value, min, max, buf, offset, byteLength$2) {
		if (value > max || value < min) {
			let n = typeof min == "bigint" ? "n" : "", range;
			throw range = byteLength$2 > 3 ? min === 0 || min === BigInt(0) ? `>= 0${n} and < 2${n} ** ${(byteLength$2 + 1) * 8}${n}` : `>= -(2${n} ** ${(byteLength$2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength$2 + 1) * 8 - 1}${n}` : `>= ${min}${n} and <= ${max}${n}`, new errors.ERR_OUT_OF_RANGE("value", range, value);
		}
		checkBounds(buf, offset, byteLength$2);
	}
	function validateNumber(value, name$1) {
		if (typeof value != "number") throw new errors.ERR_INVALID_ARG_TYPE(name$1, "number", value);
	}
	function boundsError(value, length, type) {
		throw Math.floor(value) === value ? length < 0 ? new errors.ERR_BUFFER_OUT_OF_BOUNDS() : new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value) : (validateNumber(value, type), new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value));
	}
	var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
	function base64clean(str) {
		if (str = str.split("=")[0], str = str.trim().replace(INVALID_BASE64_RE, ""), str.length < 2) return "";
		for (; str.length % 4 != 0;) str += "=";
		return str;
	}
	function utf8ToBytes(string$2, units) {
		units ||= Infinity;
		let codePoint, length = string$2.length, leadSurrogate = null, bytes = [];
		for (let i$2 = 0; i$2 < length; ++i$2) {
			if (codePoint = string$2.charCodeAt(i$2), codePoint > 55295 && codePoint < 57344) {
				if (!leadSurrogate) {
					if (codePoint > 56319) {
						(units -= 3) > -1 && bytes.push(239, 191, 189);
						continue;
					} else if (i$2 + 1 === length) {
						(units -= 3) > -1 && bytes.push(239, 191, 189);
						continue;
					}
					leadSurrogate = codePoint;
					continue;
				}
				if (codePoint < 56320) {
					(units -= 3) > -1 && bytes.push(239, 191, 189), leadSurrogate = codePoint;
					continue;
				}
				codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
			} else leadSurrogate && (units -= 3) > -1 && bytes.push(239, 191, 189);
			if (leadSurrogate = null, codePoint < 128) {
				if (--units < 0) break;
				bytes.push(codePoint);
			} else if (codePoint < 2048) {
				if ((units -= 2) < 0) break;
				bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
			} else if (codePoint < 65536) {
				if ((units -= 3) < 0) break;
				bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
			} else if (codePoint < 1114112) {
				if ((units -= 4) < 0) break;
				bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
			} else throw Error("Invalid code point");
		}
		return bytes;
	}
	function asciiToBytes(str) {
		let byteArray = [];
		for (let i$2 = 0; i$2 < str.length; ++i$2) byteArray.push(str.charCodeAt(i$2) & 255);
		return byteArray;
	}
	function utf16leToBytes(str, units) {
		let c$1, hi, lo, byteArray = [];
		for (let i$2 = 0; i$2 < str.length && !((units -= 2) < 0); ++i$2) c$1 = str.charCodeAt(i$2), hi = c$1 >> 8, lo = c$1 % 256, byteArray.push(lo), byteArray.push(hi);
		return byteArray;
	}
	function base64ToBytes(str) {
		return base64.toByteArray(base64clean(str));
	}
	function blitBuffer(src, dst, offset, length) {
		let i$2;
		for (i$2 = 0; i$2 < length && !(i$2 + offset >= dst.length || i$2 >= src.length); ++i$2) dst[i$2 + offset] = src[i$2];
		return i$2;
	}
	function isInstance(obj, type) {
		return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
	}
	function numberIsNaN(obj) {
		return obj !== obj;
	}
	var hexSliceLookupTable = (function() {
		let alphabet = "0123456789abcdef", table$1 = Array(256);
		for (let i$2 = 0; i$2 < 16; ++i$2) {
			let i16 = i$2 * 16;
			for (let j = 0; j < 16; ++j) table$1[i16 + j] = alphabet[i$2] + alphabet[j];
		}
		return table$1;
	})();
	function defineBigIntMethod(fn) {
		return typeof BigInt > "u" ? BufferBigIntNotDefined : fn;
	}
	function BufferBigIntNotDefined() {
		throw Error("BigInt not supported");
	}
})), require_binary = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var NodeBuffer;
	try {
		NodeBuffer = require_buffer().Buffer;
	} catch {}
	var Type$6 = require_type(), BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
	function resolveYamlBinary(data) {
		if (data === null) return !1;
		var code$4, idx, bitlen = 0, max = data.length, map$2 = BASE64_MAP;
		for (idx = 0; idx < max; idx++) if (code$4 = map$2.indexOf(data.charAt(idx)), !(code$4 > 64)) {
			if (code$4 < 0) return !1;
			bitlen += 6;
		}
		return bitlen % 8 == 0;
	}
	function constructYamlBinary(data) {
		var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map$2 = BASE64_MAP, bits = 0, result = [];
		for (idx = 0; idx < max; idx++) idx % 4 == 0 && idx && (result.push(bits >> 16 & 255), result.push(bits >> 8 & 255), result.push(bits & 255)), bits = bits << 6 | map$2.indexOf(input.charAt(idx));
		return tailbits = max % 4 * 6, tailbits === 0 ? (result.push(bits >> 16 & 255), result.push(bits >> 8 & 255), result.push(bits & 255)) : tailbits === 18 ? (result.push(bits >> 10 & 255), result.push(bits >> 2 & 255)) : tailbits === 12 && result.push(bits >> 4 & 255), NodeBuffer ? NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result) : result;
	}
	function representYamlBinary(object) {
		var result = "", bits = 0, idx, tail, max = object.length, map$2 = BASE64_MAP;
		for (idx = 0; idx < max; idx++) idx % 3 == 0 && idx && (result += map$2[bits >> 18 & 63], result += map$2[bits >> 12 & 63], result += map$2[bits >> 6 & 63], result += map$2[bits & 63]), bits = (bits << 8) + object[idx];
		return tail = max % 3, tail === 0 ? (result += map$2[bits >> 18 & 63], result += map$2[bits >> 12 & 63], result += map$2[bits >> 6 & 63], result += map$2[bits & 63]) : tail === 2 ? (result += map$2[bits >> 10 & 63], result += map$2[bits >> 4 & 63], result += map$2[bits << 2 & 63], result += map$2[64]) : tail === 1 && (result += map$2[bits >> 2 & 63], result += map$2[bits << 4 & 63], result += map$2[64], result += map$2[64]), result;
	}
	function isBinary(object) {
		return NodeBuffer && NodeBuffer.isBuffer(object);
	}
	module.exports = new Type$6("tag:yaml.org,2002:binary", {
		kind: "scalar",
		resolve: resolveYamlBinary,
		construct: constructYamlBinary,
		predicate: isBinary,
		represent: representYamlBinary
	});
})), require_omap = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Type$5 = require_type(), _hasOwnProperty$3 = Object.prototype.hasOwnProperty, _toString$2 = Object.prototype.toString;
	function resolveYamlOmap(data) {
		if (data === null) return !0;
		var objectKeys = [], index$2, length, pair, pairKey, pairHasKey, object = data;
		for (index$2 = 0, length = object.length; index$2 < length; index$2 += 1) {
			if (pair = object[index$2], pairHasKey = !1, _toString$2.call(pair) !== "[object Object]") return !1;
			for (pairKey in pair) if (_hasOwnProperty$3.call(pair, pairKey)) if (!pairHasKey) pairHasKey = !0;
			else return !1;
			if (!pairHasKey) return !1;
			if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
			else return !1;
		}
		return !0;
	}
	function constructYamlOmap(data) {
		return data === null ? [] : data;
	}
	module.exports = new Type$5("tag:yaml.org,2002:omap", {
		kind: "sequence",
		resolve: resolveYamlOmap,
		construct: constructYamlOmap
	});
})), require_pairs = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Type$4 = require_type(), _toString$1 = Object.prototype.toString;
	function resolveYamlPairs(data) {
		if (data === null) return !0;
		var index$2, length, pair, keys$1, result, object = data;
		for (result = Array(object.length), index$2 = 0, length = object.length; index$2 < length; index$2 += 1) {
			if (pair = object[index$2], _toString$1.call(pair) !== "[object Object]" || (keys$1 = Object.keys(pair), keys$1.length !== 1)) return !1;
			result[index$2] = [keys$1[0], pair[keys$1[0]]];
		}
		return !0;
	}
	function constructYamlPairs(data) {
		if (data === null) return [];
		var index$2, length, pair, keys$1, result, object = data;
		for (result = Array(object.length), index$2 = 0, length = object.length; index$2 < length; index$2 += 1) pair = object[index$2], keys$1 = Object.keys(pair), result[index$2] = [keys$1[0], pair[keys$1[0]]];
		return result;
	}
	module.exports = new Type$4("tag:yaml.org,2002:pairs", {
		kind: "sequence",
		resolve: resolveYamlPairs,
		construct: constructYamlPairs
	});
})), require_set = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Type$3 = require_type(), _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
	function resolveYamlSet(data) {
		if (data === null) return !0;
		var key, object = data;
		for (key in object) if (_hasOwnProperty$2.call(object, key) && object[key] !== null) return !1;
		return !0;
	}
	function constructYamlSet(data) {
		return data === null ? {} : data;
	}
	module.exports = new Type$3("tag:yaml.org,2002:set", {
		kind: "mapping",
		resolve: resolveYamlSet,
		construct: constructYamlSet
	});
})), require_default_safe = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = new (require_schema())({
		include: [require_core()],
		implicit: [require_timestamp(), require_merge()],
		explicit: [
			require_binary(),
			require_omap(),
			require_pairs(),
			require_set()
		]
	});
})), require_undefined = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Type$2 = require_type();
	function resolveJavascriptUndefined() {
		return !0;
	}
	function constructJavascriptUndefined() {}
	function representJavascriptUndefined() {
		return "";
	}
	function isUndefined(object) {
		return object === void 0;
	}
	module.exports = new Type$2("tag:yaml.org,2002:js/undefined", {
		kind: "scalar",
		resolve: resolveJavascriptUndefined,
		construct: constructJavascriptUndefined,
		predicate: isUndefined,
		represent: representJavascriptUndefined
	});
})), require_regexp = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Type$1 = require_type();
	function resolveJavascriptRegExp(data) {
		if (data === null || data.length === 0) return !1;
		var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
		return !(regexp[0] === "/" && (tail && (modifiers = tail[1]), modifiers.length > 3 || regexp[regexp.length - modifiers.length - 1] !== "/"));
	}
	function constructJavascriptRegExp(data) {
		var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
		return regexp[0] === "/" && (tail && (modifiers = tail[1]), regexp = regexp.slice(1, regexp.length - modifiers.length - 1)), new RegExp(regexp, modifiers);
	}
	function representJavascriptRegExp(object) {
		var result = "/" + object.source + "/";
		return object.global && (result += "g"), object.multiline && (result += "m"), object.ignoreCase && (result += "i"), result;
	}
	function isRegExp(object) {
		return Object.prototype.toString.call(object) === "[object RegExp]";
	}
	module.exports = new Type$1("tag:yaml.org,2002:js/regexp", {
		kind: "scalar",
		resolve: resolveJavascriptRegExp,
		construct: constructJavascriptRegExp,
		predicate: isRegExp,
		represent: representJavascriptRegExp
	});
})), require_esprima = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function(root$3, factory) {
		/* istanbul ignore next */
		typeof exports == "object" && typeof module == "object" ? module.exports = factory() : typeof define == "function" && define.amd ? define([], factory) : typeof exports == "object" ? exports.esprima = factory() : root$3.esprima = factory();
	})(exports, function() {
		return (function(modules) {
			var installedModules = {};
			function __webpack_require__(moduleId) {
				/* istanbul ignore if */
				if (installedModules[moduleId]) return installedModules[moduleId].exports;
				var module$1 = installedModules[moduleId] = {
					exports: {},
					id: moduleId,
					loaded: !1
				};
				return modules[moduleId].call(module$1.exports, module$1, module$1.exports, __webpack_require__), module$1.loaded = !0, module$1.exports;
			}
			return __webpack_require__.m = modules, __webpack_require__.c = installedModules, __webpack_require__.p = "", __webpack_require__(0);
		})([
			function(module$1, exports$1, __webpack_require__) {
				Object.defineProperty(exports$1, "__esModule", { value: !0 });
				var comment_handler_1 = __webpack_require__(1), jsx_parser_1 = __webpack_require__(3), parser_1 = __webpack_require__(8), tokenizer_1 = __webpack_require__(15);
				function parse$2(code$4, options, delegate) {
					var commentHandler = null, proxyDelegate = function(node$1, metadata) {
						delegate && delegate(node$1, metadata), commentHandler && commentHandler.visit(node$1, metadata);
					}, parserDelegate = typeof delegate == "function" ? proxyDelegate : null, collectComment = !1;
					if (options) {
						collectComment = typeof options.comment == "boolean" && options.comment;
						var attachComment = typeof options.attachComment == "boolean" && options.attachComment;
						(collectComment || attachComment) && (commentHandler = new comment_handler_1.CommentHandler(), commentHandler.attach = attachComment, options.comment = !0, parserDelegate = proxyDelegate);
					}
					var isModule = !1;
					options && typeof options.sourceType == "string" && (isModule = options.sourceType === "module");
					var parser = options && typeof options.jsx == "boolean" && options.jsx ? new jsx_parser_1.JSXParser(code$4, options, parserDelegate) : new parser_1.Parser(code$4, options, parserDelegate), ast = isModule ? parser.parseModule() : parser.parseScript();
					return collectComment && commentHandler && (ast.comments = commentHandler.comments), parser.config.tokens && (ast.tokens = parser.tokens), parser.config.tolerant && (ast.errors = parser.errorHandler.errors), ast;
				}
				exports$1.parse = parse$2;
				function parseModule(code$4, options, delegate) {
					var parsingOptions = options || {};
					return parsingOptions.sourceType = "module", parse$2(code$4, parsingOptions, delegate);
				}
				exports$1.parseModule = parseModule;
				function parseScript(code$4, options, delegate) {
					var parsingOptions = options || {};
					return parsingOptions.sourceType = "script", parse$2(code$4, parsingOptions, delegate);
				}
				exports$1.parseScript = parseScript;
				function tokenize(code$4, options, delegate) {
					var tokenizer = new tokenizer_1.Tokenizer(code$4, options), tokens = [];
					try {
						for (;;) {
							var token = tokenizer.getNextToken();
							if (!token) break;
							delegate && (token = delegate(token)), tokens.push(token);
						}
					} catch (e) {
						tokenizer.errorHandler.tolerate(e);
					}
					return tokenizer.errorHandler.tolerant && (tokens.errors = tokenizer.errors()), tokens;
				}
				exports$1.tokenize = tokenize, exports$1.Syntax = __webpack_require__(2).Syntax, exports$1.version = "4.0.1";
			},
			function(module$1, exports$1, __webpack_require__) {
				Object.defineProperty(exports$1, "__esModule", { value: !0 });
				var syntax_1 = __webpack_require__(2);
				exports$1.CommentHandler = function() {
					function CommentHandler() {
						this.attach = !1, this.comments = [], this.stack = [], this.leading = [], this.trailing = [];
					}
					return CommentHandler.prototype.insertInnerComments = function(node$1, metadata) {
						if (node$1.type === syntax_1.Syntax.BlockStatement && node$1.body.length === 0) {
							for (var innerComments = [], i$2 = this.leading.length - 1; i$2 >= 0; --i$2) {
								var entry = this.leading[i$2];
								metadata.end.offset >= entry.start && (innerComments.unshift(entry.comment), this.leading.splice(i$2, 1), this.trailing.splice(i$2, 1));
							}
							innerComments.length && (node$1.innerComments = innerComments);
						}
					}, CommentHandler.prototype.findTrailingComments = function(metadata) {
						var trailingComments = [];
						if (this.trailing.length > 0) {
							for (var i$2 = this.trailing.length - 1; i$2 >= 0; --i$2) {
								var entry_1 = this.trailing[i$2];
								entry_1.start >= metadata.end.offset && trailingComments.unshift(entry_1.comment);
							}
							return this.trailing.length = 0, trailingComments;
						}
						var entry = this.stack[this.stack.length - 1];
						if (entry && entry.node.trailingComments) {
							var firstComment = entry.node.trailingComments[0];
							firstComment && firstComment.range[0] >= metadata.end.offset && (trailingComments = entry.node.trailingComments, delete entry.node.trailingComments);
						}
						return trailingComments;
					}, CommentHandler.prototype.findLeadingComments = function(metadata) {
						for (var leadingComments = [], target; this.stack.length > 0;) {
							var entry = this.stack[this.stack.length - 1];
							if (entry && entry.start >= metadata.start.offset) target = entry.node, this.stack.pop();
							else break;
						}
						if (target) {
							for (var i$2 = (target.leadingComments ? target.leadingComments.length : 0) - 1; i$2 >= 0; --i$2) {
								var comment = target.leadingComments[i$2];
								comment.range[1] <= metadata.start.offset && (leadingComments.unshift(comment), target.leadingComments.splice(i$2, 1));
							}
							return target.leadingComments && target.leadingComments.length === 0 && delete target.leadingComments, leadingComments;
						}
						for (var i$2 = this.leading.length - 1; i$2 >= 0; --i$2) {
							var entry = this.leading[i$2];
							entry.start <= metadata.start.offset && (leadingComments.unshift(entry.comment), this.leading.splice(i$2, 1));
						}
						return leadingComments;
					}, CommentHandler.prototype.visitNode = function(node$1, metadata) {
						if (!(node$1.type === syntax_1.Syntax.Program && node$1.body.length > 0)) {
							this.insertInnerComments(node$1, metadata);
							var trailingComments = this.findTrailingComments(metadata), leadingComments = this.findLeadingComments(metadata);
							leadingComments.length > 0 && (node$1.leadingComments = leadingComments), trailingComments.length > 0 && (node$1.trailingComments = trailingComments), this.stack.push({
								node: node$1,
								start: metadata.start.offset
							});
						}
					}, CommentHandler.prototype.visitComment = function(node$1, metadata) {
						var type = node$1.type[0] === "L" ? "Line" : "Block", comment = {
							type,
							value: node$1.value
						};
						if (node$1.range && (comment.range = node$1.range), node$1.loc && (comment.loc = node$1.loc), this.comments.push(comment), this.attach) {
							var entry = {
								comment: {
									type,
									value: node$1.value,
									range: [metadata.start.offset, metadata.end.offset]
								},
								start: metadata.start.offset
							};
							node$1.loc && (entry.comment.loc = node$1.loc), node$1.type = type, this.leading.push(entry), this.trailing.push(entry);
						}
					}, CommentHandler.prototype.visit = function(node$1, metadata) {
						node$1.type === "LineComment" || node$1.type === "BlockComment" ? this.visitComment(node$1, metadata) : this.attach && this.visitNode(node$1, metadata);
					}, CommentHandler;
				}();
			},
			function(module$1, exports$1) {
				Object.defineProperty(exports$1, "__esModule", { value: !0 }), exports$1.Syntax = {
					AssignmentExpression: "AssignmentExpression",
					AssignmentPattern: "AssignmentPattern",
					ArrayExpression: "ArrayExpression",
					ArrayPattern: "ArrayPattern",
					ArrowFunctionExpression: "ArrowFunctionExpression",
					AwaitExpression: "AwaitExpression",
					BlockStatement: "BlockStatement",
					BinaryExpression: "BinaryExpression",
					BreakStatement: "BreakStatement",
					CallExpression: "CallExpression",
					CatchClause: "CatchClause",
					ClassBody: "ClassBody",
					ClassDeclaration: "ClassDeclaration",
					ClassExpression: "ClassExpression",
					ConditionalExpression: "ConditionalExpression",
					ContinueStatement: "ContinueStatement",
					DoWhileStatement: "DoWhileStatement",
					DebuggerStatement: "DebuggerStatement",
					EmptyStatement: "EmptyStatement",
					ExportAllDeclaration: "ExportAllDeclaration",
					ExportDefaultDeclaration: "ExportDefaultDeclaration",
					ExportNamedDeclaration: "ExportNamedDeclaration",
					ExportSpecifier: "ExportSpecifier",
					ExpressionStatement: "ExpressionStatement",
					ForStatement: "ForStatement",
					ForOfStatement: "ForOfStatement",
					ForInStatement: "ForInStatement",
					FunctionDeclaration: "FunctionDeclaration",
					FunctionExpression: "FunctionExpression",
					Identifier: "Identifier",
					IfStatement: "IfStatement",
					ImportDeclaration: "ImportDeclaration",
					ImportDefaultSpecifier: "ImportDefaultSpecifier",
					ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
					ImportSpecifier: "ImportSpecifier",
					Literal: "Literal",
					LabeledStatement: "LabeledStatement",
					LogicalExpression: "LogicalExpression",
					MemberExpression: "MemberExpression",
					MetaProperty: "MetaProperty",
					MethodDefinition: "MethodDefinition",
					NewExpression: "NewExpression",
					ObjectExpression: "ObjectExpression",
					ObjectPattern: "ObjectPattern",
					Program: "Program",
					Property: "Property",
					RestElement: "RestElement",
					ReturnStatement: "ReturnStatement",
					SequenceExpression: "SequenceExpression",
					SpreadElement: "SpreadElement",
					Super: "Super",
					SwitchCase: "SwitchCase",
					SwitchStatement: "SwitchStatement",
					TaggedTemplateExpression: "TaggedTemplateExpression",
					TemplateElement: "TemplateElement",
					TemplateLiteral: "TemplateLiteral",
					ThisExpression: "ThisExpression",
					ThrowStatement: "ThrowStatement",
					TryStatement: "TryStatement",
					UnaryExpression: "UnaryExpression",
					UpdateExpression: "UpdateExpression",
					VariableDeclaration: "VariableDeclaration",
					VariableDeclarator: "VariableDeclarator",
					WhileStatement: "WhileStatement",
					WithStatement: "WithStatement",
					YieldExpression: "YieldExpression"
				};
			},
			function(module$1, exports$1, __webpack_require__) {
				/* istanbul ignore next */
				var __extends = this && this.__extends || (function() {
					var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
						d.__proto__ = b;
					} || function(d, b) {
						for (var p$1 in b) b.hasOwnProperty(p$1) && (d[p$1] = b[p$1]);
					};
					return function(d, b) {
						extendStatics(d, b);
						function __() {
							this.constructor = d;
						}
						d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
					};
				})();
				Object.defineProperty(exports$1, "__esModule", { value: !0 });
				var character_1 = __webpack_require__(4), JSXNode = __webpack_require__(5), jsx_syntax_1 = __webpack_require__(6), Node = __webpack_require__(7), parser_1 = __webpack_require__(8), token_1 = __webpack_require__(13), xhtml_entities_1 = __webpack_require__(14);
				token_1.TokenName[100] = "JSXIdentifier", token_1.TokenName[101] = "JSXText";
				function getQualifiedElementName(elementName) {
					var qualifiedName;
					switch (elementName.type) {
						case jsx_syntax_1.JSXSyntax.JSXIdentifier:
							qualifiedName = elementName.name;
							break;
						case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
							var ns = elementName;
							qualifiedName = getQualifiedElementName(ns.namespace) + ":" + getQualifiedElementName(ns.name);
							break;
						case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
							var expr = elementName;
							qualifiedName = getQualifiedElementName(expr.object) + "." + getQualifiedElementName(expr.property);
							break;
						default: break;
					}
					return qualifiedName;
				}
				exports$1.JSXParser = function(_super) {
					__extends(JSXParser, _super);
					function JSXParser(code$4, options, delegate) {
						return _super.call(this, code$4, options, delegate) || this;
					}
					return JSXParser.prototype.parsePrimaryExpression = function() {
						return this.match("<") ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
					}, JSXParser.prototype.startJSX = function() {
						this.scanner.index = this.startMarker.index, this.scanner.lineNumber = this.startMarker.line, this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
					}, JSXParser.prototype.finishJSX = function() {
						this.nextToken();
					}, JSXParser.prototype.reenterJSX = function() {
						this.startJSX(), this.expectJSX("}"), this.config.tokens && this.tokens.pop();
					}, JSXParser.prototype.createJSXNode = function() {
						return this.collectComments(), {
							index: this.scanner.index,
							line: this.scanner.lineNumber,
							column: this.scanner.index - this.scanner.lineStart
						};
					}, JSXParser.prototype.createJSXChildNode = function() {
						return {
							index: this.scanner.index,
							line: this.scanner.lineNumber,
							column: this.scanner.index - this.scanner.lineStart
						};
					}, JSXParser.prototype.scanXHTMLEntity = function(quote) {
						for (var result = "&", valid$1 = !0, terminated = !1, numeric = !1, hex = !1; !this.scanner.eof() && valid$1 && !terminated;) {
							var ch = this.scanner.source[this.scanner.index];
							if (ch === quote) break;
							if (terminated = ch === ";", result += ch, ++this.scanner.index, !terminated) switch (result.length) {
								case 2:
									numeric = ch === "#";
									break;
								case 3:
									numeric && (hex = ch === "x", valid$1 = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0)), numeric &&= !hex);
									break;
								default:
									valid$1 &&= !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0))), valid$1 &&= !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
									break;
							}
						}
						if (valid$1 && terminated && result.length > 2) {
							var str = result.substr(1, result.length - 2);
							numeric && str.length > 1 ? result = String.fromCharCode(parseInt(str.substr(1), 10)) : hex && str.length > 2 ? result = String.fromCharCode(parseInt("0" + str.substr(1), 16)) : !numeric && !hex && xhtml_entities_1.XHTMLEntities[str] && (result = xhtml_entities_1.XHTMLEntities[str]);
						}
						return result;
					}, JSXParser.prototype.lexJSX = function() {
						var cp = this.scanner.source.charCodeAt(this.scanner.index);
						if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
							var value = this.scanner.source[this.scanner.index++];
							return {
								type: 7,
								value,
								lineNumber: this.scanner.lineNumber,
								lineStart: this.scanner.lineStart,
								start: this.scanner.index - 1,
								end: this.scanner.index
							};
						}
						if (cp === 34 || cp === 39) {
							for (var start = this.scanner.index, quote = this.scanner.source[this.scanner.index++], str = ""; !this.scanner.eof();) {
								var ch = this.scanner.source[this.scanner.index++];
								if (ch === quote) break;
								ch === "&" ? str += this.scanXHTMLEntity(quote) : str += ch;
							}
							return {
								type: 8,
								value: str,
								lineNumber: this.scanner.lineNumber,
								lineStart: this.scanner.lineStart,
								start,
								end: this.scanner.index
							};
						}
						if (cp === 46) {
							var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1), n2 = this.scanner.source.charCodeAt(this.scanner.index + 2), value = n1 === 46 && n2 === 46 ? "..." : ".", start = this.scanner.index;
							return this.scanner.index += value.length, {
								type: 7,
								value,
								lineNumber: this.scanner.lineNumber,
								lineStart: this.scanner.lineStart,
								start,
								end: this.scanner.index
							};
						}
						if (cp === 96) return {
							type: 10,
							value: "",
							lineNumber: this.scanner.lineNumber,
							lineStart: this.scanner.lineStart,
							start: this.scanner.index,
							end: this.scanner.index
						};
						if (character_1.Character.isIdentifierStart(cp) && cp !== 92) {
							var start = this.scanner.index;
							for (++this.scanner.index; !this.scanner.eof();) {
								var ch = this.scanner.source.charCodeAt(this.scanner.index);
								if (character_1.Character.isIdentifierPart(ch) && ch !== 92) ++this.scanner.index;
								else if (ch === 45) ++this.scanner.index;
								else break;
							}
							return {
								type: 100,
								value: this.scanner.source.slice(start, this.scanner.index),
								lineNumber: this.scanner.lineNumber,
								lineStart: this.scanner.lineStart,
								start,
								end: this.scanner.index
							};
						}
						return this.scanner.lex();
					}, JSXParser.prototype.nextJSXToken = function() {
						this.collectComments(), this.startMarker.index = this.scanner.index, this.startMarker.line = this.scanner.lineNumber, this.startMarker.column = this.scanner.index - this.scanner.lineStart;
						var token = this.lexJSX();
						return this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.index - this.scanner.lineStart, this.config.tokens && this.tokens.push(this.convertToken(token)), token;
					}, JSXParser.prototype.nextJSXText = function() {
						this.startMarker.index = this.scanner.index, this.startMarker.line = this.scanner.lineNumber, this.startMarker.column = this.scanner.index - this.scanner.lineStart;
						for (var start = this.scanner.index, text$6 = ""; !this.scanner.eof();) {
							var ch = this.scanner.source[this.scanner.index];
							if (ch === "{" || ch === "<") break;
							++this.scanner.index, text$6 += ch, character_1.Character.isLineTerminator(ch.charCodeAt(0)) && (++this.scanner.lineNumber, ch === "\r" && this.scanner.source[this.scanner.index] === "\n" && ++this.scanner.index, this.scanner.lineStart = this.scanner.index);
						}
						this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
						var token = {
							type: 101,
							value: text$6,
							lineNumber: this.scanner.lineNumber,
							lineStart: this.scanner.lineStart,
							start,
							end: this.scanner.index
						};
						return text$6.length > 0 && this.config.tokens && this.tokens.push(this.convertToken(token)), token;
					}, JSXParser.prototype.peekJSXToken = function() {
						var state = this.scanner.saveState();
						this.scanner.scanComments();
						var next = this.lexJSX();
						return this.scanner.restoreState(state), next;
					}, JSXParser.prototype.expectJSX = function(value) {
						var token = this.nextJSXToken();
						(token.type !== 7 || token.value !== value) && this.throwUnexpectedToken(token);
					}, JSXParser.prototype.matchJSX = function(value) {
						var next = this.peekJSXToken();
						return next.type === 7 && next.value === value;
					}, JSXParser.prototype.parseJSXIdentifier = function() {
						var node$1 = this.createJSXNode(), token = this.nextJSXToken();
						return token.type !== 100 && this.throwUnexpectedToken(token), this.finalize(node$1, new JSXNode.JSXIdentifier(token.value));
					}, JSXParser.prototype.parseJSXElementName = function() {
						var node$1 = this.createJSXNode(), elementName = this.parseJSXIdentifier();
						if (this.matchJSX(":")) {
							var namespace = elementName;
							this.expectJSX(":");
							var name_1 = this.parseJSXIdentifier();
							elementName = this.finalize(node$1, new JSXNode.JSXNamespacedName(namespace, name_1));
						} else if (this.matchJSX(".")) for (; this.matchJSX(".");) {
							var object = elementName;
							this.expectJSX(".");
							var property = this.parseJSXIdentifier();
							elementName = this.finalize(node$1, new JSXNode.JSXMemberExpression(object, property));
						}
						return elementName;
					}, JSXParser.prototype.parseJSXAttributeName = function() {
						var node$1 = this.createJSXNode(), attributeName, identifier$1 = this.parseJSXIdentifier();
						if (this.matchJSX(":")) {
							var namespace = identifier$1;
							this.expectJSX(":");
							var name_2 = this.parseJSXIdentifier();
							attributeName = this.finalize(node$1, new JSXNode.JSXNamespacedName(namespace, name_2));
						} else attributeName = identifier$1;
						return attributeName;
					}, JSXParser.prototype.parseJSXStringLiteralAttribute = function() {
						var node$1 = this.createJSXNode(), token = this.nextJSXToken();
						token.type !== 8 && this.throwUnexpectedToken(token);
						var raw = this.getTokenRaw(token);
						return this.finalize(node$1, new Node.Literal(token.value, raw));
					}, JSXParser.prototype.parseJSXExpressionAttribute = function() {
						var node$1 = this.createJSXNode();
						this.expectJSX("{"), this.finishJSX(), this.match("}") && this.tolerateError("JSX attributes must only be assigned a non-empty expression");
						var expression = this.parseAssignmentExpression();
						return this.reenterJSX(), this.finalize(node$1, new JSXNode.JSXExpressionContainer(expression));
					}, JSXParser.prototype.parseJSXAttributeValue = function() {
						return this.matchJSX("{") ? this.parseJSXExpressionAttribute() : this.matchJSX("<") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
					}, JSXParser.prototype.parseJSXNameValueAttribute = function() {
						var node$1 = this.createJSXNode(), name$1 = this.parseJSXAttributeName(), value = null;
						return this.matchJSX("=") && (this.expectJSX("="), value = this.parseJSXAttributeValue()), this.finalize(node$1, new JSXNode.JSXAttribute(name$1, value));
					}, JSXParser.prototype.parseJSXSpreadAttribute = function() {
						var node$1 = this.createJSXNode();
						this.expectJSX("{"), this.expectJSX("..."), this.finishJSX();
						var argument = this.parseAssignmentExpression();
						return this.reenterJSX(), this.finalize(node$1, new JSXNode.JSXSpreadAttribute(argument));
					}, JSXParser.prototype.parseJSXAttributes = function() {
						for (var attributes = []; !this.matchJSX("/") && !this.matchJSX(">");) {
							var attribute = this.matchJSX("{") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
							attributes.push(attribute);
						}
						return attributes;
					}, JSXParser.prototype.parseJSXOpeningElement = function() {
						var node$1 = this.createJSXNode();
						this.expectJSX("<");
						var name$1 = this.parseJSXElementName(), attributes = this.parseJSXAttributes(), selfClosing = this.matchJSX("/");
						return selfClosing && this.expectJSX("/"), this.expectJSX(">"), this.finalize(node$1, new JSXNode.JSXOpeningElement(name$1, selfClosing, attributes));
					}, JSXParser.prototype.parseJSXBoundaryElement = function() {
						var node$1 = this.createJSXNode();
						if (this.expectJSX("<"), this.matchJSX("/")) {
							this.expectJSX("/");
							var name_3 = this.parseJSXElementName();
							return this.expectJSX(">"), this.finalize(node$1, new JSXNode.JSXClosingElement(name_3));
						}
						var name$1 = this.parseJSXElementName(), attributes = this.parseJSXAttributes(), selfClosing = this.matchJSX("/");
						return selfClosing && this.expectJSX("/"), this.expectJSX(">"), this.finalize(node$1, new JSXNode.JSXOpeningElement(name$1, selfClosing, attributes));
					}, JSXParser.prototype.parseJSXEmptyExpression = function() {
						var node$1 = this.createJSXChildNode();
						return this.collectComments(), this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.index - this.scanner.lineStart, this.finalize(node$1, new JSXNode.JSXEmptyExpression());
					}, JSXParser.prototype.parseJSXExpressionContainer = function() {
						var node$1 = this.createJSXNode();
						this.expectJSX("{");
						var expression;
						return this.matchJSX("}") ? (expression = this.parseJSXEmptyExpression(), this.expectJSX("}")) : (this.finishJSX(), expression = this.parseAssignmentExpression(), this.reenterJSX()), this.finalize(node$1, new JSXNode.JSXExpressionContainer(expression));
					}, JSXParser.prototype.parseJSXChildren = function() {
						for (var children = []; !this.scanner.eof();) {
							var node$1 = this.createJSXChildNode(), token = this.nextJSXText();
							if (token.start < token.end) {
								var raw = this.getTokenRaw(token), child = this.finalize(node$1, new JSXNode.JSXText(token.value, raw));
								children.push(child);
							}
							if (this.scanner.source[this.scanner.index] === "{") {
								var container = this.parseJSXExpressionContainer();
								children.push(container);
							} else break;
						}
						return children;
					}, JSXParser.prototype.parseComplexJSXElement = function(el) {
						for (var stack = []; !this.scanner.eof();) {
							el.children = el.children.concat(this.parseJSXChildren());
							var node$1 = this.createJSXChildNode(), element$3 = this.parseJSXBoundaryElement();
							if (element$3.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
								var opening = element$3;
								if (opening.selfClosing) {
									var child = this.finalize(node$1, new JSXNode.JSXElement(opening, [], null));
									el.children.push(child);
								} else stack.push(el), el = {
									node: node$1,
									opening,
									closing: null,
									children: []
								};
							}
							if (element$3.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
								el.closing = element$3;
								var open_1 = getQualifiedElementName(el.opening.name);
								if (open_1 !== getQualifiedElementName(el.closing.name) && this.tolerateError("Expected corresponding JSX closing tag for %0", open_1), stack.length > 0) {
									var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
									el = stack[stack.length - 1], el.children.push(child), stack.pop();
								} else break;
							}
						}
						return el;
					}, JSXParser.prototype.parseJSXElement = function() {
						var node$1 = this.createJSXNode(), opening = this.parseJSXOpeningElement(), children = [], closing = null;
						if (!opening.selfClosing) {
							var el = this.parseComplexJSXElement({
								node: node$1,
								opening,
								closing,
								children
							});
							children = el.children, closing = el.closing;
						}
						return this.finalize(node$1, new JSXNode.JSXElement(opening, children, closing));
					}, JSXParser.prototype.parseJSXRoot = function() {
						this.config.tokens && this.tokens.pop(), this.startJSX();
						var element$3 = this.parseJSXElement();
						return this.finishJSX(), element$3;
					}, JSXParser.prototype.isStartOfExpression = function() {
						return _super.prototype.isStartOfExpression.call(this) || this.match("<");
					}, JSXParser;
				}(parser_1.Parser);
			},
			function(module$1, exports$1) {
				Object.defineProperty(exports$1, "__esModule", { value: !0 });
				var Regex = {
					NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
					NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
				};
				exports$1.Character = {
					fromCodePoint: function(cp) {
						return cp < 65536 ? String.fromCharCode(cp) : String.fromCharCode(55296 + (cp - 65536 >> 10)) + String.fromCharCode(56320 + (cp - 65536 & 1023));
					},
					isWhiteSpace: function(cp) {
						return cp === 32 || cp === 9 || cp === 11 || cp === 12 || cp === 160 || cp >= 5760 && [
							5760,
							8192,
							8193,
							8194,
							8195,
							8196,
							8197,
							8198,
							8199,
							8200,
							8201,
							8202,
							8239,
							8287,
							12288,
							65279
						].indexOf(cp) >= 0;
					},
					isLineTerminator: function(cp) {
						return cp === 10 || cp === 13 || cp === 8232 || cp === 8233;
					},
					isIdentifierStart: function(cp) {
						return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierStart.test(exports$1.Character.fromCodePoint(cp));
					},
					isIdentifierPart: function(cp) {
						return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp >= 48 && cp <= 57 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierPart.test(exports$1.Character.fromCodePoint(cp));
					},
					isDecimalDigit: function(cp) {
						return cp >= 48 && cp <= 57;
					},
					isHexDigit: function(cp) {
						return cp >= 48 && cp <= 57 || cp >= 65 && cp <= 70 || cp >= 97 && cp <= 102;
					},
					isOctalDigit: function(cp) {
						return cp >= 48 && cp <= 55;
					}
				};
			},
			function(module$1, exports$1, __webpack_require__) {
				Object.defineProperty(exports$1, "__esModule", { value: !0 });
				var jsx_syntax_1 = __webpack_require__(6);
				exports$1.JSXClosingElement = function() {
					function JSXClosingElement(name$1) {
						this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement, this.name = name$1;
					}
					return JSXClosingElement;
				}(), exports$1.JSXElement = function() {
					function JSXElement(openingElement, children, closingElement) {
						this.type = jsx_syntax_1.JSXSyntax.JSXElement, this.openingElement = openingElement, this.children = children, this.closingElement = closingElement;
					}
					return JSXElement;
				}(), exports$1.JSXEmptyExpression = function() {
					function JSXEmptyExpression() {
						this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
					}
					return JSXEmptyExpression;
				}(), exports$1.JSXExpressionContainer = function() {
					function JSXExpressionContainer(expression) {
						this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer, this.expression = expression;
					}
					return JSXExpressionContainer;
				}(), exports$1.JSXIdentifier = function() {
					function JSXIdentifier(name$1) {
						this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier, this.name = name$1;
					}
					return JSXIdentifier;
				}(), exports$1.JSXMemberExpression = function() {
					function JSXMemberExpression(object, property) {
						this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression, this.object = object, this.property = property;
					}
					return JSXMemberExpression;
				}(), exports$1.JSXAttribute = function() {
					function JSXAttribute(name$1, value) {
						this.type = jsx_syntax_1.JSXSyntax.JSXAttribute, this.name = name$1, this.value = value;
					}
					return JSXAttribute;
				}(), exports$1.JSXNamespacedName = function() {
					function JSXNamespacedName(namespace, name$1) {
						this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName, this.namespace = namespace, this.name = name$1;
					}
					return JSXNamespacedName;
				}(), exports$1.JSXOpeningElement = function() {
					function JSXOpeningElement(name$1, selfClosing, attributes) {
						this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement, this.name = name$1, this.selfClosing = selfClosing, this.attributes = attributes;
					}
					return JSXOpeningElement;
				}(), exports$1.JSXSpreadAttribute = function() {
					function JSXSpreadAttribute(argument) {
						this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute, this.argument = argument;
					}
					return JSXSpreadAttribute;
				}(), exports$1.JSXText = function() {
					function JSXText(value, raw) {
						this.type = jsx_syntax_1.JSXSyntax.JSXText, this.value = value, this.raw = raw;
					}
					return JSXText;
				}();
			},
			function(module$1, exports$1) {
				Object.defineProperty(exports$1, "__esModule", { value: !0 }), exports$1.JSXSyntax = {
					JSXAttribute: "JSXAttribute",
					JSXClosingElement: "JSXClosingElement",
					JSXElement: "JSXElement",
					JSXEmptyExpression: "JSXEmptyExpression",
					JSXExpressionContainer: "JSXExpressionContainer",
					JSXIdentifier: "JSXIdentifier",
					JSXMemberExpression: "JSXMemberExpression",
					JSXNamespacedName: "JSXNamespacedName",
					JSXOpeningElement: "JSXOpeningElement",
					JSXSpreadAttribute: "JSXSpreadAttribute",
					JSXText: "JSXText"
				};
			},
			function(module$1, exports$1, __webpack_require__) {
				Object.defineProperty(exports$1, "__esModule", { value: !0 });
				var syntax_1 = __webpack_require__(2);
				exports$1.ArrayExpression = function() {
					function ArrayExpression(elements) {
						this.type = syntax_1.Syntax.ArrayExpression, this.elements = elements;
					}
					return ArrayExpression;
				}(), exports$1.ArrayPattern = function() {
					function ArrayPattern(elements) {
						this.type = syntax_1.Syntax.ArrayPattern, this.elements = elements;
					}
					return ArrayPattern;
				}(), exports$1.ArrowFunctionExpression = function() {
					function ArrowFunctionExpression(params, body, expression) {
						this.type = syntax_1.Syntax.ArrowFunctionExpression, this.id = null, this.params = params, this.body = body, this.generator = !1, this.expression = expression, this.async = !1;
					}
					return ArrowFunctionExpression;
				}(), exports$1.AssignmentExpression = function() {
					function AssignmentExpression(operator$1, left, right) {
						this.type = syntax_1.Syntax.AssignmentExpression, this.operator = operator$1, this.left = left, this.right = right;
					}
					return AssignmentExpression;
				}(), exports$1.AssignmentPattern = function() {
					function AssignmentPattern(left, right) {
						this.type = syntax_1.Syntax.AssignmentPattern, this.left = left, this.right = right;
					}
					return AssignmentPattern;
				}(), exports$1.AsyncArrowFunctionExpression = function() {
					function AsyncArrowFunctionExpression(params, body, expression) {
						this.type = syntax_1.Syntax.ArrowFunctionExpression, this.id = null, this.params = params, this.body = body, this.generator = !1, this.expression = expression, this.async = !0;
					}
					return AsyncArrowFunctionExpression;
				}(), exports$1.AsyncFunctionDeclaration = function() {
					function AsyncFunctionDeclaration(id, params, body) {
						this.type = syntax_1.Syntax.FunctionDeclaration, this.id = id, this.params = params, this.body = body, this.generator = !1, this.expression = !1, this.async = !0;
					}
					return AsyncFunctionDeclaration;
				}(), exports$1.AsyncFunctionExpression = function() {
					function AsyncFunctionExpression(id, params, body) {
						this.type = syntax_1.Syntax.FunctionExpression, this.id = id, this.params = params, this.body = body, this.generator = !1, this.expression = !1, this.async = !0;
					}
					return AsyncFunctionExpression;
				}(), exports$1.AwaitExpression = function() {
					function AwaitExpression(argument) {
						this.type = syntax_1.Syntax.AwaitExpression, this.argument = argument;
					}
					return AwaitExpression;
				}(), exports$1.BinaryExpression = function() {
					function BinaryExpression(operator$1, left, right) {
						this.type = operator$1 === "||" || operator$1 === "&&" ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression, this.operator = operator$1, this.left = left, this.right = right;
					}
					return BinaryExpression;
				}(), exports$1.BlockStatement = function() {
					function BlockStatement(body) {
						this.type = syntax_1.Syntax.BlockStatement, this.body = body;
					}
					return BlockStatement;
				}(), exports$1.BreakStatement = function() {
					function BreakStatement(label) {
						this.type = syntax_1.Syntax.BreakStatement, this.label = label;
					}
					return BreakStatement;
				}(), exports$1.CallExpression = function() {
					function CallExpression(callee, args) {
						this.type = syntax_1.Syntax.CallExpression, this.callee = callee, this.arguments = args;
					}
					return CallExpression;
				}(), exports$1.CatchClause = function() {
					function CatchClause(param, body) {
						this.type = syntax_1.Syntax.CatchClause, this.param = param, this.body = body;
					}
					return CatchClause;
				}(), exports$1.ClassBody = function() {
					function ClassBody(body) {
						this.type = syntax_1.Syntax.ClassBody, this.body = body;
					}
					return ClassBody;
				}(), exports$1.ClassDeclaration = function() {
					function ClassDeclaration(id, superClass, body) {
						this.type = syntax_1.Syntax.ClassDeclaration, this.id = id, this.superClass = superClass, this.body = body;
					}
					return ClassDeclaration;
				}(), exports$1.ClassExpression = function() {
					function ClassExpression(id, superClass, body) {
						this.type = syntax_1.Syntax.ClassExpression, this.id = id, this.superClass = superClass, this.body = body;
					}
					return ClassExpression;
				}(), exports$1.ComputedMemberExpression = function() {
					function ComputedMemberExpression(object, property) {
						this.type = syntax_1.Syntax.MemberExpression, this.computed = !0, this.object = object, this.property = property;
					}
					return ComputedMemberExpression;
				}(), exports$1.ConditionalExpression = function() {
					function ConditionalExpression(test, consequent, alternate) {
						this.type = syntax_1.Syntax.ConditionalExpression, this.test = test, this.consequent = consequent, this.alternate = alternate;
					}
					return ConditionalExpression;
				}(), exports$1.ContinueStatement = function() {
					function ContinueStatement(label) {
						this.type = syntax_1.Syntax.ContinueStatement, this.label = label;
					}
					return ContinueStatement;
				}(), exports$1.DebuggerStatement = function() {
					function DebuggerStatement() {
						this.type = syntax_1.Syntax.DebuggerStatement;
					}
					return DebuggerStatement;
				}(), exports$1.Directive = function() {
					function Directive(expression, directive) {
						this.type = syntax_1.Syntax.ExpressionStatement, this.expression = expression, this.directive = directive;
					}
					return Directive;
				}(), exports$1.DoWhileStatement = function() {
					function DoWhileStatement(body, test) {
						this.type = syntax_1.Syntax.DoWhileStatement, this.body = body, this.test = test;
					}
					return DoWhileStatement;
				}(), exports$1.EmptyStatement = function() {
					function EmptyStatement() {
						this.type = syntax_1.Syntax.EmptyStatement;
					}
					return EmptyStatement;
				}(), exports$1.ExportAllDeclaration = function() {
					function ExportAllDeclaration(source$2) {
						this.type = syntax_1.Syntax.ExportAllDeclaration, this.source = source$2;
					}
					return ExportAllDeclaration;
				}(), exports$1.ExportDefaultDeclaration = function() {
					function ExportDefaultDeclaration(declaration) {
						this.type = syntax_1.Syntax.ExportDefaultDeclaration, this.declaration = declaration;
					}
					return ExportDefaultDeclaration;
				}(), exports$1.ExportNamedDeclaration = function() {
					function ExportNamedDeclaration(declaration, specifiers, source$2) {
						this.type = syntax_1.Syntax.ExportNamedDeclaration, this.declaration = declaration, this.specifiers = specifiers, this.source = source$2;
					}
					return ExportNamedDeclaration;
				}(), exports$1.ExportSpecifier = function() {
					function ExportSpecifier(local, exported) {
						this.type = syntax_1.Syntax.ExportSpecifier, this.exported = exported, this.local = local;
					}
					return ExportSpecifier;
				}(), exports$1.ExpressionStatement = function() {
					function ExpressionStatement(expression) {
						this.type = syntax_1.Syntax.ExpressionStatement, this.expression = expression;
					}
					return ExpressionStatement;
				}(), exports$1.ForInStatement = function() {
					function ForInStatement(left, right, body) {
						this.type = syntax_1.Syntax.ForInStatement, this.left = left, this.right = right, this.body = body, this.each = !1;
					}
					return ForInStatement;
				}(), exports$1.ForOfStatement = function() {
					function ForOfStatement(left, right, body) {
						this.type = syntax_1.Syntax.ForOfStatement, this.left = left, this.right = right, this.body = body;
					}
					return ForOfStatement;
				}(), exports$1.ForStatement = function() {
					function ForStatement(init, test, update, body) {
						this.type = syntax_1.Syntax.ForStatement, this.init = init, this.test = test, this.update = update, this.body = body;
					}
					return ForStatement;
				}(), exports$1.FunctionDeclaration = function() {
					function FunctionDeclaration(id, params, body, generator) {
						this.type = syntax_1.Syntax.FunctionDeclaration, this.id = id, this.params = params, this.body = body, this.generator = generator, this.expression = !1, this.async = !1;
					}
					return FunctionDeclaration;
				}(), exports$1.FunctionExpression = function() {
					function FunctionExpression(id, params, body, generator) {
						this.type = syntax_1.Syntax.FunctionExpression, this.id = id, this.params = params, this.body = body, this.generator = generator, this.expression = !1, this.async = !1;
					}
					return FunctionExpression;
				}(), exports$1.Identifier = function() {
					function Identifier(name$1) {
						this.type = syntax_1.Syntax.Identifier, this.name = name$1;
					}
					return Identifier;
				}(), exports$1.IfStatement = function() {
					function IfStatement(test, consequent, alternate) {
						this.type = syntax_1.Syntax.IfStatement, this.test = test, this.consequent = consequent, this.alternate = alternate;
					}
					return IfStatement;
				}(), exports$1.ImportDeclaration = function() {
					function ImportDeclaration(specifiers, source$2) {
						this.type = syntax_1.Syntax.ImportDeclaration, this.specifiers = specifiers, this.source = source$2;
					}
					return ImportDeclaration;
				}(), exports$1.ImportDefaultSpecifier = function() {
					function ImportDefaultSpecifier(local) {
						this.type = syntax_1.Syntax.ImportDefaultSpecifier, this.local = local;
					}
					return ImportDefaultSpecifier;
				}(), exports$1.ImportNamespaceSpecifier = function() {
					function ImportNamespaceSpecifier(local) {
						this.type = syntax_1.Syntax.ImportNamespaceSpecifier, this.local = local;
					}
					return ImportNamespaceSpecifier;
				}(), exports$1.ImportSpecifier = function() {
					function ImportSpecifier(local, imported) {
						this.type = syntax_1.Syntax.ImportSpecifier, this.local = local, this.imported = imported;
					}
					return ImportSpecifier;
				}(), exports$1.LabeledStatement = function() {
					function LabeledStatement(label, body) {
						this.type = syntax_1.Syntax.LabeledStatement, this.label = label, this.body = body;
					}
					return LabeledStatement;
				}(), exports$1.Literal = function() {
					function Literal(value, raw) {
						this.type = syntax_1.Syntax.Literal, this.value = value, this.raw = raw;
					}
					return Literal;
				}(), exports$1.MetaProperty = function() {
					function MetaProperty(meta, property) {
						this.type = syntax_1.Syntax.MetaProperty, this.meta = meta, this.property = property;
					}
					return MetaProperty;
				}(), exports$1.MethodDefinition = function() {
					function MethodDefinition(key, computed, value, kind, isStatic) {
						this.type = syntax_1.Syntax.MethodDefinition, this.key = key, this.computed = computed, this.value = value, this.kind = kind, this.static = isStatic;
					}
					return MethodDefinition;
				}(), exports$1.Module = function() {
					function Module(body) {
						this.type = syntax_1.Syntax.Program, this.body = body, this.sourceType = "module";
					}
					return Module;
				}(), exports$1.NewExpression = function() {
					function NewExpression(callee, args) {
						this.type = syntax_1.Syntax.NewExpression, this.callee = callee, this.arguments = args;
					}
					return NewExpression;
				}(), exports$1.ObjectExpression = function() {
					function ObjectExpression(properties) {
						this.type = syntax_1.Syntax.ObjectExpression, this.properties = properties;
					}
					return ObjectExpression;
				}(), exports$1.ObjectPattern = function() {
					function ObjectPattern(properties) {
						this.type = syntax_1.Syntax.ObjectPattern, this.properties = properties;
					}
					return ObjectPattern;
				}(), exports$1.Property = function() {
					function Property(kind, key, computed, value, method, shorthand) {
						this.type = syntax_1.Syntax.Property, this.key = key, this.computed = computed, this.value = value, this.kind = kind, this.method = method, this.shorthand = shorthand;
					}
					return Property;
				}(), exports$1.RegexLiteral = function() {
					function RegexLiteral(value, raw, pattern, flags) {
						this.type = syntax_1.Syntax.Literal, this.value = value, this.raw = raw, this.regex = {
							pattern,
							flags
						};
					}
					return RegexLiteral;
				}(), exports$1.RestElement = function() {
					function RestElement(argument) {
						this.type = syntax_1.Syntax.RestElement, this.argument = argument;
					}
					return RestElement;
				}(), exports$1.ReturnStatement = function() {
					function ReturnStatement(argument) {
						this.type = syntax_1.Syntax.ReturnStatement, this.argument = argument;
					}
					return ReturnStatement;
				}(), exports$1.Script = function() {
					function Script(body) {
						this.type = syntax_1.Syntax.Program, this.body = body, this.sourceType = "script";
					}
					return Script;
				}(), exports$1.SequenceExpression = function() {
					function SequenceExpression(expressions) {
						this.type = syntax_1.Syntax.SequenceExpression, this.expressions = expressions;
					}
					return SequenceExpression;
				}(), exports$1.SpreadElement = function() {
					function SpreadElement(argument) {
						this.type = syntax_1.Syntax.SpreadElement, this.argument = argument;
					}
					return SpreadElement;
				}(), exports$1.StaticMemberExpression = function() {
					function StaticMemberExpression(object, property) {
						this.type = syntax_1.Syntax.MemberExpression, this.computed = !1, this.object = object, this.property = property;
					}
					return StaticMemberExpression;
				}(), exports$1.Super = function() {
					function Super() {
						this.type = syntax_1.Syntax.Super;
					}
					return Super;
				}(), exports$1.SwitchCase = function() {
					function SwitchCase(test, consequent) {
						this.type = syntax_1.Syntax.SwitchCase, this.test = test, this.consequent = consequent;
					}
					return SwitchCase;
				}(), exports$1.SwitchStatement = function() {
					function SwitchStatement(discriminant, cases) {
						this.type = syntax_1.Syntax.SwitchStatement, this.discriminant = discriminant, this.cases = cases;
					}
					return SwitchStatement;
				}(), exports$1.TaggedTemplateExpression = function() {
					function TaggedTemplateExpression(tag, quasi) {
						this.type = syntax_1.Syntax.TaggedTemplateExpression, this.tag = tag, this.quasi = quasi;
					}
					return TaggedTemplateExpression;
				}(), exports$1.TemplateElement = function() {
					function TemplateElement(value, tail) {
						this.type = syntax_1.Syntax.TemplateElement, this.value = value, this.tail = tail;
					}
					return TemplateElement;
				}(), exports$1.TemplateLiteral = function() {
					function TemplateLiteral(quasis, expressions) {
						this.type = syntax_1.Syntax.TemplateLiteral, this.quasis = quasis, this.expressions = expressions;
					}
					return TemplateLiteral;
				}(), exports$1.ThisExpression = function() {
					function ThisExpression() {
						this.type = syntax_1.Syntax.ThisExpression;
					}
					return ThisExpression;
				}(), exports$1.ThrowStatement = function() {
					function ThrowStatement(argument) {
						this.type = syntax_1.Syntax.ThrowStatement, this.argument = argument;
					}
					return ThrowStatement;
				}(), exports$1.TryStatement = function() {
					function TryStatement(block, handler, finalizer) {
						this.type = syntax_1.Syntax.TryStatement, this.block = block, this.handler = handler, this.finalizer = finalizer;
					}
					return TryStatement;
				}(), exports$1.UnaryExpression = function() {
					function UnaryExpression(operator$1, argument) {
						this.type = syntax_1.Syntax.UnaryExpression, this.operator = operator$1, this.argument = argument, this.prefix = !0;
					}
					return UnaryExpression;
				}(), exports$1.UpdateExpression = function() {
					function UpdateExpression(operator$1, argument, prefix) {
						this.type = syntax_1.Syntax.UpdateExpression, this.operator = operator$1, this.argument = argument, this.prefix = prefix;
					}
					return UpdateExpression;
				}(), exports$1.VariableDeclaration = function() {
					function VariableDeclaration(declarations, kind) {
						this.type = syntax_1.Syntax.VariableDeclaration, this.declarations = declarations, this.kind = kind;
					}
					return VariableDeclaration;
				}(), exports$1.VariableDeclarator = function() {
					function VariableDeclarator(id, init) {
						this.type = syntax_1.Syntax.VariableDeclarator, this.id = id, this.init = init;
					}
					return VariableDeclarator;
				}(), exports$1.WhileStatement = function() {
					function WhileStatement(test, body) {
						this.type = syntax_1.Syntax.WhileStatement, this.test = test, this.body = body;
					}
					return WhileStatement;
				}(), exports$1.WithStatement = function() {
					function WithStatement(object, body) {
						this.type = syntax_1.Syntax.WithStatement, this.object = object, this.body = body;
					}
					return WithStatement;
				}(), exports$1.YieldExpression = function() {
					function YieldExpression(argument, delegate) {
						this.type = syntax_1.Syntax.YieldExpression, this.argument = argument, this.delegate = delegate;
					}
					return YieldExpression;
				}();
			},
			function(module$1, exports$1, __webpack_require__) {
				Object.defineProperty(exports$1, "__esModule", { value: !0 });
				var assert_1 = __webpack_require__(9), error_handler_1 = __webpack_require__(10), messages_1 = __webpack_require__(11), Node = __webpack_require__(7), scanner_1 = __webpack_require__(12), syntax_1 = __webpack_require__(2), token_1 = __webpack_require__(13), ArrowParameterPlaceHolder = "ArrowParameterPlaceHolder";
				exports$1.Parser = function() {
					function Parser(code$4, options, delegate) {
						options === void 0 && (options = {}), this.config = {
							range: typeof options.range == "boolean" && options.range,
							loc: typeof options.loc == "boolean" && options.loc,
							source: null,
							tokens: typeof options.tokens == "boolean" && options.tokens,
							comment: typeof options.comment == "boolean" && options.comment,
							tolerant: typeof options.tolerant == "boolean" && options.tolerant
						}, this.config.loc && options.source && options.source !== null && (this.config.source = String(options.source)), this.delegate = delegate, this.errorHandler = new error_handler_1.ErrorHandler(), this.errorHandler.tolerant = this.config.tolerant, this.scanner = new scanner_1.Scanner(code$4, this.errorHandler), this.scanner.trackComment = this.config.comment, this.operatorPrecedence = {
							")": 0,
							";": 0,
							",": 0,
							"=": 0,
							"]": 0,
							"||": 1,
							"&&": 2,
							"|": 3,
							"^": 4,
							"&": 5,
							"==": 6,
							"!=": 6,
							"===": 6,
							"!==": 6,
							"<": 7,
							">": 7,
							"<=": 7,
							">=": 7,
							"<<": 8,
							">>": 8,
							">>>": 8,
							"+": 9,
							"-": 9,
							"*": 11,
							"/": 11,
							"%": 11
						}, this.lookahead = {
							type: 2,
							value: "",
							lineNumber: this.scanner.lineNumber,
							lineStart: 0,
							start: 0,
							end: 0
						}, this.hasLineTerminator = !1, this.context = {
							isModule: !1,
							await: !1,
							allowIn: !0,
							allowStrictDirective: !0,
							allowYield: !0,
							firstCoverInitializedNameError: null,
							isAssignmentTarget: !1,
							isBindingElement: !1,
							inFunctionBody: !1,
							inIteration: !1,
							inSwitch: !1,
							labelSet: {},
							strict: !1
						}, this.tokens = [], this.startMarker = {
							index: 0,
							line: this.scanner.lineNumber,
							column: 0
						}, this.lastMarker = {
							index: 0,
							line: this.scanner.lineNumber,
							column: 0
						}, this.nextToken(), this.lastMarker = {
							index: this.scanner.index,
							line: this.scanner.lineNumber,
							column: this.scanner.index - this.scanner.lineStart
						};
					}
					return Parser.prototype.throwError = function(messageFormat) {
						var args = Array.prototype.slice.call(arguments, 1), msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
							return assert_1.assert(idx < args.length, "Message reference must be in range"), args[idx];
						}), index$2 = this.lastMarker.index, line = this.lastMarker.line, column = this.lastMarker.column + 1;
						throw this.errorHandler.createError(index$2, line, column, msg);
					}, Parser.prototype.tolerateError = function(messageFormat) {
						var args = Array.prototype.slice.call(arguments, 1), msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
							return assert_1.assert(idx < args.length, "Message reference must be in range"), args[idx];
						}), index$2 = this.lastMarker.index, line = this.scanner.lineNumber, column = this.lastMarker.column + 1;
						this.errorHandler.tolerateError(index$2, line, column, msg);
					}, Parser.prototype.unexpectedTokenError = function(token, message) {
						var msg = message || messages_1.Messages.UnexpectedToken, value;
						if (token ? (message || (msg = token.type === 2 ? messages_1.Messages.UnexpectedEOS : token.type === 3 ? messages_1.Messages.UnexpectedIdentifier : token.type === 6 ? messages_1.Messages.UnexpectedNumber : token.type === 8 ? messages_1.Messages.UnexpectedString : token.type === 10 ? messages_1.Messages.UnexpectedTemplate : messages_1.Messages.UnexpectedToken, token.type === 4 && (this.scanner.isFutureReservedWord(token.value) ? msg = messages_1.Messages.UnexpectedReserved : this.context.strict && this.scanner.isStrictModeReservedWord(token.value) && (msg = messages_1.Messages.StrictReservedWord))), value = token.value) : value = "ILLEGAL", msg = msg.replace("%0", value), token && typeof token.lineNumber == "number") {
							var index$2 = token.start, line = token.lineNumber, lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column, column = token.start - lastMarkerLineStart + 1;
							return this.errorHandler.createError(index$2, line, column, msg);
						} else {
							var index$2 = this.lastMarker.index, line = this.lastMarker.line, column = this.lastMarker.column + 1;
							return this.errorHandler.createError(index$2, line, column, msg);
						}
					}, Parser.prototype.throwUnexpectedToken = function(token, message) {
						throw this.unexpectedTokenError(token, message);
					}, Parser.prototype.tolerateUnexpectedToken = function(token, message) {
						this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
					}, Parser.prototype.collectComments = function() {
						if (!this.config.comment) this.scanner.scanComments();
						else {
							var comments = this.scanner.scanComments();
							if (comments.length > 0 && this.delegate) for (var i$2 = 0; i$2 < comments.length; ++i$2) {
								var e = comments[i$2], node$1 = void 0;
								node$1 = {
									type: e.multiLine ? "BlockComment" : "LineComment",
									value: this.scanner.source.slice(e.slice[0], e.slice[1])
								}, this.config.range && (node$1.range = e.range), this.config.loc && (node$1.loc = e.loc);
								var metadata = {
									start: {
										line: e.loc.start.line,
										column: e.loc.start.column,
										offset: e.range[0]
									},
									end: {
										line: e.loc.end.line,
										column: e.loc.end.column,
										offset: e.range[1]
									}
								};
								this.delegate(node$1, metadata);
							}
						}
					}, Parser.prototype.getTokenRaw = function(token) {
						return this.scanner.source.slice(token.start, token.end);
					}, Parser.prototype.convertToken = function(token) {
						var t = {
							type: token_1.TokenName[token.type],
							value: this.getTokenRaw(token)
						};
						return this.config.range && (t.range = [token.start, token.end]), this.config.loc && (t.loc = {
							start: {
								line: this.startMarker.line,
								column: this.startMarker.column
							},
							end: {
								line: this.scanner.lineNumber,
								column: this.scanner.index - this.scanner.lineStart
							}
						}), token.type === 9 && (t.regex = {
							pattern: token.pattern,
							flags: token.flags
						}), t;
					}, Parser.prototype.nextToken = function() {
						var token = this.lookahead;
						this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.index - this.scanner.lineStart, this.collectComments(), this.scanner.index !== this.startMarker.index && (this.startMarker.index = this.scanner.index, this.startMarker.line = this.scanner.lineNumber, this.startMarker.column = this.scanner.index - this.scanner.lineStart);
						var next = this.scanner.lex();
						return this.hasLineTerminator = token.lineNumber !== next.lineNumber, next && this.context.strict && next.type === 3 && this.scanner.isStrictModeReservedWord(next.value) && (next.type = 4), this.lookahead = next, this.config.tokens && next.type !== 2 && this.tokens.push(this.convertToken(next)), token;
					}, Parser.prototype.nextRegexToken = function() {
						this.collectComments();
						var token = this.scanner.scanRegExp();
						return this.config.tokens && (this.tokens.pop(), this.tokens.push(this.convertToken(token))), this.lookahead = token, this.nextToken(), token;
					}, Parser.prototype.createNode = function() {
						return {
							index: this.startMarker.index,
							line: this.startMarker.line,
							column: this.startMarker.column
						};
					}, Parser.prototype.startNode = function(token, lastLineStart) {
						lastLineStart === void 0 && (lastLineStart = 0);
						var column = token.start - token.lineStart, line = token.lineNumber;
						return column < 0 && (column += lastLineStart, line--), {
							index: token.start,
							line,
							column
						};
					}, Parser.prototype.finalize = function(marker, node$1) {
						if (this.config.range && (node$1.range = [marker.index, this.lastMarker.index]), this.config.loc && (node$1.loc = {
							start: {
								line: marker.line,
								column: marker.column
							},
							end: {
								line: this.lastMarker.line,
								column: this.lastMarker.column
							}
						}, this.config.source && (node$1.loc.source = this.config.source)), this.delegate) {
							var metadata = {
								start: {
									line: marker.line,
									column: marker.column,
									offset: marker.index
								},
								end: {
									line: this.lastMarker.line,
									column: this.lastMarker.column,
									offset: this.lastMarker.index
								}
							};
							this.delegate(node$1, metadata);
						}
						return node$1;
					}, Parser.prototype.expect = function(value) {
						var token = this.nextToken();
						(token.type !== 7 || token.value !== value) && this.throwUnexpectedToken(token);
					}, Parser.prototype.expectCommaSeparator = function() {
						if (this.config.tolerant) {
							var token = this.lookahead;
							token.type === 7 && token.value === "," ? this.nextToken() : token.type === 7 && token.value === ";" ? (this.nextToken(), this.tolerateUnexpectedToken(token)) : this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
						} else this.expect(",");
					}, Parser.prototype.expectKeyword = function(keyword) {
						var token = this.nextToken();
						(token.type !== 4 || token.value !== keyword) && this.throwUnexpectedToken(token);
					}, Parser.prototype.match = function(value) {
						return this.lookahead.type === 7 && this.lookahead.value === value;
					}, Parser.prototype.matchKeyword = function(keyword) {
						return this.lookahead.type === 4 && this.lookahead.value === keyword;
					}, Parser.prototype.matchContextualKeyword = function(keyword) {
						return this.lookahead.type === 3 && this.lookahead.value === keyword;
					}, Parser.prototype.matchAssign = function() {
						if (this.lookahead.type !== 7) return !1;
						var op = this.lookahead.value;
						return op === "=" || op === "*=" || op === "**=" || op === "/=" || op === "%=" || op === "+=" || op === "-=" || op === "<<=" || op === ">>=" || op === ">>>=" || op === "&=" || op === "^=" || op === "|=";
					}, Parser.prototype.isolateCoverGrammar = function(parseFunction) {
						var previousIsBindingElement = this.context.isBindingElement, previousIsAssignmentTarget = this.context.isAssignmentTarget, previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
						this.context.isBindingElement = !0, this.context.isAssignmentTarget = !0, this.context.firstCoverInitializedNameError = null;
						var result = parseFunction.call(this);
						return this.context.firstCoverInitializedNameError !== null && this.throwUnexpectedToken(this.context.firstCoverInitializedNameError), this.context.isBindingElement = previousIsBindingElement, this.context.isAssignmentTarget = previousIsAssignmentTarget, this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError, result;
					}, Parser.prototype.inheritCoverGrammar = function(parseFunction) {
						var previousIsBindingElement = this.context.isBindingElement, previousIsAssignmentTarget = this.context.isAssignmentTarget, previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
						this.context.isBindingElement = !0, this.context.isAssignmentTarget = !0, this.context.firstCoverInitializedNameError = null;
						var result = parseFunction.call(this);
						return this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement, this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget, this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError, result;
					}, Parser.prototype.consumeSemicolon = function() {
						this.match(";") ? this.nextToken() : this.hasLineTerminator || (this.lookahead.type !== 2 && !this.match("}") && this.throwUnexpectedToken(this.lookahead), this.lastMarker.index = this.startMarker.index, this.lastMarker.line = this.startMarker.line, this.lastMarker.column = this.startMarker.column);
					}, Parser.prototype.parsePrimaryExpression = function() {
						var node$1 = this.createNode(), expr, token, raw;
						switch (this.lookahead.type) {
							case 3:
								(this.context.isModule || this.context.await) && this.lookahead.value === "await" && this.tolerateUnexpectedToken(this.lookahead), expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node$1, new Node.Identifier(this.nextToken().value));
								break;
							case 6:
							case 8:
								this.context.strict && this.lookahead.octal && this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, token = this.nextToken(), raw = this.getTokenRaw(token), expr = this.finalize(node$1, new Node.Literal(token.value, raw));
								break;
							case 1:
								this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, token = this.nextToken(), raw = this.getTokenRaw(token), expr = this.finalize(node$1, new Node.Literal(token.value === "true", raw));
								break;
							case 5:
								this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, token = this.nextToken(), raw = this.getTokenRaw(token), expr = this.finalize(node$1, new Node.Literal(null, raw));
								break;
							case 10:
								expr = this.parseTemplateLiteral();
								break;
							case 7:
								switch (this.lookahead.value) {
									case "(":
										this.context.isBindingElement = !1, expr = this.inheritCoverGrammar(this.parseGroupExpression);
										break;
									case "[":
										expr = this.inheritCoverGrammar(this.parseArrayInitializer);
										break;
									case "{":
										expr = this.inheritCoverGrammar(this.parseObjectInitializer);
										break;
									case "/":
									case "/=":
										this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, this.scanner.index = this.startMarker.index, token = this.nextRegexToken(), raw = this.getTokenRaw(token), expr = this.finalize(node$1, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
										break;
									default: expr = this.throwUnexpectedToken(this.nextToken());
								}
								break;
							case 4:
								!this.context.strict && this.context.allowYield && this.matchKeyword("yield") ? expr = this.parseIdentifierName() : !this.context.strict && this.matchKeyword("let") ? expr = this.finalize(node$1, new Node.Identifier(this.nextToken().value)) : (this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, this.matchKeyword("function") ? expr = this.parseFunctionExpression() : this.matchKeyword("this") ? (this.nextToken(), expr = this.finalize(node$1, new Node.ThisExpression())) : expr = this.matchKeyword("class") ? this.parseClassExpression() : this.throwUnexpectedToken(this.nextToken()));
								break;
							default: expr = this.throwUnexpectedToken(this.nextToken());
						}
						return expr;
					}, Parser.prototype.parseSpreadElement = function() {
						var node$1 = this.createNode();
						this.expect("...");
						var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
						return this.finalize(node$1, new Node.SpreadElement(arg));
					}, Parser.prototype.parseArrayInitializer = function() {
						var node$1 = this.createNode(), elements = [];
						for (this.expect("["); !this.match("]");) if (this.match(",")) this.nextToken(), elements.push(null);
						else if (this.match("...")) {
							var element$3 = this.parseSpreadElement();
							this.match("]") || (this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, this.expect(",")), elements.push(element$3);
						} else elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression)), this.match("]") || this.expect(",");
						return this.expect("]"), this.finalize(node$1, new Node.ArrayExpression(elements));
					}, Parser.prototype.parsePropertyMethod = function(params) {
						this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
						var previousStrict = this.context.strict, previousAllowStrictDirective = this.context.allowStrictDirective;
						this.context.allowStrictDirective = params.simple;
						var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
						return this.context.strict && params.firstRestricted && this.tolerateUnexpectedToken(params.firstRestricted, params.message), this.context.strict && params.stricted && this.tolerateUnexpectedToken(params.stricted, params.message), this.context.strict = previousStrict, this.context.allowStrictDirective = previousAllowStrictDirective, body;
					}, Parser.prototype.parsePropertyMethodFunction = function() {
						var isGenerator = !1, node$1 = this.createNode(), previousAllowYield = this.context.allowYield;
						this.context.allowYield = !0;
						var params = this.parseFormalParameters(), method = this.parsePropertyMethod(params);
						return this.context.allowYield = previousAllowYield, this.finalize(node$1, new Node.FunctionExpression(null, params.params, method, isGenerator));
					}, Parser.prototype.parsePropertyMethodAsyncFunction = function() {
						var node$1 = this.createNode(), previousAllowYield = this.context.allowYield, previousAwait = this.context.await;
						this.context.allowYield = !1, this.context.await = !0;
						var params = this.parseFormalParameters(), method = this.parsePropertyMethod(params);
						return this.context.allowYield = previousAllowYield, this.context.await = previousAwait, this.finalize(node$1, new Node.AsyncFunctionExpression(null, params.params, method));
					}, Parser.prototype.parseObjectPropertyKey = function() {
						var node$1 = this.createNode(), token = this.nextToken(), key;
						switch (token.type) {
							case 8:
							case 6:
								this.context.strict && token.octal && this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
								var raw = this.getTokenRaw(token);
								key = this.finalize(node$1, new Node.Literal(token.value, raw));
								break;
							case 3:
							case 1:
							case 5:
							case 4:
								key = this.finalize(node$1, new Node.Identifier(token.value));
								break;
							case 7:
								token.value === "[" ? (key = this.isolateCoverGrammar(this.parseAssignmentExpression), this.expect("]")) : key = this.throwUnexpectedToken(token);
								break;
							default: key = this.throwUnexpectedToken(token);
						}
						return key;
					}, Parser.prototype.isPropertyKey = function(key, value) {
						return key.type === syntax_1.Syntax.Identifier && key.name === value || key.type === syntax_1.Syntax.Literal && key.value === value;
					}, Parser.prototype.parseObjectProperty = function(hasProto) {
						var node$1 = this.createNode(), token = this.lookahead, kind, key = null, value = null, computed = !1, method = !1, shorthand = !1, isAsync = !1;
						if (token.type === 3) {
							var id = token.value;
							this.nextToken(), computed = this.match("["), isAsync = !this.hasLineTerminator && id === "async" && !this.match(":") && !this.match("(") && !this.match("*") && !this.match(","), key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node$1, new Node.Identifier(id));
						} else this.match("*") ? this.nextToken() : (computed = this.match("["), key = this.parseObjectPropertyKey());
						var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
						if (token.type === 3 && !isAsync && token.value === "get" && lookaheadPropertyKey) kind = "get", computed = this.match("["), key = this.parseObjectPropertyKey(), this.context.allowYield = !1, value = this.parseGetterMethod();
						else if (token.type === 3 && !isAsync && token.value === "set" && lookaheadPropertyKey) kind = "set", computed = this.match("["), key = this.parseObjectPropertyKey(), value = this.parseSetterMethod();
						else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) kind = "init", computed = this.match("["), key = this.parseObjectPropertyKey(), value = this.parseGeneratorMethod(), method = !0;
						else if (key || this.throwUnexpectedToken(this.lookahead), kind = "init", this.match(":") && !isAsync) !computed && this.isPropertyKey(key, "__proto__") && (hasProto.value && this.tolerateError(messages_1.Messages.DuplicateProtoProperty), hasProto.value = !0), this.nextToken(), value = this.inheritCoverGrammar(this.parseAssignmentExpression);
						else if (this.match("(")) value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction(), method = !0;
						else if (token.type === 3) {
							var id = this.finalize(node$1, new Node.Identifier(token.value));
							if (this.match("=")) {
								this.context.firstCoverInitializedNameError = this.lookahead, this.nextToken(), shorthand = !0;
								var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
								value = this.finalize(node$1, new Node.AssignmentPattern(id, init));
							} else shorthand = !0, value = id;
						} else this.throwUnexpectedToken(this.nextToken());
						return this.finalize(node$1, new Node.Property(kind, key, computed, value, method, shorthand));
					}, Parser.prototype.parseObjectInitializer = function() {
						var node$1 = this.createNode();
						this.expect("{");
						for (var properties = [], hasProto = { value: !1 }; !this.match("}");) properties.push(this.parseObjectProperty(hasProto)), this.match("}") || this.expectCommaSeparator();
						return this.expect("}"), this.finalize(node$1, new Node.ObjectExpression(properties));
					}, Parser.prototype.parseTemplateHead = function() {
						assert_1.assert(this.lookahead.head, "Template literal must start with a template head");
						var node$1 = this.createNode(), token = this.nextToken(), raw = token.value, cooked = token.cooked;
						return this.finalize(node$1, new Node.TemplateElement({
							raw,
							cooked
						}, token.tail));
					}, Parser.prototype.parseTemplateElement = function() {
						this.lookahead.type !== 10 && this.throwUnexpectedToken();
						var node$1 = this.createNode(), token = this.nextToken(), raw = token.value, cooked = token.cooked;
						return this.finalize(node$1, new Node.TemplateElement({
							raw,
							cooked
						}, token.tail));
					}, Parser.prototype.parseTemplateLiteral = function() {
						var node$1 = this.createNode(), expressions = [], quasis = [], quasi = this.parseTemplateHead();
						for (quasis.push(quasi); !quasi.tail;) expressions.push(this.parseExpression()), quasi = this.parseTemplateElement(), quasis.push(quasi);
						return this.finalize(node$1, new Node.TemplateLiteral(quasis, expressions));
					}, Parser.prototype.reinterpretExpressionAsPattern = function(expr) {
						switch (expr.type) {
							case syntax_1.Syntax.Identifier:
							case syntax_1.Syntax.MemberExpression:
							case syntax_1.Syntax.RestElement:
							case syntax_1.Syntax.AssignmentPattern: break;
							case syntax_1.Syntax.SpreadElement:
								expr.type = syntax_1.Syntax.RestElement, this.reinterpretExpressionAsPattern(expr.argument);
								break;
							case syntax_1.Syntax.ArrayExpression:
								expr.type = syntax_1.Syntax.ArrayPattern;
								for (var i$2 = 0; i$2 < expr.elements.length; i$2++) expr.elements[i$2] !== null && this.reinterpretExpressionAsPattern(expr.elements[i$2]);
								break;
							case syntax_1.Syntax.ObjectExpression:
								expr.type = syntax_1.Syntax.ObjectPattern;
								for (var i$2 = 0; i$2 < expr.properties.length; i$2++) this.reinterpretExpressionAsPattern(expr.properties[i$2].value);
								break;
							case syntax_1.Syntax.AssignmentExpression:
								expr.type = syntax_1.Syntax.AssignmentPattern, delete expr.operator, this.reinterpretExpressionAsPattern(expr.left);
								break;
							default: break;
						}
					}, Parser.prototype.parseGroupExpression = function() {
						var expr;
						if (this.expect("("), this.match(")")) this.nextToken(), this.match("=>") || this.expect("=>"), expr = {
							type: ArrowParameterPlaceHolder,
							params: [],
							async: !1
						};
						else {
							var startToken = this.lookahead, params = [];
							if (this.match("...")) expr = this.parseRestElement(params), this.expect(")"), this.match("=>") || this.expect("=>"), expr = {
								type: ArrowParameterPlaceHolder,
								params: [expr],
								async: !1
							};
							else {
								var arrow = !1;
								if (this.context.isBindingElement = !0, expr = this.inheritCoverGrammar(this.parseAssignmentExpression), this.match(",")) {
									var expressions = [];
									for (this.context.isAssignmentTarget = !1, expressions.push(expr); this.lookahead.type !== 2 && this.match(",");) {
										if (this.nextToken(), this.match(")")) {
											this.nextToken();
											for (var i$2 = 0; i$2 < expressions.length; i$2++) this.reinterpretExpressionAsPattern(expressions[i$2]);
											arrow = !0, expr = {
												type: ArrowParameterPlaceHolder,
												params: expressions,
												async: !1
											};
										} else if (this.match("...")) {
											this.context.isBindingElement || this.throwUnexpectedToken(this.lookahead), expressions.push(this.parseRestElement(params)), this.expect(")"), this.match("=>") || this.expect("=>"), this.context.isBindingElement = !1;
											for (var i$2 = 0; i$2 < expressions.length; i$2++) this.reinterpretExpressionAsPattern(expressions[i$2]);
											arrow = !0, expr = {
												type: ArrowParameterPlaceHolder,
												params: expressions,
												async: !1
											};
										} else expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
										if (arrow) break;
									}
									arrow || (expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions)));
								}
								if (!arrow) {
									if (this.expect(")"), this.match("=>") && (expr.type === syntax_1.Syntax.Identifier && expr.name === "yield" && (arrow = !0, expr = {
										type: ArrowParameterPlaceHolder,
										params: [expr],
										async: !1
									}), !arrow)) {
										if (this.context.isBindingElement || this.throwUnexpectedToken(this.lookahead), expr.type === syntax_1.Syntax.SequenceExpression) for (var i$2 = 0; i$2 < expr.expressions.length; i$2++) this.reinterpretExpressionAsPattern(expr.expressions[i$2]);
										else this.reinterpretExpressionAsPattern(expr);
										expr = {
											type: ArrowParameterPlaceHolder,
											params: expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr],
											async: !1
										};
									}
									this.context.isBindingElement = !1;
								}
							}
						}
						return expr;
					}, Parser.prototype.parseArguments = function() {
						this.expect("(");
						var args = [];
						if (!this.match(")")) for (;;) {
							var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
							if (args.push(expr), this.match(")") || (this.expectCommaSeparator(), this.match(")"))) break;
						}
						return this.expect(")"), args;
					}, Parser.prototype.isIdentifierName = function(token) {
						return token.type === 3 || token.type === 4 || token.type === 1 || token.type === 5;
					}, Parser.prototype.parseIdentifierName = function() {
						var node$1 = this.createNode(), token = this.nextToken();
						return this.isIdentifierName(token) || this.throwUnexpectedToken(token), this.finalize(node$1, new Node.Identifier(token.value));
					}, Parser.prototype.parseNewExpression = function() {
						var node$1 = this.createNode(), id = this.parseIdentifierName();
						assert_1.assert(id.name === "new", "New expression must start with `new`");
						var expr;
						if (this.match(".")) if (this.nextToken(), this.lookahead.type === 3 && this.context.inFunctionBody && this.lookahead.value === "target") {
							var property = this.parseIdentifierName();
							expr = new Node.MetaProperty(id, property);
						} else this.throwUnexpectedToken(this.lookahead);
						else {
							var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression), args = this.match("(") ? this.parseArguments() : [];
							expr = new Node.NewExpression(callee, args), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
						}
						return this.finalize(node$1, expr);
					}, Parser.prototype.parseAsyncArgument = function() {
						var arg = this.parseAssignmentExpression();
						return this.context.firstCoverInitializedNameError = null, arg;
					}, Parser.prototype.parseAsyncArguments = function() {
						this.expect("(");
						var args = [];
						if (!this.match(")")) for (;;) {
							var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
							if (args.push(expr), this.match(")") || (this.expectCommaSeparator(), this.match(")"))) break;
						}
						return this.expect(")"), args;
					}, Parser.prototype.parseLeftHandSideExpressionAllowCall = function() {
						var startToken = this.lookahead, maybeAsync = this.matchContextualKeyword("async"), previousAllowIn = this.context.allowIn;
						this.context.allowIn = !0;
						var expr;
						for (this.matchKeyword("super") && this.context.inFunctionBody ? (expr = this.createNode(), this.nextToken(), expr = this.finalize(expr, new Node.Super()), !this.match("(") && !this.match(".") && !this.match("[") && this.throwUnexpectedToken(this.lookahead)) : expr = this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);;) if (this.match(".")) {
							this.context.isBindingElement = !1, this.context.isAssignmentTarget = !0, this.expect(".");
							var property = this.parseIdentifierName();
							expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
						} else if (this.match("(")) {
							var asyncArrow = maybeAsync && startToken.lineNumber === this.lookahead.lineNumber;
							this.context.isBindingElement = !1, this.context.isAssignmentTarget = !1;
							var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
							if (expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args)), asyncArrow && this.match("=>")) {
								for (var i$2 = 0; i$2 < args.length; ++i$2) this.reinterpretExpressionAsPattern(args[i$2]);
								expr = {
									type: ArrowParameterPlaceHolder,
									params: args,
									async: !0
								};
							}
						} else if (this.match("[")) {
							this.context.isBindingElement = !1, this.context.isAssignmentTarget = !0, this.expect("[");
							var property = this.isolateCoverGrammar(this.parseExpression);
							this.expect("]"), expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
						} else if (this.lookahead.type === 10 && this.lookahead.head) {
							var quasi = this.parseTemplateLiteral();
							expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
						} else break;
						return this.context.allowIn = previousAllowIn, expr;
					}, Parser.prototype.parseSuper = function() {
						var node$1 = this.createNode();
						return this.expectKeyword("super"), !this.match("[") && !this.match(".") && this.throwUnexpectedToken(this.lookahead), this.finalize(node$1, new Node.Super());
					}, Parser.prototype.parseLeftHandSideExpression = function() {
						assert_1.assert(this.context.allowIn, "callee of new expression always allow in keyword.");
						for (var node$1 = this.startNode(this.lookahead), expr = this.matchKeyword("super") && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);;) if (this.match("[")) {
							this.context.isBindingElement = !1, this.context.isAssignmentTarget = !0, this.expect("[");
							var property = this.isolateCoverGrammar(this.parseExpression);
							this.expect("]"), expr = this.finalize(node$1, new Node.ComputedMemberExpression(expr, property));
						} else if (this.match(".")) {
							this.context.isBindingElement = !1, this.context.isAssignmentTarget = !0, this.expect(".");
							var property = this.parseIdentifierName();
							expr = this.finalize(node$1, new Node.StaticMemberExpression(expr, property));
						} else if (this.lookahead.type === 10 && this.lookahead.head) {
							var quasi = this.parseTemplateLiteral();
							expr = this.finalize(node$1, new Node.TaggedTemplateExpression(expr, quasi));
						} else break;
						return expr;
					}, Parser.prototype.parseUpdateExpression = function() {
						var expr, startToken = this.lookahead;
						if (this.match("++") || this.match("--")) {
							var node$1 = this.startNode(startToken), token = this.nextToken();
							expr = this.inheritCoverGrammar(this.parseUnaryExpression), this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name) && this.tolerateError(messages_1.Messages.StrictLHSPrefix), this.context.isAssignmentTarget || this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
							var prefix = !0;
							expr = this.finalize(node$1, new Node.UpdateExpression(token.value, expr, prefix)), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
						} else if (expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall), !this.hasLineTerminator && this.lookahead.type === 7 && (this.match("++") || this.match("--"))) {
							this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name) && this.tolerateError(messages_1.Messages.StrictLHSPostfix), this.context.isAssignmentTarget || this.tolerateError(messages_1.Messages.InvalidLHSInAssignment), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
							var operator$1 = this.nextToken().value, prefix = !1;
							expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator$1, expr, prefix));
						}
						return expr;
					}, Parser.prototype.parseAwaitExpression = function() {
						var node$1 = this.createNode();
						this.nextToken();
						var argument = this.parseUnaryExpression();
						return this.finalize(node$1, new Node.AwaitExpression(argument));
					}, Parser.prototype.parseUnaryExpression = function() {
						var expr;
						if (this.match("+") || this.match("-") || this.match("~") || this.match("!") || this.matchKeyword("delete") || this.matchKeyword("void") || this.matchKeyword("typeof")) {
							var node$1 = this.startNode(this.lookahead), token = this.nextToken();
							expr = this.inheritCoverGrammar(this.parseUnaryExpression), expr = this.finalize(node$1, new Node.UnaryExpression(token.value, expr)), this.context.strict && expr.operator === "delete" && expr.argument.type === syntax_1.Syntax.Identifier && this.tolerateError(messages_1.Messages.StrictDelete), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
						} else expr = this.context.await && this.matchContextualKeyword("await") ? this.parseAwaitExpression() : this.parseUpdateExpression();
						return expr;
					}, Parser.prototype.parseExponentiationExpression = function() {
						var startToken = this.lookahead, expr = this.inheritCoverGrammar(this.parseUnaryExpression);
						if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match("**")) {
							this.nextToken(), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
							var left = expr, right = this.isolateCoverGrammar(this.parseExponentiationExpression);
							expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression("**", left, right));
						}
						return expr;
					}, Parser.prototype.binaryPrecedence = function(token) {
						var op = token.value;
						return token.type === 7 ? this.operatorPrecedence[op] || 0 : token.type === 4 && (op === "instanceof" || this.context.allowIn && op === "in") ? 7 : 0;
					}, Parser.prototype.parseBinaryExpression = function() {
						var startToken = this.lookahead, expr = this.inheritCoverGrammar(this.parseExponentiationExpression), token = this.lookahead, prec = this.binaryPrecedence(token);
						if (prec > 0) {
							this.nextToken(), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
							for (var markers = [startToken, this.lookahead], left = expr, right = this.isolateCoverGrammar(this.parseExponentiationExpression), stack = [
								left,
								token.value,
								right
							], precedences = [prec]; prec = this.binaryPrecedence(this.lookahead), !(prec <= 0);) {
								for (; stack.length > 2 && prec <= precedences[precedences.length - 1];) {
									right = stack.pop();
									var operator$1 = stack.pop();
									precedences.pop(), left = stack.pop(), markers.pop();
									var node$1 = this.startNode(markers[markers.length - 1]);
									stack.push(this.finalize(node$1, new Node.BinaryExpression(operator$1, left, right)));
								}
								stack.push(this.nextToken().value), precedences.push(prec), markers.push(this.lookahead), stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
							}
							var i$2 = stack.length - 1;
							expr = stack[i$2];
							for (var lastMarker = markers.pop(); i$2 > 1;) {
								var marker = markers.pop(), lastLineStart = lastMarker && lastMarker.lineStart, node$1 = this.startNode(marker, lastLineStart), operator$1 = stack[i$2 - 1];
								expr = this.finalize(node$1, new Node.BinaryExpression(operator$1, stack[i$2 - 2], expr)), i$2 -= 2, lastMarker = marker;
							}
						}
						return expr;
					}, Parser.prototype.parseConditionalExpression = function() {
						var startToken = this.lookahead, expr = this.inheritCoverGrammar(this.parseBinaryExpression);
						if (this.match("?")) {
							this.nextToken();
							var previousAllowIn = this.context.allowIn;
							this.context.allowIn = !0;
							var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
							this.context.allowIn = previousAllowIn, this.expect(":");
							var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
							expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate)), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
						}
						return expr;
					}, Parser.prototype.checkPatternParam = function(options, param) {
						switch (param.type) {
							case syntax_1.Syntax.Identifier:
								this.validateParam(options, param, param.name);
								break;
							case syntax_1.Syntax.RestElement:
								this.checkPatternParam(options, param.argument);
								break;
							case syntax_1.Syntax.AssignmentPattern:
								this.checkPatternParam(options, param.left);
								break;
							case syntax_1.Syntax.ArrayPattern:
								for (var i$2 = 0; i$2 < param.elements.length; i$2++) param.elements[i$2] !== null && this.checkPatternParam(options, param.elements[i$2]);
								break;
							case syntax_1.Syntax.ObjectPattern:
								for (var i$2 = 0; i$2 < param.properties.length; i$2++) this.checkPatternParam(options, param.properties[i$2].value);
								break;
							default: break;
						}
						options.simple = options.simple && param instanceof Node.Identifier;
					}, Parser.prototype.reinterpretAsCoverFormalsList = function(expr) {
						var params = [expr], options, asyncArrow = !1;
						switch (expr.type) {
							case syntax_1.Syntax.Identifier: break;
							case ArrowParameterPlaceHolder:
								params = expr.params, asyncArrow = expr.async;
								break;
							default: return null;
						}
						options = {
							simple: !0,
							paramSet: {}
						};
						for (var i$2 = 0; i$2 < params.length; ++i$2) {
							var param = params[i$2];
							param.type === syntax_1.Syntax.AssignmentPattern ? param.right.type === syntax_1.Syntax.YieldExpression && (param.right.argument && this.throwUnexpectedToken(this.lookahead), param.right.type = syntax_1.Syntax.Identifier, param.right.name = "yield", delete param.right.argument, delete param.right.delegate) : asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === "await" && this.throwUnexpectedToken(this.lookahead), this.checkPatternParam(options, param), params[i$2] = param;
						}
						if (this.context.strict || !this.context.allowYield) for (var i$2 = 0; i$2 < params.length; ++i$2) {
							var param = params[i$2];
							param.type === syntax_1.Syntax.YieldExpression && this.throwUnexpectedToken(this.lookahead);
						}
						if (options.message === messages_1.Messages.StrictParamDupe) {
							var token = this.context.strict ? options.stricted : options.firstRestricted;
							this.throwUnexpectedToken(token, options.message);
						}
						return {
							simple: options.simple,
							params,
							stricted: options.stricted,
							firstRestricted: options.firstRestricted,
							message: options.message
						};
					}, Parser.prototype.parseAssignmentExpression = function() {
						var expr;
						if (!this.context.allowYield && this.matchKeyword("yield")) expr = this.parseYieldExpression();
						else {
							var startToken = this.lookahead, token = startToken;
							if (expr = this.parseConditionalExpression(), token.type === 3 && token.lineNumber === this.lookahead.lineNumber && token.value === "async" && (this.lookahead.type === 3 || this.matchKeyword("yield"))) {
								var arg = this.parsePrimaryExpression();
								this.reinterpretExpressionAsPattern(arg), expr = {
									type: ArrowParameterPlaceHolder,
									params: [arg],
									async: !0
								};
							}
							if (expr.type === ArrowParameterPlaceHolder || this.match("=>")) {
								this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
								var isAsync = expr.async, list$3 = this.reinterpretAsCoverFormalsList(expr);
								if (list$3) {
									this.hasLineTerminator && this.tolerateUnexpectedToken(this.lookahead), this.context.firstCoverInitializedNameError = null;
									var previousStrict = this.context.strict, previousAllowStrictDirective = this.context.allowStrictDirective;
									this.context.allowStrictDirective = list$3.simple;
									var previousAllowYield = this.context.allowYield, previousAwait = this.context.await;
									this.context.allowYield = !0, this.context.await = isAsync;
									var node$1 = this.startNode(startToken);
									this.expect("=>");
									var body = void 0;
									if (this.match("{")) {
										var previousAllowIn = this.context.allowIn;
										this.context.allowIn = !0, body = this.parseFunctionSourceElements(), this.context.allowIn = previousAllowIn;
									} else body = this.isolateCoverGrammar(this.parseAssignmentExpression);
									var expression = body.type !== syntax_1.Syntax.BlockStatement;
									this.context.strict && list$3.firstRestricted && this.throwUnexpectedToken(list$3.firstRestricted, list$3.message), this.context.strict && list$3.stricted && this.tolerateUnexpectedToken(list$3.stricted, list$3.message), expr = isAsync ? this.finalize(node$1, new Node.AsyncArrowFunctionExpression(list$3.params, body, expression)) : this.finalize(node$1, new Node.ArrowFunctionExpression(list$3.params, body, expression)), this.context.strict = previousStrict, this.context.allowStrictDirective = previousAllowStrictDirective, this.context.allowYield = previousAllowYield, this.context.await = previousAwait;
								}
							} else if (this.matchAssign()) {
								if (this.context.isAssignmentTarget || this.tolerateError(messages_1.Messages.InvalidLHSInAssignment), this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
									var id = expr;
									this.scanner.isRestrictedWord(id.name) && this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment), this.scanner.isStrictModeReservedWord(id.name) && this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
								}
								this.match("=") ? this.reinterpretExpressionAsPattern(expr) : (this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1), token = this.nextToken();
								var operator$1 = token.value, right = this.isolateCoverGrammar(this.parseAssignmentExpression);
								expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator$1, expr, right)), this.context.firstCoverInitializedNameError = null;
							}
						}
						return expr;
					}, Parser.prototype.parseExpression = function() {
						var startToken = this.lookahead, expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
						if (this.match(",")) {
							var expressions = [];
							for (expressions.push(expr); this.lookahead.type !== 2 && this.match(",");) this.nextToken(), expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
							expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
						}
						return expr;
					}, Parser.prototype.parseStatementListItem = function() {
						var statement;
						if (this.context.isAssignmentTarget = !0, this.context.isBindingElement = !0, this.lookahead.type === 4) switch (this.lookahead.value) {
							case "export":
								this.context.isModule || this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration), statement = this.parseExportDeclaration();
								break;
							case "import":
								this.context.isModule || this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration), statement = this.parseImportDeclaration();
								break;
							case "const":
								statement = this.parseLexicalDeclaration({ inFor: !1 });
								break;
							case "function":
								statement = this.parseFunctionDeclaration();
								break;
							case "class":
								statement = this.parseClassDeclaration();
								break;
							case "let":
								statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: !1 }) : this.parseStatement();
								break;
							default:
								statement = this.parseStatement();
								break;
						}
						else statement = this.parseStatement();
						return statement;
					}, Parser.prototype.parseBlock = function() {
						var node$1 = this.createNode();
						this.expect("{");
						for (var block = []; !this.match("}");) block.push(this.parseStatementListItem());
						return this.expect("}"), this.finalize(node$1, new Node.BlockStatement(block));
					}, Parser.prototype.parseLexicalBinding = function(kind, options) {
						var node$1 = this.createNode(), id = this.parsePattern([], kind);
						this.context.strict && id.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(id.name) && this.tolerateError(messages_1.Messages.StrictVarName);
						var init = null;
						return kind === "const" ? !this.matchKeyword("in") && !this.matchContextualKeyword("of") && (this.match("=") ? (this.nextToken(), init = this.isolateCoverGrammar(this.parseAssignmentExpression)) : this.throwError(messages_1.Messages.DeclarationMissingInitializer, "const")) : (!options.inFor && id.type !== syntax_1.Syntax.Identifier || this.match("=")) && (this.expect("="), init = this.isolateCoverGrammar(this.parseAssignmentExpression)), this.finalize(node$1, new Node.VariableDeclarator(id, init));
					}, Parser.prototype.parseBindingList = function(kind, options) {
						for (var list$3 = [this.parseLexicalBinding(kind, options)]; this.match(",");) this.nextToken(), list$3.push(this.parseLexicalBinding(kind, options));
						return list$3;
					}, Parser.prototype.isLexicalDeclaration = function() {
						var state = this.scanner.saveState();
						this.scanner.scanComments();
						var next = this.scanner.lex();
						return this.scanner.restoreState(state), next.type === 3 || next.type === 7 && next.value === "[" || next.type === 7 && next.value === "{" || next.type === 4 && next.value === "let" || next.type === 4 && next.value === "yield";
					}, Parser.prototype.parseLexicalDeclaration = function(options) {
						var node$1 = this.createNode(), kind = this.nextToken().value;
						assert_1.assert(kind === "let" || kind === "const", "Lexical declaration must be either let or const");
						var declarations = this.parseBindingList(kind, options);
						return this.consumeSemicolon(), this.finalize(node$1, new Node.VariableDeclaration(declarations, kind));
					}, Parser.prototype.parseBindingRestElement = function(params, kind) {
						var node$1 = this.createNode();
						this.expect("...");
						var arg = this.parsePattern(params, kind);
						return this.finalize(node$1, new Node.RestElement(arg));
					}, Parser.prototype.parseArrayPattern = function(params, kind) {
						var node$1 = this.createNode();
						this.expect("[");
						for (var elements = []; !this.match("]");) if (this.match(",")) this.nextToken(), elements.push(null);
						else {
							if (this.match("...")) {
								elements.push(this.parseBindingRestElement(params, kind));
								break;
							} else elements.push(this.parsePatternWithDefault(params, kind));
							this.match("]") || this.expect(",");
						}
						return this.expect("]"), this.finalize(node$1, new Node.ArrayPattern(elements));
					}, Parser.prototype.parsePropertyPattern = function(params, kind) {
						var node$1 = this.createNode(), computed = !1, shorthand = !1, method = !1, key, value;
						if (this.lookahead.type === 3) {
							var keyToken = this.lookahead;
							key = this.parseVariableIdentifier();
							var init = this.finalize(node$1, new Node.Identifier(keyToken.value));
							if (this.match("=")) {
								params.push(keyToken), shorthand = !0, this.nextToken();
								var expr = this.parseAssignmentExpression();
								value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
							} else this.match(":") ? (this.expect(":"), value = this.parsePatternWithDefault(params, kind)) : (params.push(keyToken), shorthand = !0, value = init);
						} else computed = this.match("["), key = this.parseObjectPropertyKey(), this.expect(":"), value = this.parsePatternWithDefault(params, kind);
						return this.finalize(node$1, new Node.Property("init", key, computed, value, method, shorthand));
					}, Parser.prototype.parseObjectPattern = function(params, kind) {
						var node$1 = this.createNode(), properties = [];
						for (this.expect("{"); !this.match("}");) properties.push(this.parsePropertyPattern(params, kind)), this.match("}") || this.expect(",");
						return this.expect("}"), this.finalize(node$1, new Node.ObjectPattern(properties));
					}, Parser.prototype.parsePattern = function(params, kind) {
						var pattern;
						return this.match("[") ? pattern = this.parseArrayPattern(params, kind) : this.match("{") ? pattern = this.parseObjectPattern(params, kind) : (this.matchKeyword("let") && (kind === "const" || kind === "let") && this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding), params.push(this.lookahead), pattern = this.parseVariableIdentifier(kind)), pattern;
					}, Parser.prototype.parsePatternWithDefault = function(params, kind) {
						var startToken = this.lookahead, pattern = this.parsePattern(params, kind);
						if (this.match("=")) {
							this.nextToken();
							var previousAllowYield = this.context.allowYield;
							this.context.allowYield = !0;
							var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
							this.context.allowYield = previousAllowYield, pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
						}
						return pattern;
					}, Parser.prototype.parseVariableIdentifier = function(kind) {
						var node$1 = this.createNode(), token = this.nextToken();
						return token.type === 4 && token.value === "yield" ? this.context.strict ? this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord) : this.context.allowYield || this.throwUnexpectedToken(token) : token.type === 3 ? (this.context.isModule || this.context.await) && token.type === 3 && token.value === "await" && this.tolerateUnexpectedToken(token) : this.context.strict && token.type === 4 && this.scanner.isStrictModeReservedWord(token.value) ? this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord) : (this.context.strict || token.value !== "let" || kind !== "var") && this.throwUnexpectedToken(token), this.finalize(node$1, new Node.Identifier(token.value));
					}, Parser.prototype.parseVariableDeclaration = function(options) {
						var node$1 = this.createNode(), id = this.parsePattern([], "var");
						this.context.strict && id.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(id.name) && this.tolerateError(messages_1.Messages.StrictVarName);
						var init = null;
						return this.match("=") ? (this.nextToken(), init = this.isolateCoverGrammar(this.parseAssignmentExpression)) : id.type !== syntax_1.Syntax.Identifier && !options.inFor && this.expect("="), this.finalize(node$1, new Node.VariableDeclarator(id, init));
					}, Parser.prototype.parseVariableDeclarationList = function(options) {
						var opt = { inFor: options.inFor }, list$3 = [];
						for (list$3.push(this.parseVariableDeclaration(opt)); this.match(",");) this.nextToken(), list$3.push(this.parseVariableDeclaration(opt));
						return list$3;
					}, Parser.prototype.parseVariableStatement = function() {
						var node$1 = this.createNode();
						this.expectKeyword("var");
						var declarations = this.parseVariableDeclarationList({ inFor: !1 });
						return this.consumeSemicolon(), this.finalize(node$1, new Node.VariableDeclaration(declarations, "var"));
					}, Parser.prototype.parseEmptyStatement = function() {
						var node$1 = this.createNode();
						return this.expect(";"), this.finalize(node$1, new Node.EmptyStatement());
					}, Parser.prototype.parseExpressionStatement = function() {
						var node$1 = this.createNode(), expr = this.parseExpression();
						return this.consumeSemicolon(), this.finalize(node$1, new Node.ExpressionStatement(expr));
					}, Parser.prototype.parseIfClause = function() {
						return this.context.strict && this.matchKeyword("function") && this.tolerateError(messages_1.Messages.StrictFunction), this.parseStatement();
					}, Parser.prototype.parseIfStatement = function() {
						var node$1 = this.createNode(), consequent, alternate = null;
						this.expectKeyword("if"), this.expect("(");
						var test = this.parseExpression();
						return !this.match(")") && this.config.tolerant ? (this.tolerateUnexpectedToken(this.nextToken()), consequent = this.finalize(this.createNode(), new Node.EmptyStatement())) : (this.expect(")"), consequent = this.parseIfClause(), this.matchKeyword("else") && (this.nextToken(), alternate = this.parseIfClause())), this.finalize(node$1, new Node.IfStatement(test, consequent, alternate));
					}, Parser.prototype.parseDoWhileStatement = function() {
						var node$1 = this.createNode();
						this.expectKeyword("do");
						var previousInIteration = this.context.inIteration;
						this.context.inIteration = !0;
						var body = this.parseStatement();
						this.context.inIteration = previousInIteration, this.expectKeyword("while"), this.expect("(");
						var test = this.parseExpression();
						return !this.match(")") && this.config.tolerant ? this.tolerateUnexpectedToken(this.nextToken()) : (this.expect(")"), this.match(";") && this.nextToken()), this.finalize(node$1, new Node.DoWhileStatement(body, test));
					}, Parser.prototype.parseWhileStatement = function() {
						var node$1 = this.createNode(), body;
						this.expectKeyword("while"), this.expect("(");
						var test = this.parseExpression();
						if (!this.match(")") && this.config.tolerant) this.tolerateUnexpectedToken(this.nextToken()), body = this.finalize(this.createNode(), new Node.EmptyStatement());
						else {
							this.expect(")");
							var previousInIteration = this.context.inIteration;
							this.context.inIteration = !0, body = this.parseStatement(), this.context.inIteration = previousInIteration;
						}
						return this.finalize(node$1, new Node.WhileStatement(test, body));
					}, Parser.prototype.parseForStatement = function() {
						var init = null, test = null, update = null, forIn = !0, left, right, node$1 = this.createNode();
						if (this.expectKeyword("for"), this.expect("("), this.match(";")) this.nextToken();
						else if (this.matchKeyword("var")) {
							init = this.createNode(), this.nextToken();
							var previousAllowIn = this.context.allowIn;
							this.context.allowIn = !1;
							var declarations = this.parseVariableDeclarationList({ inFor: !0 });
							if (this.context.allowIn = previousAllowIn, declarations.length === 1 && this.matchKeyword("in")) {
								var decl = declarations[0];
								decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict) && this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, "for-in"), init = this.finalize(init, new Node.VariableDeclaration(declarations, "var")), this.nextToken(), left = init, right = this.parseExpression(), init = null;
							} else declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of") ? (init = this.finalize(init, new Node.VariableDeclaration(declarations, "var")), this.nextToken(), left = init, right = this.parseAssignmentExpression(), init = null, forIn = !1) : (init = this.finalize(init, new Node.VariableDeclaration(declarations, "var")), this.expect(";"));
						} else if (this.matchKeyword("const") || this.matchKeyword("let")) {
							init = this.createNode();
							var kind = this.nextToken().value;
							if (!this.context.strict && this.lookahead.value === "in") init = this.finalize(init, new Node.Identifier(kind)), this.nextToken(), left = init, right = this.parseExpression(), init = null;
							else {
								var previousAllowIn = this.context.allowIn;
								this.context.allowIn = !1;
								var declarations = this.parseBindingList(kind, { inFor: !0 });
								this.context.allowIn = previousAllowIn, declarations.length === 1 && declarations[0].init === null && this.matchKeyword("in") ? (init = this.finalize(init, new Node.VariableDeclaration(declarations, kind)), this.nextToken(), left = init, right = this.parseExpression(), init = null) : declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of") ? (init = this.finalize(init, new Node.VariableDeclaration(declarations, kind)), this.nextToken(), left = init, right = this.parseAssignmentExpression(), init = null, forIn = !1) : (this.consumeSemicolon(), init = this.finalize(init, new Node.VariableDeclaration(declarations, kind)));
							}
						} else {
							var initStartToken = this.lookahead, previousAllowIn = this.context.allowIn;
							if (this.context.allowIn = !1, init = this.inheritCoverGrammar(this.parseAssignmentExpression), this.context.allowIn = previousAllowIn, this.matchKeyword("in")) (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) && this.tolerateError(messages_1.Messages.InvalidLHSInForIn), this.nextToken(), this.reinterpretExpressionAsPattern(init), left = init, right = this.parseExpression(), init = null;
							else if (this.matchContextualKeyword("of")) (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) && this.tolerateError(messages_1.Messages.InvalidLHSInForLoop), this.nextToken(), this.reinterpretExpressionAsPattern(init), left = init, right = this.parseAssignmentExpression(), init = null, forIn = !1;
							else {
								if (this.match(",")) {
									for (var initSeq = [init]; this.match(",");) this.nextToken(), initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
									init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
								}
								this.expect(";");
							}
						}
						left === void 0 && (this.match(";") || (test = this.parseExpression()), this.expect(";"), this.match(")") || (update = this.parseExpression()));
						var body;
						if (!this.match(")") && this.config.tolerant) this.tolerateUnexpectedToken(this.nextToken()), body = this.finalize(this.createNode(), new Node.EmptyStatement());
						else {
							this.expect(")");
							var previousInIteration = this.context.inIteration;
							this.context.inIteration = !0, body = this.isolateCoverGrammar(this.parseStatement), this.context.inIteration = previousInIteration;
						}
						return left === void 0 ? this.finalize(node$1, new Node.ForStatement(init, test, update, body)) : forIn ? this.finalize(node$1, new Node.ForInStatement(left, right, body)) : this.finalize(node$1, new Node.ForOfStatement(left, right, body));
					}, Parser.prototype.parseContinueStatement = function() {
						var node$1 = this.createNode();
						this.expectKeyword("continue");
						var label = null;
						if (this.lookahead.type === 3 && !this.hasLineTerminator) {
							var id = this.parseVariableIdentifier();
							label = id;
							var key = "$" + id.name;
							Object.prototype.hasOwnProperty.call(this.context.labelSet, key) || this.throwError(messages_1.Messages.UnknownLabel, id.name);
						}
						return this.consumeSemicolon(), label === null && !this.context.inIteration && this.throwError(messages_1.Messages.IllegalContinue), this.finalize(node$1, new Node.ContinueStatement(label));
					}, Parser.prototype.parseBreakStatement = function() {
						var node$1 = this.createNode();
						this.expectKeyword("break");
						var label = null;
						if (this.lookahead.type === 3 && !this.hasLineTerminator) {
							var id = this.parseVariableIdentifier(), key = "$" + id.name;
							Object.prototype.hasOwnProperty.call(this.context.labelSet, key) || this.throwError(messages_1.Messages.UnknownLabel, id.name), label = id;
						}
						return this.consumeSemicolon(), label === null && !this.context.inIteration && !this.context.inSwitch && this.throwError(messages_1.Messages.IllegalBreak), this.finalize(node$1, new Node.BreakStatement(label));
					}, Parser.prototype.parseReturnStatement = function() {
						this.context.inFunctionBody || this.tolerateError(messages_1.Messages.IllegalReturn);
						var node$1 = this.createNode();
						this.expectKeyword("return");
						var argument = !this.match(";") && !this.match("}") && !this.hasLineTerminator && this.lookahead.type !== 2 || this.lookahead.type === 8 || this.lookahead.type === 10 ? this.parseExpression() : null;
						return this.consumeSemicolon(), this.finalize(node$1, new Node.ReturnStatement(argument));
					}, Parser.prototype.parseWithStatement = function() {
						this.context.strict && this.tolerateError(messages_1.Messages.StrictModeWith);
						var node$1 = this.createNode(), body;
						this.expectKeyword("with"), this.expect("(");
						var object = this.parseExpression();
						return !this.match(")") && this.config.tolerant ? (this.tolerateUnexpectedToken(this.nextToken()), body = this.finalize(this.createNode(), new Node.EmptyStatement())) : (this.expect(")"), body = this.parseStatement()), this.finalize(node$1, new Node.WithStatement(object, body));
					}, Parser.prototype.parseSwitchCase = function() {
						var node$1 = this.createNode(), test;
						this.matchKeyword("default") ? (this.nextToken(), test = null) : (this.expectKeyword("case"), test = this.parseExpression()), this.expect(":");
						for (var consequent = []; !(this.match("}") || this.matchKeyword("default") || this.matchKeyword("case"));) consequent.push(this.parseStatementListItem());
						return this.finalize(node$1, new Node.SwitchCase(test, consequent));
					}, Parser.prototype.parseSwitchStatement = function() {
						var node$1 = this.createNode();
						this.expectKeyword("switch"), this.expect("(");
						var discriminant = this.parseExpression();
						this.expect(")");
						var previousInSwitch = this.context.inSwitch;
						this.context.inSwitch = !0;
						var cases = [], defaultFound = !1;
						for (this.expect("{"); !this.match("}");) {
							var clause = this.parseSwitchCase();
							clause.test === null && (defaultFound && this.throwError(messages_1.Messages.MultipleDefaultsInSwitch), defaultFound = !0), cases.push(clause);
						}
						return this.expect("}"), this.context.inSwitch = previousInSwitch, this.finalize(node$1, new Node.SwitchStatement(discriminant, cases));
					}, Parser.prototype.parseLabelledStatement = function() {
						var node$1 = this.createNode(), expr = this.parseExpression(), statement;
						if (expr.type === syntax_1.Syntax.Identifier && this.match(":")) {
							this.nextToken();
							var id = expr, key = "$" + id.name;
							Object.prototype.hasOwnProperty.call(this.context.labelSet, key) && this.throwError(messages_1.Messages.Redeclaration, "Label", id.name), this.context.labelSet[key] = !0;
							var body = void 0;
							if (this.matchKeyword("class")) this.tolerateUnexpectedToken(this.lookahead), body = this.parseClassDeclaration();
							else if (this.matchKeyword("function")) {
								var token = this.lookahead, declaration = this.parseFunctionDeclaration();
								this.context.strict ? this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction) : declaration.generator && this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext), body = declaration;
							} else body = this.parseStatement();
							delete this.context.labelSet[key], statement = new Node.LabeledStatement(id, body);
						} else this.consumeSemicolon(), statement = new Node.ExpressionStatement(expr);
						return this.finalize(node$1, statement);
					}, Parser.prototype.parseThrowStatement = function() {
						var node$1 = this.createNode();
						this.expectKeyword("throw"), this.hasLineTerminator && this.throwError(messages_1.Messages.NewlineAfterThrow);
						var argument = this.parseExpression();
						return this.consumeSemicolon(), this.finalize(node$1, new Node.ThrowStatement(argument));
					}, Parser.prototype.parseCatchClause = function() {
						var node$1 = this.createNode();
						this.expectKeyword("catch"), this.expect("("), this.match(")") && this.throwUnexpectedToken(this.lookahead);
						for (var params = [], param = this.parsePattern(params), paramMap = {}, i$2 = 0; i$2 < params.length; i$2++) {
							var key = "$" + params[i$2].value;
							Object.prototype.hasOwnProperty.call(paramMap, key) && this.tolerateError(messages_1.Messages.DuplicateBinding, params[i$2].value), paramMap[key] = !0;
						}
						this.context.strict && param.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(param.name) && this.tolerateError(messages_1.Messages.StrictCatchVariable), this.expect(")");
						var body = this.parseBlock();
						return this.finalize(node$1, new Node.CatchClause(param, body));
					}, Parser.prototype.parseFinallyClause = function() {
						return this.expectKeyword("finally"), this.parseBlock();
					}, Parser.prototype.parseTryStatement = function() {
						var node$1 = this.createNode();
						this.expectKeyword("try");
						var block = this.parseBlock(), handler = this.matchKeyword("catch") ? this.parseCatchClause() : null, finalizer = this.matchKeyword("finally") ? this.parseFinallyClause() : null;
						return !handler && !finalizer && this.throwError(messages_1.Messages.NoCatchOrFinally), this.finalize(node$1, new Node.TryStatement(block, handler, finalizer));
					}, Parser.prototype.parseDebuggerStatement = function() {
						var node$1 = this.createNode();
						return this.expectKeyword("debugger"), this.consumeSemicolon(), this.finalize(node$1, new Node.DebuggerStatement());
					}, Parser.prototype.parseStatement = function() {
						var statement;
						switch (this.lookahead.type) {
							case 1:
							case 5:
							case 6:
							case 8:
							case 10:
							case 9:
								statement = this.parseExpressionStatement();
								break;
							case 7:
								var value = this.lookahead.value;
								statement = value === "{" ? this.parseBlock() : value === "(" ? this.parseExpressionStatement() : value === ";" ? this.parseEmptyStatement() : this.parseExpressionStatement();
								break;
							case 3:
								statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
								break;
							case 4:
								switch (this.lookahead.value) {
									case "break":
										statement = this.parseBreakStatement();
										break;
									case "continue":
										statement = this.parseContinueStatement();
										break;
									case "debugger":
										statement = this.parseDebuggerStatement();
										break;
									case "do":
										statement = this.parseDoWhileStatement();
										break;
									case "for":
										statement = this.parseForStatement();
										break;
									case "function":
										statement = this.parseFunctionDeclaration();
										break;
									case "if":
										statement = this.parseIfStatement();
										break;
									case "return":
										statement = this.parseReturnStatement();
										break;
									case "switch":
										statement = this.parseSwitchStatement();
										break;
									case "throw":
										statement = this.parseThrowStatement();
										break;
									case "try":
										statement = this.parseTryStatement();
										break;
									case "var":
										statement = this.parseVariableStatement();
										break;
									case "while":
										statement = this.parseWhileStatement();
										break;
									case "with":
										statement = this.parseWithStatement();
										break;
									default:
										statement = this.parseExpressionStatement();
										break;
								}
								break;
							default: statement = this.throwUnexpectedToken(this.lookahead);
						}
						return statement;
					}, Parser.prototype.parseFunctionSourceElements = function() {
						var node$1 = this.createNode();
						this.expect("{");
						var body = this.parseDirectivePrologues(), previousLabelSet = this.context.labelSet, previousInIteration = this.context.inIteration, previousInSwitch = this.context.inSwitch, previousInFunctionBody = this.context.inFunctionBody;
						for (this.context.labelSet = {}, this.context.inIteration = !1, this.context.inSwitch = !1, this.context.inFunctionBody = !0; this.lookahead.type !== 2 && !this.match("}");) body.push(this.parseStatementListItem());
						return this.expect("}"), this.context.labelSet = previousLabelSet, this.context.inIteration = previousInIteration, this.context.inSwitch = previousInSwitch, this.context.inFunctionBody = previousInFunctionBody, this.finalize(node$1, new Node.BlockStatement(body));
					}, Parser.prototype.validateParam = function(options, param, name$1) {
						var key = "$" + name$1;
						/* istanbul ignore next */
						this.context.strict ? (this.scanner.isRestrictedWord(name$1) && (options.stricted = param, options.message = messages_1.Messages.StrictParamName), Object.prototype.hasOwnProperty.call(options.paramSet, key) && (options.stricted = param, options.message = messages_1.Messages.StrictParamDupe)) : options.firstRestricted || (this.scanner.isRestrictedWord(name$1) ? (options.firstRestricted = param, options.message = messages_1.Messages.StrictParamName) : this.scanner.isStrictModeReservedWord(name$1) ? (options.firstRestricted = param, options.message = messages_1.Messages.StrictReservedWord) : Object.prototype.hasOwnProperty.call(options.paramSet, key) && (options.stricted = param, options.message = messages_1.Messages.StrictParamDupe)), typeof Object.defineProperty == "function" ? Object.defineProperty(options.paramSet, key, {
							value: !0,
							enumerable: !0,
							writable: !0,
							configurable: !0
						}) : options.paramSet[key] = !0;
					}, Parser.prototype.parseRestElement = function(params) {
						var node$1 = this.createNode();
						this.expect("...");
						var arg = this.parsePattern(params);
						return this.match("=") && this.throwError(messages_1.Messages.DefaultRestParameter), this.match(")") || this.throwError(messages_1.Messages.ParameterAfterRestParameter), this.finalize(node$1, new Node.RestElement(arg));
					}, Parser.prototype.parseFormalParameter = function(options) {
						for (var params = [], param = this.match("...") ? this.parseRestElement(params) : this.parsePatternWithDefault(params), i$2 = 0; i$2 < params.length; i$2++) this.validateParam(options, params[i$2], params[i$2].value);
						options.simple = options.simple && param instanceof Node.Identifier, options.params.push(param);
					}, Parser.prototype.parseFormalParameters = function(firstRestricted) {
						var options = {
							simple: !0,
							params: [],
							firstRestricted
						};
						if (this.expect("("), !this.match(")")) for (options.paramSet = {}; this.lookahead.type !== 2 && (this.parseFormalParameter(options), !(this.match(")") || (this.expect(","), this.match(")")))););
						return this.expect(")"), {
							simple: options.simple,
							params: options.params,
							stricted: options.stricted,
							firstRestricted: options.firstRestricted,
							message: options.message
						};
					}, Parser.prototype.matchAsyncFunction = function() {
						var match = this.matchContextualKeyword("async");
						if (match) {
							var state = this.scanner.saveState();
							this.scanner.scanComments();
							var next = this.scanner.lex();
							this.scanner.restoreState(state), match = state.lineNumber === next.lineNumber && next.type === 4 && next.value === "function";
						}
						return match;
					}, Parser.prototype.parseFunctionDeclaration = function(identifierIsOptional) {
						var node$1 = this.createNode(), isAsync = this.matchContextualKeyword("async");
						isAsync && this.nextToken(), this.expectKeyword("function");
						var isGenerator = isAsync ? !1 : this.match("*");
						isGenerator && this.nextToken();
						var message, id = null, firstRestricted = null;
						if (!identifierIsOptional || !this.match("(")) {
							var token = this.lookahead;
							id = this.parseVariableIdentifier(), this.context.strict ? this.scanner.isRestrictedWord(token.value) && this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName) : this.scanner.isRestrictedWord(token.value) ? (firstRestricted = token, message = messages_1.Messages.StrictFunctionName) : this.scanner.isStrictModeReservedWord(token.value) && (firstRestricted = token, message = messages_1.Messages.StrictReservedWord);
						}
						var previousAllowAwait = this.context.await, previousAllowYield = this.context.allowYield;
						this.context.await = isAsync, this.context.allowYield = !isGenerator;
						var formalParameters = this.parseFormalParameters(firstRestricted), params = formalParameters.params, stricted = formalParameters.stricted;
						firstRestricted = formalParameters.firstRestricted, formalParameters.message && (message = formalParameters.message);
						var previousStrict = this.context.strict, previousAllowStrictDirective = this.context.allowStrictDirective;
						this.context.allowStrictDirective = formalParameters.simple;
						var body = this.parseFunctionSourceElements();
						return this.context.strict && firstRestricted && this.throwUnexpectedToken(firstRestricted, message), this.context.strict && stricted && this.tolerateUnexpectedToken(stricted, message), this.context.strict = previousStrict, this.context.allowStrictDirective = previousAllowStrictDirective, this.context.await = previousAllowAwait, this.context.allowYield = previousAllowYield, isAsync ? this.finalize(node$1, new Node.AsyncFunctionDeclaration(id, params, body)) : this.finalize(node$1, new Node.FunctionDeclaration(id, params, body, isGenerator));
					}, Parser.prototype.parseFunctionExpression = function() {
						var node$1 = this.createNode(), isAsync = this.matchContextualKeyword("async");
						isAsync && this.nextToken(), this.expectKeyword("function");
						var isGenerator = isAsync ? !1 : this.match("*");
						isGenerator && this.nextToken();
						var message, id = null, firstRestricted, previousAllowAwait = this.context.await, previousAllowYield = this.context.allowYield;
						if (this.context.await = isAsync, this.context.allowYield = !isGenerator, !this.match("(")) {
							var token = this.lookahead;
							id = !this.context.strict && !isGenerator && this.matchKeyword("yield") ? this.parseIdentifierName() : this.parseVariableIdentifier(), this.context.strict ? this.scanner.isRestrictedWord(token.value) && this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName) : this.scanner.isRestrictedWord(token.value) ? (firstRestricted = token, message = messages_1.Messages.StrictFunctionName) : this.scanner.isStrictModeReservedWord(token.value) && (firstRestricted = token, message = messages_1.Messages.StrictReservedWord);
						}
						var formalParameters = this.parseFormalParameters(firstRestricted), params = formalParameters.params, stricted = formalParameters.stricted;
						firstRestricted = formalParameters.firstRestricted, formalParameters.message && (message = formalParameters.message);
						var previousStrict = this.context.strict, previousAllowStrictDirective = this.context.allowStrictDirective;
						this.context.allowStrictDirective = formalParameters.simple;
						var body = this.parseFunctionSourceElements();
						return this.context.strict && firstRestricted && this.throwUnexpectedToken(firstRestricted, message), this.context.strict && stricted && this.tolerateUnexpectedToken(stricted, message), this.context.strict = previousStrict, this.context.allowStrictDirective = previousAllowStrictDirective, this.context.await = previousAllowAwait, this.context.allowYield = previousAllowYield, isAsync ? this.finalize(node$1, new Node.AsyncFunctionExpression(id, params, body)) : this.finalize(node$1, new Node.FunctionExpression(id, params, body, isGenerator));
					}, Parser.prototype.parseDirective = function() {
						var token = this.lookahead, node$1 = this.createNode(), expr = this.parseExpression(), directive = expr.type === syntax_1.Syntax.Literal ? this.getTokenRaw(token).slice(1, -1) : null;
						return this.consumeSemicolon(), this.finalize(node$1, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
					}, Parser.prototype.parseDirectivePrologues = function() {
						for (var firstRestricted = null, body = [];;) {
							var token = this.lookahead;
							if (token.type !== 8) break;
							var statement = this.parseDirective();
							body.push(statement);
							var directive = statement.directive;
							if (typeof directive != "string") break;
							directive === "use strict" ? (this.context.strict = !0, firstRestricted && this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral), this.context.allowStrictDirective || this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective)) : !firstRestricted && token.octal && (firstRestricted = token);
						}
						return body;
					}, Parser.prototype.qualifiedPropertyName = function(token) {
						switch (token.type) {
							case 3:
							case 8:
							case 1:
							case 5:
							case 6:
							case 4: return !0;
							case 7: return token.value === "[";
							default: break;
						}
						return !1;
					}, Parser.prototype.parseGetterMethod = function() {
						var node$1 = this.createNode(), isGenerator = !1, previousAllowYield = this.context.allowYield;
						this.context.allowYield = !isGenerator;
						var formalParameters = this.parseFormalParameters();
						formalParameters.params.length > 0 && this.tolerateError(messages_1.Messages.BadGetterArity);
						var method = this.parsePropertyMethod(formalParameters);
						return this.context.allowYield = previousAllowYield, this.finalize(node$1, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
					}, Parser.prototype.parseSetterMethod = function() {
						var node$1 = this.createNode(), isGenerator = !1, previousAllowYield = this.context.allowYield;
						this.context.allowYield = !isGenerator;
						var formalParameters = this.parseFormalParameters();
						formalParameters.params.length === 1 ? formalParameters.params[0] instanceof Node.RestElement && this.tolerateError(messages_1.Messages.BadSetterRestParameter) : this.tolerateError(messages_1.Messages.BadSetterArity);
						var method = this.parsePropertyMethod(formalParameters);
						return this.context.allowYield = previousAllowYield, this.finalize(node$1, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
					}, Parser.prototype.parseGeneratorMethod = function() {
						var node$1 = this.createNode(), isGenerator = !0, previousAllowYield = this.context.allowYield;
						this.context.allowYield = !0;
						var params = this.parseFormalParameters();
						this.context.allowYield = !1;
						var method = this.parsePropertyMethod(params);
						return this.context.allowYield = previousAllowYield, this.finalize(node$1, new Node.FunctionExpression(null, params.params, method, isGenerator));
					}, Parser.prototype.isStartOfExpression = function() {
						var start = !0, value = this.lookahead.value;
						switch (this.lookahead.type) {
							case 7:
								start = value === "[" || value === "(" || value === "{" || value === "+" || value === "-" || value === "!" || value === "~" || value === "++" || value === "--" || value === "/" || value === "/=";
								break;
							case 4:
								start = value === "class" || value === "delete" || value === "function" || value === "let" || value === "new" || value === "super" || value === "this" || value === "typeof" || value === "void" || value === "yield";
								break;
							default: break;
						}
						return start;
					}, Parser.prototype.parseYieldExpression = function() {
						var node$1 = this.createNode();
						this.expectKeyword("yield");
						var argument = null, delegate = !1;
						if (!this.hasLineTerminator) {
							var previousAllowYield = this.context.allowYield;
							this.context.allowYield = !1, delegate = this.match("*"), delegate ? (this.nextToken(), argument = this.parseAssignmentExpression()) : this.isStartOfExpression() && (argument = this.parseAssignmentExpression()), this.context.allowYield = previousAllowYield;
						}
						return this.finalize(node$1, new Node.YieldExpression(argument, delegate));
					}, Parser.prototype.parseClassElement = function(hasConstructor) {
						var token = this.lookahead, node$1 = this.createNode(), kind = "", key = null, value = null, computed = !1, method = !1, isStatic = !1, isAsync = !1;
						if (this.match("*")) this.nextToken();
						else if (computed = this.match("["), key = this.parseObjectPropertyKey(), key.name === "static" && (this.qualifiedPropertyName(this.lookahead) || this.match("*")) && (token = this.lookahead, isStatic = !0, computed = this.match("["), this.match("*") ? this.nextToken() : key = this.parseObjectPropertyKey()), token.type === 3 && !this.hasLineTerminator && token.value === "async") {
							var punctuator = this.lookahead.value;
							punctuator !== ":" && punctuator !== "(" && punctuator !== "*" && (isAsync = !0, token = this.lookahead, key = this.parseObjectPropertyKey(), token.type === 3 && token.value === "constructor" && this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync));
						}
						var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
						return token.type === 3 ? token.value === "get" && lookaheadPropertyKey ? (kind = "get", computed = this.match("["), key = this.parseObjectPropertyKey(), this.context.allowYield = !1, value = this.parseGetterMethod()) : token.value === "set" && lookaheadPropertyKey && (kind = "set", computed = this.match("["), key = this.parseObjectPropertyKey(), value = this.parseSetterMethod()) : token.type === 7 && token.value === "*" && lookaheadPropertyKey && (kind = "init", computed = this.match("["), key = this.parseObjectPropertyKey(), value = this.parseGeneratorMethod(), method = !0), !kind && key && this.match("(") && (kind = "init", value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction(), method = !0), kind || this.throwUnexpectedToken(this.lookahead), kind === "init" && (kind = "method"), computed || (isStatic && this.isPropertyKey(key, "prototype") && this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype), !isStatic && this.isPropertyKey(key, "constructor") && ((kind !== "method" || !method || value && value.generator) && this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod), hasConstructor.value ? this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor) : hasConstructor.value = !0, kind = "constructor")), this.finalize(node$1, new Node.MethodDefinition(key, computed, value, kind, isStatic));
					}, Parser.prototype.parseClassElementList = function() {
						var body = [], hasConstructor = { value: !1 };
						for (this.expect("{"); !this.match("}");) this.match(";") ? this.nextToken() : body.push(this.parseClassElement(hasConstructor));
						return this.expect("}"), body;
					}, Parser.prototype.parseClassBody = function() {
						var node$1 = this.createNode(), elementList = this.parseClassElementList();
						return this.finalize(node$1, new Node.ClassBody(elementList));
					}, Parser.prototype.parseClassDeclaration = function(identifierIsOptional) {
						var node$1 = this.createNode(), previousStrict = this.context.strict;
						this.context.strict = !0, this.expectKeyword("class");
						var id = identifierIsOptional && this.lookahead.type !== 3 ? null : this.parseVariableIdentifier(), superClass = null;
						this.matchKeyword("extends") && (this.nextToken(), superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall));
						var classBody = this.parseClassBody();
						return this.context.strict = previousStrict, this.finalize(node$1, new Node.ClassDeclaration(id, superClass, classBody));
					}, Parser.prototype.parseClassExpression = function() {
						var node$1 = this.createNode(), previousStrict = this.context.strict;
						this.context.strict = !0, this.expectKeyword("class");
						var id = this.lookahead.type === 3 ? this.parseVariableIdentifier() : null, superClass = null;
						this.matchKeyword("extends") && (this.nextToken(), superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall));
						var classBody = this.parseClassBody();
						return this.context.strict = previousStrict, this.finalize(node$1, new Node.ClassExpression(id, superClass, classBody));
					}, Parser.prototype.parseModule = function() {
						this.context.strict = !0, this.context.isModule = !0, this.scanner.isModule = !0;
						for (var node$1 = this.createNode(), body = this.parseDirectivePrologues(); this.lookahead.type !== 2;) body.push(this.parseStatementListItem());
						return this.finalize(node$1, new Node.Module(body));
					}, Parser.prototype.parseScript = function() {
						for (var node$1 = this.createNode(), body = this.parseDirectivePrologues(); this.lookahead.type !== 2;) body.push(this.parseStatementListItem());
						return this.finalize(node$1, new Node.Script(body));
					}, Parser.prototype.parseModuleSpecifier = function() {
						var node$1 = this.createNode();
						this.lookahead.type !== 8 && this.throwError(messages_1.Messages.InvalidModuleSpecifier);
						var token = this.nextToken(), raw = this.getTokenRaw(token);
						return this.finalize(node$1, new Node.Literal(token.value, raw));
					}, Parser.prototype.parseImportSpecifier = function() {
						var node$1 = this.createNode(), imported, local;
						return this.lookahead.type === 3 ? (imported = this.parseVariableIdentifier(), local = imported, this.matchContextualKeyword("as") && (this.nextToken(), local = this.parseVariableIdentifier())) : (imported = this.parseIdentifierName(), local = imported, this.matchContextualKeyword("as") ? (this.nextToken(), local = this.parseVariableIdentifier()) : this.throwUnexpectedToken(this.nextToken())), this.finalize(node$1, new Node.ImportSpecifier(local, imported));
					}, Parser.prototype.parseNamedImports = function() {
						this.expect("{");
						for (var specifiers = []; !this.match("}");) specifiers.push(this.parseImportSpecifier()), this.match("}") || this.expect(",");
						return this.expect("}"), specifiers;
					}, Parser.prototype.parseImportDefaultSpecifier = function() {
						var node$1 = this.createNode(), local = this.parseIdentifierName();
						return this.finalize(node$1, new Node.ImportDefaultSpecifier(local));
					}, Parser.prototype.parseImportNamespaceSpecifier = function() {
						var node$1 = this.createNode();
						this.expect("*"), this.matchContextualKeyword("as") || this.throwError(messages_1.Messages.NoAsAfterImportNamespace), this.nextToken();
						var local = this.parseIdentifierName();
						return this.finalize(node$1, new Node.ImportNamespaceSpecifier(local));
					}, Parser.prototype.parseImportDeclaration = function() {
						this.context.inFunctionBody && this.throwError(messages_1.Messages.IllegalImportDeclaration);
						var node$1 = this.createNode();
						this.expectKeyword("import");
						var src, specifiers = [];
						if (this.lookahead.type === 8) src = this.parseModuleSpecifier();
						else {
							if (this.match("{") ? specifiers = specifiers.concat(this.parseNamedImports()) : this.match("*") ? specifiers.push(this.parseImportNamespaceSpecifier()) : this.isIdentifierName(this.lookahead) && !this.matchKeyword("default") ? (specifiers.push(this.parseImportDefaultSpecifier()), this.match(",") && (this.nextToken(), this.match("*") ? specifiers.push(this.parseImportNamespaceSpecifier()) : this.match("{") ? specifiers = specifiers.concat(this.parseNamedImports()) : this.throwUnexpectedToken(this.lookahead))) : this.throwUnexpectedToken(this.nextToken()), !this.matchContextualKeyword("from")) {
								var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
								this.throwError(message, this.lookahead.value);
							}
							this.nextToken(), src = this.parseModuleSpecifier();
						}
						return this.consumeSemicolon(), this.finalize(node$1, new Node.ImportDeclaration(specifiers, src));
					}, Parser.prototype.parseExportSpecifier = function() {
						var node$1 = this.createNode(), local = this.parseIdentifierName(), exported = local;
						return this.matchContextualKeyword("as") && (this.nextToken(), exported = this.parseIdentifierName()), this.finalize(node$1, new Node.ExportSpecifier(local, exported));
					}, Parser.prototype.parseExportDeclaration = function() {
						this.context.inFunctionBody && this.throwError(messages_1.Messages.IllegalExportDeclaration);
						var node$1 = this.createNode();
						this.expectKeyword("export");
						var exportDeclaration;
						if (this.matchKeyword("default")) if (this.nextToken(), this.matchKeyword("function")) {
							var declaration = this.parseFunctionDeclaration(!0);
							exportDeclaration = this.finalize(node$1, new Node.ExportDefaultDeclaration(declaration));
						} else if (this.matchKeyword("class")) {
							var declaration = this.parseClassDeclaration(!0);
							exportDeclaration = this.finalize(node$1, new Node.ExportDefaultDeclaration(declaration));
						} else if (this.matchContextualKeyword("async")) {
							var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(!0) : this.parseAssignmentExpression();
							exportDeclaration = this.finalize(node$1, new Node.ExportDefaultDeclaration(declaration));
						} else {
							this.matchContextualKeyword("from") && this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
							var declaration = this.match("{") ? this.parseObjectInitializer() : this.match("[") ? this.parseArrayInitializer() : this.parseAssignmentExpression();
							this.consumeSemicolon(), exportDeclaration = this.finalize(node$1, new Node.ExportDefaultDeclaration(declaration));
						}
						else if (this.match("*")) {
							if (this.nextToken(), !this.matchContextualKeyword("from")) {
								var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
								this.throwError(message, this.lookahead.value);
							}
							this.nextToken();
							var src = this.parseModuleSpecifier();
							this.consumeSemicolon(), exportDeclaration = this.finalize(node$1, new Node.ExportAllDeclaration(src));
						} else if (this.lookahead.type === 4) {
							var declaration = void 0;
							switch (this.lookahead.value) {
								case "let":
								case "const":
									declaration = this.parseLexicalDeclaration({ inFor: !1 });
									break;
								case "var":
								case "class":
								case "function":
									declaration = this.parseStatementListItem();
									break;
								default: this.throwUnexpectedToken(this.lookahead);
							}
							exportDeclaration = this.finalize(node$1, new Node.ExportNamedDeclaration(declaration, [], null));
						} else if (this.matchAsyncFunction()) {
							var declaration = this.parseFunctionDeclaration();
							exportDeclaration = this.finalize(node$1, new Node.ExportNamedDeclaration(declaration, [], null));
						} else {
							var specifiers = [], source$2 = null, isExportFromIdentifier = !1;
							for (this.expect("{"); !this.match("}");) isExportFromIdentifier ||= this.matchKeyword("default"), specifiers.push(this.parseExportSpecifier()), this.match("}") || this.expect(",");
							if (this.expect("}"), this.matchContextualKeyword("from")) this.nextToken(), source$2 = this.parseModuleSpecifier(), this.consumeSemicolon();
							else if (isExportFromIdentifier) {
								var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
								this.throwError(message, this.lookahead.value);
							} else this.consumeSemicolon();
							exportDeclaration = this.finalize(node$1, new Node.ExportNamedDeclaration(null, specifiers, source$2));
						}
						return exportDeclaration;
					}, Parser;
				}();
			},
			function(module$1, exports$1) {
				Object.defineProperty(exports$1, "__esModule", { value: !0 });
				function assert(condition, message) {
					/* istanbul ignore if */
					if (!condition) throw Error("ASSERT: " + message);
				}
				exports$1.assert = assert;
			},
			function(module$1, exports$1) {
				Object.defineProperty(exports$1, "__esModule", { value: !0 }), exports$1.ErrorHandler = function() {
					function ErrorHandler() {
						this.errors = [], this.tolerant = !1;
					}
					return ErrorHandler.prototype.recordError = function(error$1) {
						this.errors.push(error$1);
					}, ErrorHandler.prototype.tolerate = function(error$1) {
						if (this.tolerant) this.recordError(error$1);
						else throw error$1;
					}, ErrorHandler.prototype.constructError = function(msg, column) {
						var error$1 = Error(msg);
						try {
							throw error$1;
						} catch (base) {
							/* istanbul ignore else */
							Object.create && Object.defineProperty && (error$1 = Object.create(base), Object.defineProperty(error$1, "column", { value: column }));
						}
						/* istanbul ignore next */
						return error$1;
					}, ErrorHandler.prototype.createError = function(index$2, line, col, description) {
						var msg = "Line " + line + ": " + description, error$1 = this.constructError(msg, col);
						return error$1.index = index$2, error$1.lineNumber = line, error$1.description = description, error$1;
					}, ErrorHandler.prototype.throwError = function(index$2, line, col, description) {
						throw this.createError(index$2, line, col, description);
					}, ErrorHandler.prototype.tolerateError = function(index$2, line, col, description) {
						var error$1 = this.createError(index$2, line, col, description);
						if (this.tolerant) this.recordError(error$1);
						else throw error$1;
					}, ErrorHandler;
				}();
			},
			function(module$1, exports$1) {
				Object.defineProperty(exports$1, "__esModule", { value: !0 }), exports$1.Messages = {
					BadGetterArity: "Getter must not have any formal parameters",
					BadSetterArity: "Setter must have exactly one formal parameter",
					BadSetterRestParameter: "Setter function argument must not be a rest parameter",
					ConstructorIsAsync: "Class constructor may not be an async method",
					ConstructorSpecialMethod: "Class constructor may not be an accessor",
					DeclarationMissingInitializer: "Missing initializer in %0 declaration",
					DefaultRestParameter: "Unexpected token =",
					DuplicateBinding: "Duplicate binding %0",
					DuplicateConstructor: "A class may only have one constructor",
					DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals",
					ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
					GeneratorInLegacyContext: "Generator declarations are not allowed in legacy contexts",
					IllegalBreak: "Illegal break statement",
					IllegalContinue: "Illegal continue statement",
					IllegalExportDeclaration: "Unexpected token",
					IllegalImportDeclaration: "Unexpected token",
					IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list",
					IllegalReturn: "Illegal return statement",
					InvalidEscapedReservedWord: "Keyword must not contain escaped characters",
					InvalidHexEscapeSequence: "Invalid hexadecimal escape sequence",
					InvalidLHSInAssignment: "Invalid left-hand side in assignment",
					InvalidLHSInForIn: "Invalid left-hand side in for-in",
					InvalidLHSInForLoop: "Invalid left-hand side in for-loop",
					InvalidModuleSpecifier: "Unexpected token",
					InvalidRegExp: "Invalid regular expression",
					LetInLexicalBinding: "let is disallowed as a lexically bound name",
					MissingFromClause: "Unexpected token",
					MultipleDefaultsInSwitch: "More than one default clause in switch statement",
					NewlineAfterThrow: "Illegal newline after throw",
					NoAsAfterImportNamespace: "Unexpected token",
					NoCatchOrFinally: "Missing catch or finally after try",
					ParameterAfterRestParameter: "Rest parameter must be last formal parameter",
					Redeclaration: "%0 '%1' has already been declared",
					StaticPrototype: "Classes may not have static property named prototype",
					StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
					StrictDelete: "Delete of an unqualified identifier in strict mode.",
					StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
					StrictFunctionName: "Function name may not be eval or arguments in strict mode",
					StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
					StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
					StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
					StrictModeWith: "Strict mode code may not include a with statement",
					StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
					StrictParamDupe: "Strict mode function may not have duplicate parameter names",
					StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
					StrictReservedWord: "Use of future reserved word in strict mode",
					StrictVarName: "Variable name may not be eval or arguments in strict mode",
					TemplateOctalLiteral: "Octal literals are not allowed in template strings.",
					UnexpectedEOS: "Unexpected end of input",
					UnexpectedIdentifier: "Unexpected identifier",
					UnexpectedNumber: "Unexpected number",
					UnexpectedReserved: "Unexpected reserved word",
					UnexpectedString: "Unexpected string",
					UnexpectedTemplate: "Unexpected quasi %0",
					UnexpectedToken: "Unexpected token %0",
					UnexpectedTokenIllegal: "Unexpected token ILLEGAL",
					UnknownLabel: "Undefined label '%0'",
					UnterminatedRegExp: "Invalid regular expression: missing /"
				};
			},
			function(module$1, exports$1, __webpack_require__) {
				Object.defineProperty(exports$1, "__esModule", { value: !0 });
				var assert_1 = __webpack_require__(9), character_1 = __webpack_require__(4), messages_1 = __webpack_require__(11);
				function hexValue(ch) {
					return "0123456789abcdef".indexOf(ch.toLowerCase());
				}
				function octalValue(ch) {
					return "01234567".indexOf(ch);
				}
				exports$1.Scanner = function() {
					function Scanner(code$4, handler) {
						this.source = code$4, this.errorHandler = handler, this.trackComment = !1, this.isModule = !1, this.length = code$4.length, this.index = 0, this.lineNumber = code$4.length > 0 ? 1 : 0, this.lineStart = 0, this.curlyStack = [];
					}
					return Scanner.prototype.saveState = function() {
						return {
							index: this.index,
							lineNumber: this.lineNumber,
							lineStart: this.lineStart
						};
					}, Scanner.prototype.restoreState = function(state) {
						this.index = state.index, this.lineNumber = state.lineNumber, this.lineStart = state.lineStart;
					}, Scanner.prototype.eof = function() {
						return this.index >= this.length;
					}, Scanner.prototype.throwUnexpectedToken = function(message) {
						return message === void 0 && (message = messages_1.Messages.UnexpectedTokenIllegal), this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
					}, Scanner.prototype.tolerateUnexpectedToken = function(message) {
						message === void 0 && (message = messages_1.Messages.UnexpectedTokenIllegal), this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
					}, Scanner.prototype.skipSingleLineComment = function(offset) {
						var comments = [], start, loc;
						for (this.trackComment && (comments = [], start = this.index - offset, loc = {
							start: {
								line: this.lineNumber,
								column: this.index - this.lineStart - offset
							},
							end: {}
						}); !this.eof();) {
							var ch = this.source.charCodeAt(this.index);
							if (++this.index, character_1.Character.isLineTerminator(ch)) {
								if (this.trackComment) {
									loc.end = {
										line: this.lineNumber,
										column: this.index - this.lineStart - 1
									};
									var entry = {
										multiLine: !1,
										slice: [start + offset, this.index - 1],
										range: [start, this.index - 1],
										loc
									};
									comments.push(entry);
								}
								return ch === 13 && this.source.charCodeAt(this.index) === 10 && ++this.index, ++this.lineNumber, this.lineStart = this.index, comments;
							}
						}
						if (this.trackComment) {
							loc.end = {
								line: this.lineNumber,
								column: this.index - this.lineStart
							};
							var entry = {
								multiLine: !1,
								slice: [start + offset, this.index],
								range: [start, this.index],
								loc
							};
							comments.push(entry);
						}
						return comments;
					}, Scanner.prototype.skipMultiLineComment = function() {
						var comments = [], start, loc;
						for (this.trackComment && (comments = [], start = this.index - 2, loc = {
							start: {
								line: this.lineNumber,
								column: this.index - this.lineStart - 2
							},
							end: {}
						}); !this.eof();) {
							var ch = this.source.charCodeAt(this.index);
							if (character_1.Character.isLineTerminator(ch)) ch === 13 && this.source.charCodeAt(this.index + 1) === 10 && ++this.index, ++this.lineNumber, ++this.index, this.lineStart = this.index;
							else if (ch === 42) {
								if (this.source.charCodeAt(this.index + 1) === 47) {
									if (this.index += 2, this.trackComment) {
										loc.end = {
											line: this.lineNumber,
											column: this.index - this.lineStart
										};
										var entry = {
											multiLine: !0,
											slice: [start + 2, this.index - 2],
											range: [start, this.index],
											loc
										};
										comments.push(entry);
									}
									return comments;
								}
								++this.index;
							} else ++this.index;
						}
						if (this.trackComment) {
							loc.end = {
								line: this.lineNumber,
								column: this.index - this.lineStart
							};
							var entry = {
								multiLine: !0,
								slice: [start + 2, this.index],
								range: [start, this.index],
								loc
							};
							comments.push(entry);
						}
						return this.tolerateUnexpectedToken(), comments;
					}, Scanner.prototype.scanComments = function() {
						var comments;
						this.trackComment && (comments = []);
						for (var start = this.index === 0; !this.eof();) {
							var ch = this.source.charCodeAt(this.index);
							if (character_1.Character.isWhiteSpace(ch)) ++this.index;
							else if (character_1.Character.isLineTerminator(ch)) ++this.index, ch === 13 && this.source.charCodeAt(this.index) === 10 && ++this.index, ++this.lineNumber, this.lineStart = this.index, start = !0;
							else if (ch === 47) if (ch = this.source.charCodeAt(this.index + 1), ch === 47) {
								this.index += 2;
								var comment = this.skipSingleLineComment(2);
								this.trackComment && (comments = comments.concat(comment)), start = !0;
							} else if (ch === 42) {
								this.index += 2;
								var comment = this.skipMultiLineComment();
								this.trackComment && (comments = comments.concat(comment));
							} else break;
							else if (start && ch === 45) if (this.source.charCodeAt(this.index + 1) === 45 && this.source.charCodeAt(this.index + 2) === 62) {
								this.index += 3;
								var comment = this.skipSingleLineComment(3);
								this.trackComment && (comments = comments.concat(comment));
							} else break;
							else if (ch === 60 && !this.isModule) if (this.source.slice(this.index + 1, this.index + 4) === "!--") {
								this.index += 4;
								var comment = this.skipSingleLineComment(4);
								this.trackComment && (comments = comments.concat(comment));
							} else break;
							else break;
						}
						return comments;
					}, Scanner.prototype.isFutureReservedWord = function(id) {
						switch (id) {
							case "enum":
							case "export":
							case "import":
							case "super": return !0;
							default: return !1;
						}
					}, Scanner.prototype.isStrictModeReservedWord = function(id) {
						switch (id) {
							case "implements":
							case "interface":
							case "package":
							case "private":
							case "protected":
							case "public":
							case "static":
							case "yield":
							case "let": return !0;
							default: return !1;
						}
					}, Scanner.prototype.isRestrictedWord = function(id) {
						return id === "eval" || id === "arguments";
					}, Scanner.prototype.isKeyword = function(id) {
						switch (id.length) {
							case 2: return id === "if" || id === "in" || id === "do";
							case 3: return id === "var" || id === "for" || id === "new" || id === "try" || id === "let";
							case 4: return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
							case 5: return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
							case 6: return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
							case 7: return id === "default" || id === "finally" || id === "extends";
							case 8: return id === "function" || id === "continue" || id === "debugger";
							case 10: return id === "instanceof";
							default: return !1;
						}
					}, Scanner.prototype.codePointAt = function(i$2) {
						var cp = this.source.charCodeAt(i$2);
						if (cp >= 55296 && cp <= 56319) {
							var second = this.source.charCodeAt(i$2 + 1);
							second >= 56320 && second <= 57343 && (cp = (cp - 55296) * 1024 + second - 56320 + 65536);
						}
						return cp;
					}, Scanner.prototype.scanHexEscape = function(prefix) {
						for (var len$1 = prefix === "u" ? 4 : 2, code$4 = 0, i$2 = 0; i$2 < len$1; ++i$2) if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) code$4 = code$4 * 16 + hexValue(this.source[this.index++]);
						else return null;
						return String.fromCharCode(code$4);
					}, Scanner.prototype.scanUnicodeCodePointEscape = function() {
						var ch = this.source[this.index], code$4 = 0;
						for (ch === "}" && this.throwUnexpectedToken(); !this.eof() && (ch = this.source[this.index++], character_1.Character.isHexDigit(ch.charCodeAt(0)));) code$4 = code$4 * 16 + hexValue(ch);
						return (code$4 > 1114111 || ch !== "}") && this.throwUnexpectedToken(), character_1.Character.fromCodePoint(code$4);
					}, Scanner.prototype.getIdentifier = function() {
						for (var start = this.index++; !this.eof();) {
							var ch = this.source.charCodeAt(this.index);
							if (ch === 92 || ch >= 55296 && ch < 57343) return this.index = start, this.getComplexIdentifier();
							if (character_1.Character.isIdentifierPart(ch)) ++this.index;
							else break;
						}
						return this.source.slice(start, this.index);
					}, Scanner.prototype.getComplexIdentifier = function() {
						var cp = this.codePointAt(this.index), id = character_1.Character.fromCodePoint(cp);
						this.index += id.length;
						var ch;
						for (cp === 92 && (this.source.charCodeAt(this.index) !== 117 && this.throwUnexpectedToken(), ++this.index, this.source[this.index] === "{" ? (++this.index, ch = this.scanUnicodeCodePointEscape()) : (ch = this.scanHexEscape("u"), (ch === null || ch === "\\" || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) && this.throwUnexpectedToken()), id = ch); !this.eof() && (cp = this.codePointAt(this.index), character_1.Character.isIdentifierPart(cp));) ch = character_1.Character.fromCodePoint(cp), id += ch, this.index += ch.length, cp === 92 && (id = id.substr(0, id.length - 1), this.source.charCodeAt(this.index) !== 117 && this.throwUnexpectedToken(), ++this.index, this.source[this.index] === "{" ? (++this.index, ch = this.scanUnicodeCodePointEscape()) : (ch = this.scanHexEscape("u"), (ch === null || ch === "\\" || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) && this.throwUnexpectedToken()), id += ch);
						return id;
					}, Scanner.prototype.octalToDecimal = function(ch) {
						var octal = ch !== "0", code$4 = octalValue(ch);
						return !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index)) && (octal = !0, code$4 = code$4 * 8 + octalValue(this.source[this.index++]), "0123".indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index)) && (code$4 = code$4 * 8 + octalValue(this.source[this.index++]))), {
							code: code$4,
							octal
						};
					}, Scanner.prototype.scanIdentifier = function() {
						var type, start = this.index, id = this.source.charCodeAt(start) === 92 ? this.getComplexIdentifier() : this.getIdentifier();
						if (type = id.length === 1 ? 3 : this.isKeyword(id) ? 4 : id === "null" ? 5 : id === "true" || id === "false" ? 1 : 3, type !== 3 && start + id.length !== this.index) {
							var restore = this.index;
							this.index = start, this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord), this.index = restore;
						}
						return {
							type,
							value: id,
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start,
							end: this.index
						};
					}, Scanner.prototype.scanPunctuator = function() {
						var start = this.index, str = this.source[this.index];
						switch (str) {
							case "(":
							case "{":
								str === "{" && this.curlyStack.push("{"), ++this.index;
								break;
							case ".":
								++this.index, this.source[this.index] === "." && this.source[this.index + 1] === "." && (this.index += 2, str = "...");
								break;
							case "}":
								++this.index, this.curlyStack.pop();
								break;
							case ")":
							case ";":
							case ",":
							case "[":
							case "]":
							case ":":
							case "?":
							case "~":
								++this.index;
								break;
							default: str = this.source.substr(this.index, 4), str === ">>>=" ? this.index += 4 : (str = str.substr(0, 3), str === "===" || str === "!==" || str === ">>>" || str === "<<=" || str === ">>=" || str === "**=" ? this.index += 3 : (str = str.substr(0, 2), str === "&&" || str === "||" || str === "==" || str === "!=" || str === "+=" || str === "-=" || str === "*=" || str === "/=" || str === "++" || str === "--" || str === "<<" || str === ">>" || str === "&=" || str === "|=" || str === "^=" || str === "%=" || str === "<=" || str === ">=" || str === "=>" || str === "**" ? this.index += 2 : (str = this.source[this.index], "<>=!+-*%&|^/".indexOf(str) >= 0 && ++this.index)));
						}
						return this.index === start && this.throwUnexpectedToken(), {
							type: 7,
							value: str,
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start,
							end: this.index
						};
					}, Scanner.prototype.scanHexLiteral = function(start) {
						for (var num = ""; !this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index));) num += this.source[this.index++];
						return num.length === 0 && this.throwUnexpectedToken(), character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(), {
							type: 6,
							value: parseInt("0x" + num, 16),
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start,
							end: this.index
						};
					}, Scanner.prototype.scanBinaryLiteral = function(start) {
						for (var num = "", ch; !this.eof() && (ch = this.source[this.index], !(ch !== "0" && ch !== "1"));) num += this.source[this.index++];
						return num.length === 0 && this.throwUnexpectedToken(), this.eof() || (ch = this.source.charCodeAt(this.index), (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) && this.throwUnexpectedToken()), {
							type: 6,
							value: parseInt(num, 2),
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start,
							end: this.index
						};
					}, Scanner.prototype.scanOctalLiteral = function(prefix, start) {
						var num = "", octal = !1;
						for (character_1.Character.isOctalDigit(prefix.charCodeAt(0)) ? (octal = !0, num = "0" + this.source[this.index++]) : ++this.index; !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index));) num += this.source[this.index++];
						return !octal && num.length === 0 && this.throwUnexpectedToken(), (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) && this.throwUnexpectedToken(), {
							type: 6,
							value: parseInt(num, 8),
							octal,
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start,
							end: this.index
						};
					}, Scanner.prototype.isImplicitOctalLiteral = function() {
						for (var i$2 = this.index + 1; i$2 < this.length; ++i$2) {
							var ch = this.source[i$2];
							if (ch === "8" || ch === "9") return !1;
							if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) return !0;
						}
						return !0;
					}, Scanner.prototype.scanNumericLiteral = function() {
						var start = this.index, ch = this.source[start];
						assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || ch === ".", "Numeric literal must start with a decimal digit or a decimal point");
						var num = "";
						if (ch !== ".") {
							if (num = this.source[this.index++], ch = this.source[this.index], num === "0") {
								if (ch === "x" || ch === "X") return ++this.index, this.scanHexLiteral(start);
								if (ch === "b" || ch === "B") return ++this.index, this.scanBinaryLiteral(start);
								if (ch === "o" || ch === "O" || ch && character_1.Character.isOctalDigit(ch.charCodeAt(0)) && this.isImplicitOctalLiteral()) return this.scanOctalLiteral(ch, start);
							}
							for (; character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index));) num += this.source[this.index++];
							ch = this.source[this.index];
						}
						if (ch === ".") {
							for (num += this.source[this.index++]; character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index));) num += this.source[this.index++];
							ch = this.source[this.index];
						}
						if (ch === "e" || ch === "E") if (num += this.source[this.index++], ch = this.source[this.index], (ch === "+" || ch === "-") && (num += this.source[this.index++]), character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) for (; character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index));) num += this.source[this.index++];
						else this.throwUnexpectedToken();
						return character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(), {
							type: 6,
							value: parseFloat(num),
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start,
							end: this.index
						};
					}, Scanner.prototype.scanStringLiteral = function() {
						var start = this.index, quote = this.source[start];
						assert_1.assert(quote === "'" || quote === "\"", "String literal must starts with a quote"), ++this.index;
						for (var octal = !1, str = ""; !this.eof();) {
							var ch = this.source[this.index++];
							if (ch === quote) {
								quote = "";
								break;
							} else if (ch === "\\") if (ch = this.source[this.index++], !ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) switch (ch) {
								case "u":
									if (this.source[this.index] === "{") ++this.index, str += this.scanUnicodeCodePointEscape();
									else {
										var unescaped_1 = this.scanHexEscape(ch);
										unescaped_1 === null && this.throwUnexpectedToken(), str += unescaped_1;
									}
									break;
								case "x":
									var unescaped = this.scanHexEscape(ch);
									unescaped === null && this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence), str += unescaped;
									break;
								case "n":
									str += "\n";
									break;
								case "r":
									str += "\r";
									break;
								case "t":
									str += "	";
									break;
								case "b":
									str += "\b";
									break;
								case "f":
									str += "\f";
									break;
								case "v":
									str += "\v";
									break;
								case "8":
								case "9":
									str += ch, this.tolerateUnexpectedToken();
									break;
								default:
									if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
										var octToDec = this.octalToDecimal(ch);
										octal = octToDec.octal || octal, str += String.fromCharCode(octToDec.code);
									} else str += ch;
									break;
							}
							else ++this.lineNumber, ch === "\r" && this.source[this.index] === "\n" && ++this.index, this.lineStart = this.index;
							else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) break;
							else str += ch;
						}
						return quote !== "" && (this.index = start, this.throwUnexpectedToken()), {
							type: 8,
							value: str,
							octal,
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start,
							end: this.index
						};
					}, Scanner.prototype.scanTemplate = function() {
						var cooked = "", terminated = !1, start = this.index, head = this.source[start] === "`", tail = !1, rawOffset = 2;
						for (++this.index; !this.eof();) {
							var ch = this.source[this.index++];
							if (ch === "`") {
								rawOffset = 1, tail = !0, terminated = !0;
								break;
							} else if (ch === "$") {
								if (this.source[this.index] === "{") {
									this.curlyStack.push("${"), ++this.index, terminated = !0;
									break;
								}
								cooked += ch;
							} else if (ch === "\\") if (ch = this.source[this.index++], character_1.Character.isLineTerminator(ch.charCodeAt(0))) ++this.lineNumber, ch === "\r" && this.source[this.index] === "\n" && ++this.index, this.lineStart = this.index;
							else switch (ch) {
								case "n":
									cooked += "\n";
									break;
								case "r":
									cooked += "\r";
									break;
								case "t":
									cooked += "	";
									break;
								case "u":
									if (this.source[this.index] === "{") ++this.index, cooked += this.scanUnicodeCodePointEscape();
									else {
										var restore = this.index, unescaped_2 = this.scanHexEscape(ch);
										unescaped_2 === null ? (this.index = restore, cooked += ch) : cooked += unescaped_2;
									}
									break;
								case "x":
									var unescaped = this.scanHexEscape(ch);
									unescaped === null && this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence), cooked += unescaped;
									break;
								case "b":
									cooked += "\b";
									break;
								case "f":
									cooked += "\f";
									break;
								case "v":
									cooked += "\v";
									break;
								default:
									ch === "0" ? (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral), cooked += "\0") : character_1.Character.isOctalDigit(ch.charCodeAt(0)) ? this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral) : cooked += ch;
									break;
							}
							else character_1.Character.isLineTerminator(ch.charCodeAt(0)) ? (++this.lineNumber, ch === "\r" && this.source[this.index] === "\n" && ++this.index, this.lineStart = this.index, cooked += "\n") : cooked += ch;
						}
						return terminated || this.throwUnexpectedToken(), head || this.curlyStack.pop(), {
							type: 10,
							value: this.source.slice(start + 1, this.index - rawOffset),
							cooked,
							head,
							tail,
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start,
							end: this.index
						};
					}, Scanner.prototype.testRegExp = function(pattern, flags) {
						var astralSubstitute = "ï¿¿", tmp = pattern, self$1 = this;
						flags.indexOf("u") >= 0 && (tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function($0, $1, $2) {
							var codePoint = parseInt($1 || $2, 16);
							return codePoint > 1114111 && self$1.throwUnexpectedToken(messages_1.Messages.InvalidRegExp), codePoint <= 65535 ? String.fromCharCode(codePoint) : astralSubstitute;
						}).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute));
						try {
							return new RegExp(pattern, flags);
						} catch {
							/* istanbul ignore next */
							return null;
						}
					}, Scanner.prototype.scanRegExpBody = function() {
						var ch = this.source[this.index];
						assert_1.assert(ch === "/", "Regular expression literal must start with a slash");
						for (var str = this.source[this.index++], classMarker = !1, terminated = !1; !this.eof();) if (ch = this.source[this.index++], str += ch, ch === "\\") ch = this.source[this.index++], character_1.Character.isLineTerminator(ch.charCodeAt(0)) && this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp), str += ch;
						else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
						else if (classMarker) ch === "]" && (classMarker = !1);
						else if (ch === "/") {
							terminated = !0;
							break;
						} else ch === "[" && (classMarker = !0);
						return terminated || this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp), str.substr(1, str.length - 2);
					}, Scanner.prototype.scanRegExpFlags = function() {
						for (var str = "", flags = ""; !this.eof();) {
							var ch = this.source[this.index];
							if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) break;
							if (++this.index, ch === "\\" && !this.eof()) if (ch = this.source[this.index], ch === "u") {
								++this.index;
								var restore = this.index, char = this.scanHexEscape("u");
								if (char !== null) for (flags += char, str += "\\u"; restore < this.index; ++restore) str += this.source[restore];
								else this.index = restore, flags += "u", str += "\\u";
								this.tolerateUnexpectedToken();
							} else str += "\\", this.tolerateUnexpectedToken();
							else flags += ch, str += ch;
						}
						return flags;
					}, Scanner.prototype.scanRegExp = function() {
						var start = this.index, pattern = this.scanRegExpBody(), flags = this.scanRegExpFlags();
						return {
							type: 9,
							value: "",
							pattern,
							flags,
							regex: this.testRegExp(pattern, flags),
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start,
							end: this.index
						};
					}, Scanner.prototype.lex = function() {
						if (this.eof()) return {
							type: 2,
							value: "",
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start: this.index,
							end: this.index
						};
						var cp = this.source.charCodeAt(this.index);
						return character_1.Character.isIdentifierStart(cp) ? this.scanIdentifier() : cp === 40 || cp === 41 || cp === 59 ? this.scanPunctuator() : cp === 39 || cp === 34 ? this.scanStringLiteral() : cp === 46 ? character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1)) ? this.scanNumericLiteral() : this.scanPunctuator() : character_1.Character.isDecimalDigit(cp) ? this.scanNumericLiteral() : cp === 96 || cp === 125 && this.curlyStack[this.curlyStack.length - 1] === "${" ? this.scanTemplate() : cp >= 55296 && cp < 57343 && character_1.Character.isIdentifierStart(this.codePointAt(this.index)) ? this.scanIdentifier() : this.scanPunctuator();
					}, Scanner;
				}();
			},
			function(module$1, exports$1) {
				Object.defineProperty(exports$1, "__esModule", { value: !0 }), exports$1.TokenName = {}, exports$1.TokenName[1] = "Boolean", exports$1.TokenName[2] = "<end>", exports$1.TokenName[3] = "Identifier", exports$1.TokenName[4] = "Keyword", exports$1.TokenName[5] = "Null", exports$1.TokenName[6] = "Numeric", exports$1.TokenName[7] = "Punctuator", exports$1.TokenName[8] = "String", exports$1.TokenName[9] = "RegularExpression", exports$1.TokenName[10] = "Template";
			},
			function(module$1, exports$1) {
				Object.defineProperty(exports$1, "__esModule", { value: !0 }), exports$1.XHTMLEntities = {
					quot: "\"",
					amp: "&",
					apos: "'",
					gt: ">",
					nbsp: "\xA0",
					iexcl: "Â¡",
					cent: "Â¢",
					pound: "Â£",
					curren: "Â¤",
					yen: "Â¥",
					brvbar: "Â¦",
					sect: "Â§",
					uml: "Â¨",
					copy: "Â©",
					ordf: "Âª",
					laquo: "Â«",
					not: "Â¬",
					shy: "Â­",
					reg: "Â®",
					macr: "Â¯",
					deg: "Â°",
					plusmn: "Â±",
					sup2: "Â²",
					sup3: "Â³",
					acute: "Â´",
					micro: "Âµ",
					para: "Â¶",
					middot: "Â·",
					cedil: "Â¸",
					sup1: "Â¹",
					ordm: "Âº",
					raquo: "Â»",
					frac14: "Â¼",
					frac12: "Â½",
					frac34: "Â¾",
					iquest: "Â¿",
					Agrave: "Ã€",
					Aacute: "Ã",
					Acirc: "Ã‚",
					Atilde: "Ãƒ",
					Auml: "Ã„",
					Aring: "Ã…",
					AElig: "Ã†",
					Ccedil: "Ã‡",
					Egrave: "Ãˆ",
					Eacute: "Ã‰",
					Ecirc: "ÃŠ",
					Euml: "Ã‹",
					Igrave: "ÃŒ",
					Iacute: "Ã",
					Icirc: "ÃŽ",
					Iuml: "Ã",
					ETH: "Ã",
					Ntilde: "Ã‘",
					Ograve: "Ã’",
					Oacute: "Ã“",
					Ocirc: "Ã”",
					Otilde: "Ã•",
					Ouml: "Ã–",
					times: "Ã—",
					Oslash: "Ã˜",
					Ugrave: "Ã™",
					Uacute: "Ãš",
					Ucirc: "Ã›",
					Uuml: "Ãœ",
					Yacute: "Ã",
					THORN: "Ãž",
					szlig: "ÃŸ",
					agrave: "Ã ",
					aacute: "Ã¡",
					acirc: "Ã¢",
					atilde: "Ã£",
					auml: "Ã¤",
					aring: "Ã¥",
					aelig: "Ã¦",
					ccedil: "Ã§",
					egrave: "Ã¨",
					eacute: "Ã©",
					ecirc: "Ãª",
					euml: "Ã«",
					igrave: "Ã¬",
					iacute: "Ã­",
					icirc: "Ã®",
					iuml: "Ã¯",
					eth: "Ã°",
					ntilde: "Ã±",
					ograve: "Ã²",
					oacute: "Ã³",
					ocirc: "Ã´",
					otilde: "Ãµ",
					ouml: "Ã¶",
					divide: "Ã·",
					oslash: "Ã¸",
					ugrave: "Ã¹",
					uacute: "Ãº",
					ucirc: "Ã»",
					uuml: "Ã¼",
					yacute: "Ã½",
					thorn: "Ã¾",
					yuml: "Ã¿",
					OElig: "Å’",
					oelig: "Å“",
					Scaron: "Å ",
					scaron: "Å¡",
					Yuml: "Å¸",
					fnof: "Æ’",
					circ: "Ë†",
					tilde: "Ëœ",
					Alpha: "Î‘",
					Beta: "Î’",
					Gamma: "Î“",
					Delta: "Î”",
					Epsilon: "Î•",
					Zeta: "Î–",
					Eta: "Î—",
					Theta: "Î˜",
					Iota: "Î™",
					Kappa: "Îš",
					Lambda: "Î›",
					Mu: "Îœ",
					Nu: "Î",
					Xi: "Îž",
					Omicron: "ÎŸ",
					Pi: "Î ",
					Rho: "Î¡",
					Sigma: "Î£",
					Tau: "Î¤",
					Upsilon: "Î¥",
					Phi: "Î¦",
					Chi: "Î§",
					Psi: "Î¨",
					Omega: "Î©",
					alpha: "Î±",
					beta: "Î²",
					gamma: "Î³",
					delta: "Î´",
					epsilon: "Îµ",
					zeta: "Î¶",
					eta: "Î·",
					theta: "Î¸",
					iota: "Î¹",
					kappa: "Îº",
					lambda: "Î»",
					mu: "Î¼",
					nu: "Î½",
					xi: "Î¾",
					omicron: "Î¿",
					pi: "Ï€",
					rho: "Ï",
					sigmaf: "Ï‚",
					sigma: "Ïƒ",
					tau: "Ï„",
					upsilon: "Ï…",
					phi: "Ï†",
					chi: "Ï‡",
					psi: "Ïˆ",
					omega: "Ï‰",
					thetasym: "Ï‘",
					upsih: "Ï’",
					piv: "Ï–",
					ensp: "â€‚",
					emsp: "â€ƒ",
					thinsp: "â€‰",
					zwnj: "â€Œ",
					zwj: "â€",
					lrm: "â€Ž",
					rlm: "â€",
					ndash: "â€“",
					mdash: "â€”",
					lsquo: "â€˜",
					rsquo: "â€™",
					sbquo: "â€š",
					ldquo: "â€œ",
					rdquo: "â€",
					bdquo: "â€ž",
					dagger: "â€ ",
					Dagger: "â€¡",
					bull: "â€¢",
					hellip: "â€¦",
					permil: "â€°",
					prime: "â€²",
					Prime: "â€³",
					lsaquo: "â€¹",
					rsaquo: "â€º",
					oline: "â€¾",
					frasl: "â„",
					euro: "â‚¬",
					image: "â„‘",
					weierp: "â„˜",
					real: "â„œ",
					trade: "â„¢",
					alefsym: "â„µ",
					larr: "â†",
					uarr: "â†‘",
					rarr: "â†’",
					darr: "â†“",
					harr: "â†”",
					crarr: "â†µ",
					lArr: "â‡",
					uArr: "â‡‘",
					rArr: "â‡’",
					dArr: "â‡“",
					hArr: "â‡”",
					forall: "âˆ€",
					part: "âˆ‚",
					exist: "âˆƒ",
					empty: "âˆ…",
					nabla: "âˆ‡",
					isin: "âˆˆ",
					notin: "âˆ‰",
					ni: "âˆ‹",
					prod: "âˆ",
					sum: "âˆ‘",
					minus: "âˆ’",
					lowast: "âˆ—",
					radic: "âˆš",
					prop: "âˆ",
					infin: "âˆž",
					ang: "âˆ ",
					and: "âˆ§",
					or: "âˆ¨",
					cap: "âˆ©",
					cup: "âˆª",
					int: "âˆ«",
					there4: "âˆ´",
					sim: "âˆ¼",
					cong: "â‰…",
					asymp: "â‰ˆ",
					ne: "â‰ ",
					equiv: "â‰¡",
					le: "â‰¤",
					ge: "â‰¥",
					sub: "âŠ‚",
					sup: "âŠƒ",
					nsub: "âŠ„",
					sube: "âŠ†",
					supe: "âŠ‡",
					oplus: "âŠ•",
					otimes: "âŠ—",
					perp: "âŠ¥",
					sdot: "â‹…",
					lceil: "âŒˆ",
					rceil: "âŒ‰",
					lfloor: "âŒŠ",
					rfloor: "âŒ‹",
					loz: "â—Š",
					spades: "â™ ",
					clubs: "â™£",
					hearts: "â™¥",
					diams: "â™¦",
					lang: "âŸ¨",
					rang: "âŸ©"
				};
			},
			function(module$1, exports$1, __webpack_require__) {
				Object.defineProperty(exports$1, "__esModule", { value: !0 });
				var error_handler_1 = __webpack_require__(10), scanner_1 = __webpack_require__(12), token_1 = __webpack_require__(13), Reader = function() {
					function Reader$1() {
						this.values = [], this.curly = this.paren = -1;
					}
					return Reader$1.prototype.beforeFunctionExpression = function(t) {
						return (/* @__PURE__ */ "(.{.[.in.typeof.instanceof.new.return.case.delete.throw.void.=.+=.-=.*=.**=./=.%=.<<=.>>=.>>>=.&=.|=.^=.,.+.-.*.**./.%.++.--.<<.>>.>>>.&.|.^.!.~.&&.||.?.:.===.==.>=.<=.<.>.!=.!==".split(".")).indexOf(t) >= 0;
					}, Reader$1.prototype.isRegexStart = function() {
						var previous$2 = this.values[this.values.length - 1], regex$1 = previous$2 !== null;
						switch (previous$2) {
							case "this":
							case "]":
								regex$1 = !1;
								break;
							case ")":
								var keyword = this.values[this.paren - 1];
								regex$1 = keyword === "if" || keyword === "while" || keyword === "for" || keyword === "with";
								break;
							case "}":
								if (regex$1 = !1, this.values[this.curly - 3] === "function") {
									var check = this.values[this.curly - 4];
									regex$1 = check ? !this.beforeFunctionExpression(check) : !1;
								} else if (this.values[this.curly - 4] === "function") {
									var check = this.values[this.curly - 5];
									regex$1 = check ? !this.beforeFunctionExpression(check) : !0;
								}
								break;
							default: break;
						}
						return regex$1;
					}, Reader$1.prototype.push = function(token) {
						token.type === 7 || token.type === 4 ? (token.value === "{" ? this.curly = this.values.length : token.value === "(" && (this.paren = this.values.length), this.values.push(token.value)) : this.values.push(null);
					}, Reader$1;
				}();
				exports$1.Tokenizer = function() {
					function Tokenizer(code$4, config) {
						this.errorHandler = new error_handler_1.ErrorHandler(), this.errorHandler.tolerant = config ? typeof config.tolerant == "boolean" && config.tolerant : !1, this.scanner = new scanner_1.Scanner(code$4, this.errorHandler), this.scanner.trackComment = config ? typeof config.comment == "boolean" && config.comment : !1, this.trackRange = config ? typeof config.range == "boolean" && config.range : !1, this.trackLoc = config ? typeof config.loc == "boolean" && config.loc : !1, this.buffer = [], this.reader = new Reader();
					}
					return Tokenizer.prototype.errors = function() {
						return this.errorHandler.errors;
					}, Tokenizer.prototype.getNextToken = function() {
						if (this.buffer.length === 0) {
							var comments = this.scanner.scanComments();
							if (this.scanner.trackComment) for (var i$2 = 0; i$2 < comments.length; ++i$2) {
								var e = comments[i$2], value = this.scanner.source.slice(e.slice[0], e.slice[1]), comment = {
									type: e.multiLine ? "BlockComment" : "LineComment",
									value
								};
								this.trackRange && (comment.range = e.range), this.trackLoc && (comment.loc = e.loc), this.buffer.push(comment);
							}
							if (!this.scanner.eof()) {
								var loc = void 0;
								this.trackLoc && (loc = {
									start: {
										line: this.scanner.lineNumber,
										column: this.scanner.index - this.scanner.lineStart
									},
									end: {}
								});
								var token = this.scanner.source[this.scanner.index] === "/" && this.reader.isRegexStart() ? this.scanner.scanRegExp() : this.scanner.lex();
								this.reader.push(token);
								var entry = {
									type: token_1.TokenName[token.type],
									value: this.scanner.source.slice(token.start, token.end)
								};
								this.trackRange && (entry.range = [token.start, token.end]), this.trackLoc && (loc.end = {
									line: this.scanner.lineNumber,
									column: this.scanner.index - this.scanner.lineStart
								}, entry.loc = loc), token.type === 9 && (entry.regex = {
									pattern: token.pattern,
									flags: token.flags
								}), this.buffer.push(entry);
							}
						}
						return this.buffer.shift();
					}, Tokenizer;
				}();
			}
		]);
	});
})), require_function = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var esprima;
	try {
		esprima = require_esprima();
	} catch {
		typeof window < "u" && (esprima = window.esprima);
	}
	var Type = require_type();
	function resolveJavascriptFunction(data) {
		if (data === null) return !1;
		try {
			var source$2 = "(" + data + ")", ast = esprima.parse(source$2, { range: !0 });
			return !(ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression");
		} catch {
			return !1;
		}
	}
	function constructJavascriptFunction(data) {
		var source$2 = "(" + data + ")", ast = esprima.parse(source$2, { range: !0 }), params = [], body;
		if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") throw Error("Failed to resolve function");
		return ast.body[0].expression.params.forEach(function(param) {
			params.push(param.name);
		}), body = ast.body[0].expression.body.range, ast.body[0].expression.body.type === "BlockStatement" ? Function(params, source$2.slice(body[0] + 1, body[1] - 1)) : Function(params, "return " + source$2.slice(body[0], body[1]));
	}
	function representJavascriptFunction(object) {
		return object.toString();
	}
	function isFunction(object) {
		return Object.prototype.toString.call(object) === "[object Function]";
	}
	module.exports = new Type("tag:yaml.org,2002:js/function", {
		kind: "scalar",
		resolve: resolveJavascriptFunction,
		construct: constructJavascriptFunction,
		predicate: isFunction,
		represent: representJavascriptFunction
	});
})), require_default_full = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Schema = require_schema();
	module.exports = Schema.DEFAULT = new Schema({
		include: [require_default_safe()],
		explicit: [
			require_undefined(),
			require_regexp(),
			require_function()
		]
	});
})), require_loader = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var common$1 = require_common(), YAMLException$1 = require_exception(), Mark = require_mark(), DEFAULT_SAFE_SCHEMA$1 = require_default_safe(), DEFAULT_FULL_SCHEMA$1 = require_default_full(), _hasOwnProperty$1 = Object.prototype.hasOwnProperty, CONTEXT_FLOW_IN = 1, CONTEXT_FLOW_OUT = 2, CONTEXT_BLOCK_IN = 3, CONTEXT_BLOCK_OUT = 4, CHOMPING_CLIP = 1, CHOMPING_STRIP = 2, CHOMPING_KEEP = 3, PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/, PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/, PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i, PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
	function _class(obj) {
		return Object.prototype.toString.call(obj);
	}
	function is_EOL(c$1) {
		return c$1 === 10 || c$1 === 13;
	}
	function is_WHITE_SPACE(c$1) {
		return c$1 === 9 || c$1 === 32;
	}
	function is_WS_OR_EOL(c$1) {
		return c$1 === 9 || c$1 === 32 || c$1 === 10 || c$1 === 13;
	}
	function is_FLOW_INDICATOR(c$1) {
		return c$1 === 44 || c$1 === 91 || c$1 === 93 || c$1 === 123 || c$1 === 125;
	}
	function fromHexCode(c$1) {
		var lc;
		return 48 <= c$1 && c$1 <= 57 ? c$1 - 48 : (lc = c$1 | 32, 97 <= lc && lc <= 102 ? lc - 97 + 10 : -1);
	}
	function escapedHexLen(c$1) {
		return c$1 === 120 ? 2 : c$1 === 117 ? 4 : c$1 === 85 ? 8 : 0;
	}
	function fromDecimalCode(c$1) {
		return 48 <= c$1 && c$1 <= 57 ? c$1 - 48 : -1;
	}
	function simpleEscapeSequence(c$1) {
		return c$1 === 48 ? "\0" : c$1 === 97 ? "\x07" : c$1 === 98 ? "\b" : c$1 === 116 || c$1 === 9 ? "	" : c$1 === 110 ? "\n" : c$1 === 118 ? "\v" : c$1 === 102 ? "\f" : c$1 === 114 ? "\r" : c$1 === 101 ? "\x1B" : c$1 === 32 ? " " : c$1 === 34 ? "\"" : c$1 === 47 ? "/" : c$1 === 92 ? "\\" : c$1 === 78 ? "Â…" : c$1 === 95 ? "\xA0" : c$1 === 76 ? "\u2028" : c$1 === 80 ? "\u2029" : "";
	}
	function charFromCodepoint(c$1) {
		return c$1 <= 65535 ? String.fromCharCode(c$1) : String.fromCharCode((c$1 - 65536 >> 10) + 55296, (c$1 - 65536 & 1023) + 56320);
	}
	function setProperty(object, key, value) {
		key === "__proto__" ? Object.defineProperty(object, key, {
			configurable: !0,
			enumerable: !0,
			writable: !0,
			value
		}) : object[key] = value;
	}
	for (var simpleEscapeCheck = Array(256), simpleEscapeMap = Array(256), i = 0; i < 256; i++) simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0, simpleEscapeMap[i] = simpleEscapeSequence(i);
	function State$1(input, options) {
		this.input = input, this.filename = options.filename || null, this.schema = options.schema || DEFAULT_FULL_SCHEMA$1, this.onWarning = options.onWarning || null, this.legacy = options.legacy || !1, this.json = options.json || !1, this.listener = options.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = input.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.documents = [];
	}
	function generateError(state, message) {
		return new YAMLException$1(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
	}
	function throwError(state, message) {
		throw generateError(state, message);
	}
	function throwWarning(state, message) {
		state.onWarning && state.onWarning.call(null, generateError(state, message));
	}
	var directiveHandlers = {
		YAML: function(state, name$1, args) {
			var match, major, minor;
			state.version !== null && throwError(state, "duplication of %YAML directive"), args.length !== 1 && throwError(state, "YAML directive accepts exactly one argument"), match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]), match === null && throwError(state, "ill-formed argument of the YAML directive"), major = parseInt(match[1], 10), minor = parseInt(match[2], 10), major !== 1 && throwError(state, "unacceptable YAML version of the document"), state.version = args[0], state.checkLineBreaks = minor < 2, minor !== 1 && minor !== 2 && throwWarning(state, "unsupported YAML version of the document");
		},
		TAG: function(state, name$1, args) {
			var handle$1, prefix;
			args.length !== 2 && throwError(state, "TAG directive accepts exactly two arguments"), handle$1 = args[0], prefix = args[1], PATTERN_TAG_HANDLE.test(handle$1) || throwError(state, "ill-formed tag handle (first argument) of the TAG directive"), _hasOwnProperty$1.call(state.tagMap, handle$1) && throwError(state, "there is a previously declared suffix for \"" + handle$1 + "\" tag handle"), PATTERN_TAG_URI.test(prefix) || throwError(state, "ill-formed tag prefix (second argument) of the TAG directive"), state.tagMap[handle$1] = prefix;
		}
	};
	function captureSegment(state, start, end, checkJson) {
		var _position, _length, _character, _result;
		if (start < end) {
			if (_result = state.input.slice(start, end), checkJson) for (_position = 0, _length = _result.length; _position < _length; _position += 1) _character = _result.charCodeAt(_position), _character === 9 || 32 <= _character && _character <= 1114111 || throwError(state, "expected valid JSON character");
			else PATTERN_NON_PRINTABLE.test(_result) && throwError(state, "the stream contains non-printable characters");
			state.result += _result;
		}
	}
	function mergeMappings(state, destination, source$2, overridableKeys) {
		var sourceKeys, key, index$2, quantity;
		for (common$1.isObject(source$2) || throwError(state, "cannot merge mappings; the provided source object is unacceptable"), sourceKeys = Object.keys(source$2), index$2 = 0, quantity = sourceKeys.length; index$2 < quantity; index$2 += 1) key = sourceKeys[index$2], _hasOwnProperty$1.call(destination, key) || (setProperty(destination, key, source$2[key]), overridableKeys[key] = !0);
	}
	function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
		var index$2, quantity;
		if (Array.isArray(keyNode)) for (keyNode = Array.prototype.slice.call(keyNode), index$2 = 0, quantity = keyNode.length; index$2 < quantity; index$2 += 1) Array.isArray(keyNode[index$2]) && throwError(state, "nested arrays are not supported inside keys"), typeof keyNode == "object" && _class(keyNode[index$2]) === "[object Object]" && (keyNode[index$2] = "[object Object]");
		if (typeof keyNode == "object" && _class(keyNode) === "[object Object]" && (keyNode = "[object Object]"), keyNode = String(keyNode), _result === null && (_result = {}), keyTag === "tag:yaml.org,2002:merge") if (Array.isArray(valueNode)) for (index$2 = 0, quantity = valueNode.length; index$2 < quantity; index$2 += 1) mergeMappings(state, _result, valueNode[index$2], overridableKeys);
		else mergeMappings(state, _result, valueNode, overridableKeys);
		else !state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode) && (state.line = startLine || state.line, state.position = startPos || state.position, throwError(state, "duplicated mapping key")), setProperty(_result, keyNode, valueNode), delete overridableKeys[keyNode];
		return _result;
	}
	function readLineBreak(state) {
		var ch = state.input.charCodeAt(state.position);
		ch === 10 ? state.position++ : ch === 13 ? (state.position++, state.input.charCodeAt(state.position) === 10 && state.position++) : throwError(state, "a line break is expected"), state.line += 1, state.lineStart = state.position;
	}
	function skipSeparationSpace(state, allowComments, checkIndent) {
		for (var lineBreaks = 0, ch = state.input.charCodeAt(state.position); ch !== 0;) {
			for (; is_WHITE_SPACE(ch);) ch = state.input.charCodeAt(++state.position);
			if (allowComments && ch === 35) do
				ch = state.input.charCodeAt(++state.position);
			while (ch !== 10 && ch !== 13 && ch !== 0);
			if (is_EOL(ch)) for (readLineBreak(state), ch = state.input.charCodeAt(state.position), lineBreaks++, state.lineIndent = 0; ch === 32;) state.lineIndent++, ch = state.input.charCodeAt(++state.position);
			else break;
		}
		return checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent && throwWarning(state, "deficient indentation"), lineBreaks;
	}
	function testDocumentSeparator(state) {
		var _position = state.position, ch = state.input.charCodeAt(_position);
		return !!((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2) && (_position += 3, ch = state.input.charCodeAt(_position), ch === 0 || is_WS_OR_EOL(ch)));
	}
	function writeFoldedLines(state, count) {
		count === 1 ? state.result += " " : count > 1 && (state.result += common$1.repeat("\n", count - 1));
	}
	function readPlainScalar(state, nodeIndent, withinFlowCollection) {
		var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch = state.input.charCodeAt(state.position);
		if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96 || (ch === 63 || ch === 45) && (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following))) return !1;
		for (state.kind = "scalar", state.result = "", captureStart = captureEnd = state.position, hasPendingContent = !1; ch !== 0;) {
			if (ch === 58) {
				if (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) break;
			} else if (ch === 35) {
				if (preceding = state.input.charCodeAt(state.position - 1), is_WS_OR_EOL(preceding)) break;
			} else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) break;
			else if (is_EOL(ch)) if (_line = state.line, _lineStart = state.lineStart, _lineIndent = state.lineIndent, skipSeparationSpace(state, !1, -1), state.lineIndent >= nodeIndent) {
				hasPendingContent = !0, ch = state.input.charCodeAt(state.position);
				continue;
			} else {
				state.position = captureEnd, state.line = _line, state.lineStart = _lineStart, state.lineIndent = _lineIndent;
				break;
			}
			hasPendingContent &&= (captureSegment(state, captureStart, captureEnd, !1), writeFoldedLines(state, state.line - _line), captureStart = captureEnd = state.position, !1), is_WHITE_SPACE(ch) || (captureEnd = state.position + 1), ch = state.input.charCodeAt(++state.position);
		}
		return captureSegment(state, captureStart, captureEnd, !1), state.result ? !0 : (state.kind = _kind, state.result = _result, !1);
	}
	function readSingleQuotedScalar(state, nodeIndent) {
		var ch = state.input.charCodeAt(state.position), captureStart, captureEnd;
		if (ch !== 39) return !1;
		for (state.kind = "scalar", state.result = "", state.position++, captureStart = captureEnd = state.position; (ch = state.input.charCodeAt(state.position)) !== 0;) if (ch === 39) if (captureSegment(state, captureStart, state.position, !0), ch = state.input.charCodeAt(++state.position), ch === 39) captureStart = state.position, state.position++, captureEnd = state.position;
		else return !0;
		else is_EOL(ch) ? (captureSegment(state, captureStart, captureEnd, !0), writeFoldedLines(state, skipSeparationSpace(state, !1, nodeIndent)), captureStart = captureEnd = state.position) : state.position === state.lineStart && testDocumentSeparator(state) ? throwError(state, "unexpected end of the document within a single quoted scalar") : (state.position++, captureEnd = state.position);
		throwError(state, "unexpected end of the stream within a single quoted scalar");
	}
	function readDoubleQuotedScalar(state, nodeIndent) {
		var captureStart, captureEnd, hexLength, hexResult, tmp, ch = state.input.charCodeAt(state.position);
		if (ch !== 34) return !1;
		for (state.kind = "scalar", state.result = "", state.position++, captureStart = captureEnd = state.position; (ch = state.input.charCodeAt(state.position)) !== 0;) if (ch === 34) return captureSegment(state, captureStart, state.position, !0), state.position++, !0;
		else if (ch === 92) {
			if (captureSegment(state, captureStart, state.position, !0), ch = state.input.charCodeAt(++state.position), is_EOL(ch)) skipSeparationSpace(state, !1, nodeIndent);
			else if (ch < 256 && simpleEscapeCheck[ch]) state.result += simpleEscapeMap[ch], state.position++;
			else if ((tmp = escapedHexLen(ch)) > 0) {
				for (hexLength = tmp, hexResult = 0; hexLength > 0; hexLength--) ch = state.input.charCodeAt(++state.position), (tmp = fromHexCode(ch)) >= 0 ? hexResult = (hexResult << 4) + tmp : throwError(state, "expected hexadecimal character");
				state.result += charFromCodepoint(hexResult), state.position++;
			} else throwError(state, "unknown escape sequence");
			captureStart = captureEnd = state.position;
		} else is_EOL(ch) ? (captureSegment(state, captureStart, captureEnd, !0), writeFoldedLines(state, skipSeparationSpace(state, !1, nodeIndent)), captureStart = captureEnd = state.position) : state.position === state.lineStart && testDocumentSeparator(state) ? throwError(state, "unexpected end of the document within a double quoted scalar") : (state.position++, captureEnd = state.position);
		throwError(state, "unexpected end of the stream within a double quoted scalar");
	}
	function readFlowCollection(state, nodeIndent) {
		var readNext = !0, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch = state.input.charCodeAt(state.position);
		if (ch === 91) terminator = 93, isMapping = !1, _result = [];
		else if (ch === 123) terminator = 125, isMapping = !0, _result = {};
		else return !1;
		for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(++state.position); ch !== 0;) {
			if (skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), ch === terminator) return state.position++, state.tag = _tag, state.anchor = _anchor, state.kind = isMapping ? "mapping" : "sequence", state.result = _result, !0;
			readNext || throwError(state, "missed comma between flow collection entries"), keyTag = keyNode = valueNode = null, isPair = isExplicitPair = !1, ch === 63 && (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) && (isPair = isExplicitPair = !0, state.position++, skipSeparationSpace(state, !0, nodeIndent))), _line = state.line, composeNode(state, nodeIndent, CONTEXT_FLOW_IN, !1, !0), keyTag = state.tag, keyNode = state.result, skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), (isExplicitPair || state.line === _line) && ch === 58 && (isPair = !0, ch = state.input.charCodeAt(++state.position), skipSeparationSpace(state, !0, nodeIndent), composeNode(state, nodeIndent, CONTEXT_FLOW_IN, !1, !0), valueNode = state.result), isMapping ? storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode) : isPair ? _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode)) : _result.push(keyNode), skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), ch === 44 ? (readNext = !0, ch = state.input.charCodeAt(++state.position)) : readNext = !1;
		}
		throwError(state, "unexpected end of the stream within a flow collection");
	}
	function readBlockScalar(state, nodeIndent) {
		var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = !1, detectedIndent = !1, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = !1, tmp, ch = state.input.charCodeAt(state.position);
		if (ch === 124) folding = !1;
		else if (ch === 62) folding = !0;
		else return !1;
		for (state.kind = "scalar", state.result = ""; ch !== 0;) if (ch = state.input.charCodeAt(++state.position), ch === 43 || ch === 45) CHOMPING_CLIP === chomping ? chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP : throwError(state, "repeat of a chomping mode identifier");
		else if ((tmp = fromDecimalCode(ch)) >= 0) tmp === 0 ? throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one") : detectedIndent ? throwError(state, "repeat of an indentation width identifier") : (textIndent = nodeIndent + tmp - 1, detectedIndent = !0);
		else break;
		if (is_WHITE_SPACE(ch)) {
			do
				ch = state.input.charCodeAt(++state.position);
			while (is_WHITE_SPACE(ch));
			if (ch === 35) do
				ch = state.input.charCodeAt(++state.position);
			while (!is_EOL(ch) && ch !== 0);
		}
		for (; ch !== 0;) {
			for (readLineBreak(state), state.lineIndent = 0, ch = state.input.charCodeAt(state.position); (!detectedIndent || state.lineIndent < textIndent) && ch === 32;) state.lineIndent++, ch = state.input.charCodeAt(++state.position);
			if (!detectedIndent && state.lineIndent > textIndent && (textIndent = state.lineIndent), is_EOL(ch)) {
				emptyLines++;
				continue;
			}
			if (state.lineIndent < textIndent) {
				chomping === CHOMPING_KEEP ? state.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines) : chomping === CHOMPING_CLIP && didReadContent && (state.result += "\n");
				break;
			}
			for (folding ? is_WHITE_SPACE(ch) ? (atMoreIndented = !0, state.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines)) : atMoreIndented ? (atMoreIndented = !1, state.result += common$1.repeat("\n", emptyLines + 1)) : emptyLines === 0 ? didReadContent && (state.result += " ") : state.result += common$1.repeat("\n", emptyLines) : state.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines), didReadContent = !0, detectedIndent = !0, emptyLines = 0, captureStart = state.position; !is_EOL(ch) && ch !== 0;) ch = state.input.charCodeAt(++state.position);
			captureSegment(state, captureStart, state.position, !1);
		}
		return !0;
	}
	function readBlockSequence(state, nodeIndent) {
		var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = !1, ch;
		for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(state.position); ch !== 0 && !(ch !== 45 || (following = state.input.charCodeAt(state.position + 1), !is_WS_OR_EOL(following)));) {
			if (detected = !0, state.position++, skipSeparationSpace(state, !0, -1) && state.lineIndent <= nodeIndent) {
				_result.push(null), ch = state.input.charCodeAt(state.position);
				continue;
			}
			if (_line = state.line, composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, !1, !0), _result.push(state.result), skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position), (state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) throwError(state, "bad indentation of a sequence entry");
			else if (state.lineIndent < nodeIndent) break;
		}
		return detected ? (state.tag = _tag, state.anchor = _anchor, state.kind = "sequence", state.result = _result, !0) : !1;
	}
	function readBlockMapping(state, nodeIndent, flowIndent) {
		var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = !1, detected = !1, ch;
		for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(state.position); ch !== 0;) {
			if (following = state.input.charCodeAt(state.position + 1), _line = state.line, _pos = state.position, (ch === 63 || ch === 58) && is_WS_OR_EOL(following)) ch === 63 ? (atExplicitKey && (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null), keyTag = keyNode = valueNode = null), detected = !0, atExplicitKey = !0, allowCompact = !0) : atExplicitKey ? (atExplicitKey = !1, allowCompact = !0) : throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), state.position += 1, ch = following;
			else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, !1, !0)) if (state.line === _line) {
				for (ch = state.input.charCodeAt(state.position); is_WHITE_SPACE(ch);) ch = state.input.charCodeAt(++state.position);
				if (ch === 58) ch = state.input.charCodeAt(++state.position), is_WS_OR_EOL(ch) || throwError(state, "a whitespace character is expected after the key-value separator within a block mapping"), atExplicitKey && (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null), keyTag = keyNode = valueNode = null), detected = !0, atExplicitKey = !1, allowCompact = !1, keyTag = state.tag, keyNode = state.result;
				else if (detected) throwError(state, "can not read an implicit mapping pair; a colon is missed");
				else return state.tag = _tag, state.anchor = _anchor, !0;
			} else if (detected) throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
			else return state.tag = _tag, state.anchor = _anchor, !0;
			else break;
			if ((state.line === _line || state.lineIndent > nodeIndent) && (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, !0, allowCompact) && (atExplicitKey ? keyNode = state.result : valueNode = state.result), atExplicitKey || (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos), keyTag = keyNode = valueNode = null), skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position)), state.lineIndent > nodeIndent && ch !== 0) throwError(state, "bad indentation of a mapping entry");
			else if (state.lineIndent < nodeIndent) break;
		}
		return atExplicitKey && storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null), detected && (state.tag = _tag, state.anchor = _anchor, state.kind = "mapping", state.result = _result), detected;
	}
	function readTagProperty(state) {
		var _position, isVerbatim = !1, isNamed = !1, tagHandle, tagName, ch = state.input.charCodeAt(state.position);
		if (ch !== 33) return !1;
		if (state.tag !== null && throwError(state, "duplication of a tag property"), ch = state.input.charCodeAt(++state.position), ch === 60 ? (isVerbatim = !0, ch = state.input.charCodeAt(++state.position)) : ch === 33 ? (isNamed = !0, tagHandle = "!!", ch = state.input.charCodeAt(++state.position)) : tagHandle = "!", _position = state.position, isVerbatim) {
			do
				ch = state.input.charCodeAt(++state.position);
			while (ch !== 0 && ch !== 62);
			state.position < state.length ? (tagName = state.input.slice(_position, state.position), ch = state.input.charCodeAt(++state.position)) : throwError(state, "unexpected end of the stream within a verbatim tag");
		} else {
			for (; ch !== 0 && !is_WS_OR_EOL(ch);) ch === 33 && (isNamed ? throwError(state, "tag suffix cannot contain exclamation marks") : (tagHandle = state.input.slice(_position - 1, state.position + 1), PATTERN_TAG_HANDLE.test(tagHandle) || throwError(state, "named tag handle cannot contain such characters"), isNamed = !0, _position = state.position + 1)), ch = state.input.charCodeAt(++state.position);
			tagName = state.input.slice(_position, state.position), PATTERN_FLOW_INDICATORS.test(tagName) && throwError(state, "tag suffix cannot contain flow indicator characters");
		}
		return tagName && !PATTERN_TAG_URI.test(tagName) && throwError(state, "tag name cannot contain such characters: " + tagName), isVerbatim ? state.tag = tagName : _hasOwnProperty$1.call(state.tagMap, tagHandle) ? state.tag = state.tagMap[tagHandle] + tagName : tagHandle === "!" ? state.tag = "!" + tagName : tagHandle === "!!" ? state.tag = "tag:yaml.org,2002:" + tagName : throwError(state, "undeclared tag handle \"" + tagHandle + "\""), !0;
	}
	function readAnchorProperty(state) {
		var _position, ch = state.input.charCodeAt(state.position);
		if (ch !== 38) return !1;
		for (state.anchor !== null && throwError(state, "duplication of an anchor property"), ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch);) ch = state.input.charCodeAt(++state.position);
		return state.position === _position && throwError(state, "name of an anchor node must contain at least one character"), state.anchor = state.input.slice(_position, state.position), !0;
	}
	function readAlias(state) {
		var _position, alias, ch = state.input.charCodeAt(state.position);
		if (ch !== 42) return !1;
		for (ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch);) ch = state.input.charCodeAt(++state.position);
		return state.position === _position && throwError(state, "name of an alias node must contain at least one character"), alias = state.input.slice(_position, state.position), _hasOwnProperty$1.call(state.anchorMap, alias) || throwError(state, "unidentified alias \"" + alias + "\""), state.result = state.anchorMap[alias], skipSeparationSpace(state, !0, -1), !0;
	}
	function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
		var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = !1, hasContent = !1, typeIndex, typeQuantity, type, flowIndent, blockIndent;
		if (state.listener !== null && state.listener("open", state), state.tag = null, state.anchor = null, state.kind = null, state.result = null, allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext, allowToSeek && skipSeparationSpace(state, !0, -1) && (atNewLine = !0, state.lineIndent > parentIndent ? indentStatus = 1 : state.lineIndent === parentIndent ? indentStatus = 0 : state.lineIndent < parentIndent && (indentStatus = -1)), indentStatus === 1) for (; readTagProperty(state) || readAnchorProperty(state);) skipSeparationSpace(state, !0, -1) ? (atNewLine = !0, allowBlockCollections = allowBlockStyles, state.lineIndent > parentIndent ? indentStatus = 1 : state.lineIndent === parentIndent ? indentStatus = 0 : state.lineIndent < parentIndent && (indentStatus = -1)) : allowBlockCollections = !1;
		if (allowBlockCollections &&= atNewLine || allowCompact, (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) && (flowIndent = CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext ? parentIndent : parentIndent + 1, blockIndent = state.position - state.lineStart, indentStatus === 1 ? allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent) ? hasContent = !0 : (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent) ? hasContent = !0 : readAlias(state) ? (hasContent = !0, (state.tag !== null || state.anchor !== null) && throwError(state, "alias node should not have any properties")) : readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext) && (hasContent = !0, state.tag === null && (state.tag = "?")), state.anchor !== null && (state.anchorMap[state.anchor] = state.result)) : indentStatus === 0 && (hasContent = allowBlockCollections && readBlockSequence(state, blockIndent))), state.tag !== null && state.tag !== "!") if (state.tag === "?") {
			for (state.result !== null && state.kind !== "scalar" && throwError(state, "unacceptable node kind for !<?> tag; it should be \"scalar\", not \"" + state.kind + "\""), typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) if (type = state.implicitTypes[typeIndex], type.resolve(state.result)) {
				state.result = type.construct(state.result), state.tag = type.tag, state.anchor !== null && (state.anchorMap[state.anchor] = state.result);
				break;
			}
		} else _hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag) ? (type = state.typeMap[state.kind || "fallback"][state.tag], state.result !== null && type.kind !== state.kind && throwError(state, "unacceptable node kind for !<" + state.tag + "> tag; it should be \"" + type.kind + "\", not \"" + state.kind + "\""), type.resolve(state.result) ? (state.result = type.construct(state.result), state.anchor !== null && (state.anchorMap[state.anchor] = state.result)) : throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag")) : throwError(state, "unknown tag !<" + state.tag + ">");
		return state.listener !== null && state.listener("close", state), state.tag !== null || state.anchor !== null || hasContent;
	}
	function readDocument(state) {
		var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = !1, ch;
		for (state.version = null, state.checkLineBreaks = state.legacy, state.tagMap = {}, state.anchorMap = {}; (ch = state.input.charCodeAt(state.position)) !== 0 && (skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position), !(state.lineIndent > 0 || ch !== 37));) {
			for (hasDirectives = !0, ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch);) ch = state.input.charCodeAt(++state.position);
			for (directiveName = state.input.slice(_position, state.position), directiveArgs = [], directiveName.length < 1 && throwError(state, "directive name must not be less than one character in length"); ch !== 0;) {
				for (; is_WHITE_SPACE(ch);) ch = state.input.charCodeAt(++state.position);
				if (ch === 35) {
					do
						ch = state.input.charCodeAt(++state.position);
					while (ch !== 0 && !is_EOL(ch));
					break;
				}
				if (is_EOL(ch)) break;
				for (_position = state.position; ch !== 0 && !is_WS_OR_EOL(ch);) ch = state.input.charCodeAt(++state.position);
				directiveArgs.push(state.input.slice(_position, state.position));
			}
			ch !== 0 && readLineBreak(state), _hasOwnProperty$1.call(directiveHandlers, directiveName) ? directiveHandlers[directiveName](state, directiveName, directiveArgs) : throwWarning(state, "unknown document directive \"" + directiveName + "\"");
		}
		if (skipSeparationSpace(state, !0, -1), state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45 ? (state.position += 3, skipSeparationSpace(state, !0, -1)) : hasDirectives && throwError(state, "directives end mark is expected"), composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, !1, !0), skipSeparationSpace(state, !0, -1), state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position)) && throwWarning(state, "non-ASCII line breaks are interpreted as content"), state.documents.push(state.result), state.position === state.lineStart && testDocumentSeparator(state)) {
			state.input.charCodeAt(state.position) === 46 && (state.position += 3, skipSeparationSpace(state, !0, -1));
			return;
		}
		if (state.position < state.length - 1) throwError(state, "end of the stream or a document separator is expected");
		else return;
	}
	function loadDocuments(input, options) {
		input = String(input), options ||= {}, input.length !== 0 && (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13 && (input += "\n"), input.charCodeAt(0) === 65279 && (input = input.slice(1)));
		var state = new State$1(input, options), nullpos = input.indexOf("\0");
		for (nullpos !== -1 && (state.position = nullpos, throwError(state, "null byte is not allowed in input")), state.input += "\0"; state.input.charCodeAt(state.position) === 32;) state.lineIndent += 1, state.position += 1;
		for (; state.position < state.length - 1;) readDocument(state);
		return state.documents;
	}
	function loadAll(input, iterator, options) {
		typeof iterator == "object" && iterator && options === void 0 && (options = iterator, iterator = null);
		var documents = loadDocuments(input, options);
		if (typeof iterator != "function") return documents;
		for (var index$2 = 0, length = documents.length; index$2 < length; index$2 += 1) iterator(documents[index$2]);
	}
	function load(input, options) {
		var documents = loadDocuments(input, options);
		if (documents.length !== 0) {
			if (documents.length === 1) return documents[0];
			throw new YAMLException$1("expected a single document in the stream, but found more");
		}
	}
	function safeLoadAll(input, iterator, options) {
		return typeof iterator == "object" && iterator && options === void 0 && (options = iterator, iterator = null), loadAll(input, iterator, common$1.extend({ schema: DEFAULT_SAFE_SCHEMA$1 }, options));
	}
	function safeLoad(input, options) {
		return load(input, common$1.extend({ schema: DEFAULT_SAFE_SCHEMA$1 }, options));
	}
	module.exports.loadAll = loadAll, module.exports.load = load, module.exports.safeLoadAll = safeLoadAll, module.exports.safeLoad = safeLoad;
})), require_dumper = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var common = require_common(), YAMLException = require_exception(), DEFAULT_FULL_SCHEMA = require_default_full(), DEFAULT_SAFE_SCHEMA = require_default_safe(), _toString = Object.prototype.toString, _hasOwnProperty = Object.prototype.hasOwnProperty, CHAR_TAB = 9, CHAR_LINE_FEED = 10, CHAR_CARRIAGE_RETURN = 13, CHAR_SPACE = 32, CHAR_EXCLAMATION = 33, CHAR_DOUBLE_QUOTE = 34, CHAR_SHARP = 35, CHAR_PERCENT = 37, CHAR_AMPERSAND = 38, CHAR_SINGLE_QUOTE = 39, CHAR_ASTERISK = 42, CHAR_COMMA = 44, CHAR_MINUS = 45, CHAR_COLON = 58, CHAR_EQUALS = 61, CHAR_GREATER_THAN = 62, CHAR_QUESTION = 63, CHAR_COMMERCIAL_AT = 64, CHAR_LEFT_SQUARE_BRACKET = 91, CHAR_RIGHT_SQUARE_BRACKET = 93, CHAR_GRAVE_ACCENT = 96, CHAR_LEFT_CURLY_BRACKET = 123, CHAR_VERTICAL_LINE = 124, CHAR_RIGHT_CURLY_BRACKET = 125, ESCAPE_SEQUENCES = {};
	ESCAPE_SEQUENCES[0] = "\\0", ESCAPE_SEQUENCES[7] = "\\a", ESCAPE_SEQUENCES[8] = "\\b", ESCAPE_SEQUENCES[9] = "\\t", ESCAPE_SEQUENCES[10] = "\\n", ESCAPE_SEQUENCES[11] = "\\v", ESCAPE_SEQUENCES[12] = "\\f", ESCAPE_SEQUENCES[13] = "\\r", ESCAPE_SEQUENCES[27] = "\\e", ESCAPE_SEQUENCES[34] = "\\\"", ESCAPE_SEQUENCES[92] = "\\\\", ESCAPE_SEQUENCES[133] = "\\N", ESCAPE_SEQUENCES[160] = "\\_", ESCAPE_SEQUENCES[8232] = "\\L", ESCAPE_SEQUENCES[8233] = "\\P";
	var DEPRECATED_BOOLEANS_SYNTAX = [
		"y",
		"Y",
		"yes",
		"Yes",
		"YES",
		"on",
		"On",
		"ON",
		"n",
		"N",
		"no",
		"No",
		"NO",
		"off",
		"Off",
		"OFF"
	];
	function compileStyleMap(schema, map$2) {
		var result, keys$1, index$2, length, tag, style, type;
		if (map$2 === null) return {};
		for (result = {}, keys$1 = Object.keys(map$2), index$2 = 0, length = keys$1.length; index$2 < length; index$2 += 1) tag = keys$1[index$2], style = String(map$2[tag]), tag.slice(0, 2) === "!!" && (tag = "tag:yaml.org,2002:" + tag.slice(2)), type = schema.compiledTypeMap.fallback[tag], type && _hasOwnProperty.call(type.styleAliases, style) && (style = type.styleAliases[style]), result[tag] = style;
		return result;
	}
	function encodeHex(character) {
		var string$2 = character.toString(16).toUpperCase(), handle$1, length;
		if (character <= 255) handle$1 = "x", length = 2;
		else if (character <= 65535) handle$1 = "u", length = 4;
		else if (character <= 4294967295) handle$1 = "U", length = 8;
		else throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
		return "\\" + handle$1 + common.repeat("0", length - string$2.length) + string$2;
	}
	function State(options) {
		this.schema = options.schema || DEFAULT_FULL_SCHEMA, this.indent = Math.max(1, options.indent || 2), this.noArrayIndent = options.noArrayIndent || !1, this.skipInvalid = options.skipInvalid || !1, this.flowLevel = common.isNothing(options.flowLevel) ? -1 : options.flowLevel, this.styleMap = compileStyleMap(this.schema, options.styles || null), this.sortKeys = options.sortKeys || !1, this.lineWidth = options.lineWidth || 80, this.noRefs = options.noRefs || !1, this.noCompatMode = options.noCompatMode || !1, this.condenseFlow = options.condenseFlow || !1, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
	}
	function indentString(string$2, spaces) {
		for (var ind = common.repeat(" ", spaces), position$2 = 0, next = -1, result = "", line, length = string$2.length; position$2 < length;) next = string$2.indexOf("\n", position$2), next === -1 ? (line = string$2.slice(position$2), position$2 = length) : (line = string$2.slice(position$2, next + 1), position$2 = next + 1), line.length && line !== "\n" && (result += ind), result += line;
		return result;
	}
	function generateNextLine(state, level) {
		return "\n" + common.repeat(" ", state.indent * level);
	}
	function testImplicitResolving(state, str) {
		var index$2, length, type;
		for (index$2 = 0, length = state.implicitTypes.length; index$2 < length; index$2 += 1) if (type = state.implicitTypes[index$2], type.resolve(str)) return !0;
		return !1;
	}
	function isWhitespace(c$1) {
		return c$1 === CHAR_SPACE || c$1 === CHAR_TAB;
	}
	function isPrintable(c$1) {
		return 32 <= c$1 && c$1 <= 126 || 161 <= c$1 && c$1 <= 55295 && c$1 !== 8232 && c$1 !== 8233 || 57344 <= c$1 && c$1 <= 65533 && c$1 !== 65279 || 65536 <= c$1 && c$1 <= 1114111;
	}
	function isNsChar(c$1) {
		return isPrintable(c$1) && !isWhitespace(c$1) && c$1 !== 65279 && c$1 !== CHAR_CARRIAGE_RETURN && c$1 !== CHAR_LINE_FEED;
	}
	function isPlainSafe(c$1, prev) {
		return isPrintable(c$1) && c$1 !== 65279 && c$1 !== CHAR_COMMA && c$1 !== CHAR_LEFT_SQUARE_BRACKET && c$1 !== CHAR_RIGHT_SQUARE_BRACKET && c$1 !== CHAR_LEFT_CURLY_BRACKET && c$1 !== CHAR_RIGHT_CURLY_BRACKET && c$1 !== CHAR_COLON && (c$1 !== CHAR_SHARP || prev && isNsChar(prev));
	}
	function isPlainSafeFirst(c$1) {
		return isPrintable(c$1) && c$1 !== 65279 && !isWhitespace(c$1) && c$1 !== CHAR_MINUS && c$1 !== CHAR_QUESTION && c$1 !== CHAR_COLON && c$1 !== CHAR_COMMA && c$1 !== CHAR_LEFT_SQUARE_BRACKET && c$1 !== CHAR_RIGHT_SQUARE_BRACKET && c$1 !== CHAR_LEFT_CURLY_BRACKET && c$1 !== CHAR_RIGHT_CURLY_BRACKET && c$1 !== CHAR_SHARP && c$1 !== CHAR_AMPERSAND && c$1 !== CHAR_ASTERISK && c$1 !== CHAR_EXCLAMATION && c$1 !== CHAR_VERTICAL_LINE && c$1 !== CHAR_EQUALS && c$1 !== CHAR_GREATER_THAN && c$1 !== CHAR_SINGLE_QUOTE && c$1 !== CHAR_DOUBLE_QUOTE && c$1 !== CHAR_PERCENT && c$1 !== CHAR_COMMERCIAL_AT && c$1 !== CHAR_GRAVE_ACCENT;
	}
	function needIndentIndicator(string$2) {
		return /^\n* /.test(string$2);
	}
	var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
	function chooseScalarStyle(string$2, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
		var i$2, char, prev_char, hasLineBreak = !1, hasFoldableLine = !1, shouldTrackWidth = lineWidth !== -1, previousLineBreak = -1, plain = isPlainSafeFirst(string$2.charCodeAt(0)) && !isWhitespace(string$2.charCodeAt(string$2.length - 1));
		if (singleLineOnly) for (i$2 = 0; i$2 < string$2.length; i$2++) {
			if (char = string$2.charCodeAt(i$2), !isPrintable(char)) return STYLE_DOUBLE;
			prev_char = i$2 > 0 ? string$2.charCodeAt(i$2 - 1) : null, plain &&= isPlainSafe(char, prev_char);
		}
		else {
			for (i$2 = 0; i$2 < string$2.length; i$2++) {
				if (char = string$2.charCodeAt(i$2), char === CHAR_LINE_FEED) hasLineBreak = !0, shouldTrackWidth && (hasFoldableLine ||= i$2 - previousLineBreak - 1 > lineWidth && string$2[previousLineBreak + 1] !== " ", previousLineBreak = i$2);
				else if (!isPrintable(char)) return STYLE_DOUBLE;
				prev_char = i$2 > 0 ? string$2.charCodeAt(i$2 - 1) : null, plain &&= isPlainSafe(char, prev_char);
			}
			hasFoldableLine ||= shouldTrackWidth && i$2 - previousLineBreak - 1 > lineWidth && string$2[previousLineBreak + 1] !== " ";
		}
		return !hasLineBreak && !hasFoldableLine ? plain && !testAmbiguousType(string$2) ? STYLE_PLAIN : STYLE_SINGLE : indentPerLevel > 9 && needIndentIndicator(string$2) ? STYLE_DOUBLE : hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
	}
	function writeScalar(state, string$2, level, iskey) {
		state.dump = function() {
			if (string$2.length === 0) return "''";
			if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string$2) !== -1) return "'" + string$2 + "'";
			var indent$1 = state.indent * Math.max(1, level), lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent$1), singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
			function testAmbiguity(string$3) {
				return testImplicitResolving(state, string$3);
			}
			switch (chooseScalarStyle(string$2, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
				case STYLE_PLAIN: return string$2;
				case STYLE_SINGLE: return "'" + string$2.replace(/'/g, "''") + "'";
				case STYLE_LITERAL: return "|" + blockHeader(string$2, state.indent) + dropEndingNewline(indentString(string$2, indent$1));
				case STYLE_FOLDED: return ">" + blockHeader(string$2, state.indent) + dropEndingNewline(indentString(foldString(string$2, lineWidth), indent$1));
				case STYLE_DOUBLE: return "\"" + escapeString(string$2, lineWidth) + "\"";
				default: throw new YAMLException("impossible error: invalid scalar style");
			}
		}();
	}
	function blockHeader(string$2, indentPerLevel) {
		var indentIndicator = needIndentIndicator(string$2) ? String(indentPerLevel) : "", clip = string$2[string$2.length - 1] === "\n";
		return indentIndicator + (clip && (string$2[string$2.length - 2] === "\n" || string$2 === "\n") ? "+" : clip ? "" : "-") + "\n";
	}
	function dropEndingNewline(string$2) {
		return string$2[string$2.length - 1] === "\n" ? string$2.slice(0, -1) : string$2;
	}
	function foldString(string$2, width) {
		for (var lineRe = /(\n+)([^\n]*)/g, result = function() {
			var nextLF = string$2.indexOf("\n");
			return nextLF = nextLF === -1 ? string$2.length : nextLF, lineRe.lastIndex = nextLF, foldLine(string$2.slice(0, nextLF), width);
		}(), prevMoreIndented = string$2[0] === "\n" || string$2[0] === " ", moreIndented, match; match = lineRe.exec(string$2);) {
			var prefix = match[1], line = match[2];
			moreIndented = line[0] === " ", result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width), prevMoreIndented = moreIndented;
		}
		return result;
	}
	function foldLine(line, width) {
		if (line === "" || line[0] === " ") return line;
		for (var breakRe = / [^ ]/g, match, start = 0, end, curr = 0, next = 0, result = ""; match = breakRe.exec(line);) next = match.index, next - start > width && (end = curr > start ? curr : next, result += "\n" + line.slice(start, end), start = end + 1), curr = next;
		return result += "\n", line.length - start > width && curr > start ? result += line.slice(start, curr) + "\n" + line.slice(curr + 1) : result += line.slice(start), result.slice(1);
	}
	function escapeString(string$2) {
		for (var result = "", char, nextChar, escapeSeq, i$2 = 0; i$2 < string$2.length; i$2++) {
			if (char = string$2.charCodeAt(i$2), char >= 55296 && char <= 56319 && (nextChar = string$2.charCodeAt(i$2 + 1), nextChar >= 56320 && nextChar <= 57343)) {
				result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536), i$2++;
				continue;
			}
			escapeSeq = ESCAPE_SEQUENCES[char], result += !escapeSeq && isPrintable(char) ? string$2[i$2] : escapeSeq || encodeHex(char);
		}
		return result;
	}
	function writeFlowSequence(state, level, object) {
		var _result = "", _tag = state.tag, index$2, length;
		for (index$2 = 0, length = object.length; index$2 < length; index$2 += 1) writeNode(state, level, object[index$2], !1, !1) && (index$2 !== 0 && (_result += "," + (state.condenseFlow ? "" : " ")), _result += state.dump);
		state.tag = _tag, state.dump = "[" + _result + "]";
	}
	function writeBlockSequence(state, level, object, compact) {
		var _result = "", _tag = state.tag, index$2, length;
		for (index$2 = 0, length = object.length; index$2 < length; index$2 += 1) writeNode(state, level + 1, object[index$2], !0, !0) && ((!compact || index$2 !== 0) && (_result += generateNextLine(state, level)), state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? _result += "-" : _result += "- ", _result += state.dump);
		state.tag = _tag, state.dump = _result || "[]";
	}
	function writeFlowMapping(state, level, object) {
		var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index$2, length, objectKey, objectValue, pairBuffer;
		for (index$2 = 0, length = objectKeyList.length; index$2 < length; index$2 += 1) pairBuffer = "", index$2 !== 0 && (pairBuffer += ", "), state.condenseFlow && (pairBuffer += "\""), objectKey = objectKeyList[index$2], objectValue = object[objectKey], writeNode(state, level, objectKey, !1, !1) && (state.dump.length > 1024 && (pairBuffer += "? "), pairBuffer += state.dump + (state.condenseFlow ? "\"" : "") + ":" + (state.condenseFlow ? "" : " "), writeNode(state, level, objectValue, !1, !1) && (pairBuffer += state.dump, _result += pairBuffer));
		state.tag = _tag, state.dump = "{" + _result + "}";
	}
	function writeBlockMapping(state, level, object, compact) {
		var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index$2, length, objectKey, objectValue, explicitPair, pairBuffer;
		if (state.sortKeys === !0) objectKeyList.sort();
		else if (typeof state.sortKeys == "function") objectKeyList.sort(state.sortKeys);
		else if (state.sortKeys) throw new YAMLException("sortKeys must be a boolean or a function");
		for (index$2 = 0, length = objectKeyList.length; index$2 < length; index$2 += 1) pairBuffer = "", (!compact || index$2 !== 0) && (pairBuffer += generateNextLine(state, level)), objectKey = objectKeyList[index$2], objectValue = object[objectKey], writeNode(state, level + 1, objectKey, !0, !0, !0) && (explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024, explicitPair && (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? pairBuffer += "?" : pairBuffer += "? "), pairBuffer += state.dump, explicitPair && (pairBuffer += generateNextLine(state, level)), writeNode(state, level + 1, objectValue, !0, explicitPair) && (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? pairBuffer += ":" : pairBuffer += ": ", pairBuffer += state.dump, _result += pairBuffer));
		state.tag = _tag, state.dump = _result || "{}";
	}
	function detectType(state, object, explicit) {
		var _result, typeList = explicit ? state.explicitTypes : state.implicitTypes, index$2, length, type, style;
		for (index$2 = 0, length = typeList.length; index$2 < length; index$2 += 1) if (type = typeList[index$2], (type.instanceOf || type.predicate) && (!type.instanceOf || typeof object == "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
			if (state.tag = explicit ? type.tag : "?", type.represent) {
				if (style = state.styleMap[type.tag] || type.defaultStyle, _toString.call(type.represent) === "[object Function]") _result = type.represent(object, style);
				else if (_hasOwnProperty.call(type.represent, style)) _result = type.represent[style](object, style);
				else throw new YAMLException("!<" + type.tag + "> tag resolver accepts not \"" + style + "\" style");
				state.dump = _result;
			}
			return !0;
		}
		return !1;
	}
	function writeNode(state, level, object, block, compact, iskey) {
		state.tag = null, state.dump = object, detectType(state, object, !1) || detectType(state, object, !0);
		var type = _toString.call(state.dump);
		block &&= state.flowLevel < 0 || state.flowLevel > level;
		var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
		if (objectOrArray && (duplicateIndex = state.duplicates.indexOf(object), duplicate = duplicateIndex !== -1), (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) && (compact = !1), duplicate && state.usedDuplicates[duplicateIndex]) state.dump = "*ref_" + duplicateIndex;
		else {
			if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex] && (state.usedDuplicates[duplicateIndex] = !0), type === "[object Object]") block && Object.keys(state.dump).length !== 0 ? (writeBlockMapping(state, level, state.dump, compact), duplicate && (state.dump = "&ref_" + duplicateIndex + state.dump)) : (writeFlowMapping(state, level, state.dump), duplicate && (state.dump = "&ref_" + duplicateIndex + " " + state.dump));
			else if (type === "[object Array]") {
				var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
				block && state.dump.length !== 0 ? (writeBlockSequence(state, arrayLevel, state.dump, compact), duplicate && (state.dump = "&ref_" + duplicateIndex + state.dump)) : (writeFlowSequence(state, arrayLevel, state.dump), duplicate && (state.dump = "&ref_" + duplicateIndex + " " + state.dump));
			} else if (type === "[object String]") state.tag !== "?" && writeScalar(state, state.dump, level, iskey);
			else {
				if (state.skipInvalid) return !1;
				throw new YAMLException("unacceptable kind of an object to dump " + type);
			}
			state.tag !== null && state.tag !== "?" && (state.dump = "!<" + state.tag + "> " + state.dump);
		}
		return !0;
	}
	function getDuplicateReferences(object, state) {
		var objects = [], duplicatesIndexes = [], index$2, length;
		for (inspectNode(object, objects, duplicatesIndexes), index$2 = 0, length = duplicatesIndexes.length; index$2 < length; index$2 += 1) state.duplicates.push(objects[duplicatesIndexes[index$2]]);
		state.usedDuplicates = Array(length);
	}
	function inspectNode(object, objects, duplicatesIndexes) {
		var objectKeyList, index$2, length;
		if (typeof object == "object" && object) if (index$2 = objects.indexOf(object), index$2 !== -1) duplicatesIndexes.indexOf(index$2) === -1 && duplicatesIndexes.push(index$2);
		else if (objects.push(object), Array.isArray(object)) for (index$2 = 0, length = object.length; index$2 < length; index$2 += 1) inspectNode(object[index$2], objects, duplicatesIndexes);
		else for (objectKeyList = Object.keys(object), index$2 = 0, length = objectKeyList.length; index$2 < length; index$2 += 1) inspectNode(object[objectKeyList[index$2]], objects, duplicatesIndexes);
	}
	function dump(input, options) {
		options ||= {};
		var state = new State(options);
		return state.noRefs || getDuplicateReferences(input, state), writeNode(state, 0, input, !0, !0) ? state.dump + "\n" : "";
	}
	function safeDump(input, options) {
		return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
	}
	module.exports.dump = dump, module.exports.safeDump = safeDump;
})), require_js_yaml$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var loader = require_loader(), dumper = require_dumper();
	function deprecated(name$1) {
		return function() {
			throw Error("Function " + name$1 + " is deprecated and cannot be used.");
		};
	}
	module.exports.Type = require_type(), module.exports.Schema = require_schema(), module.exports.FAILSAFE_SCHEMA = require_failsafe(), module.exports.JSON_SCHEMA = require_json(), module.exports.CORE_SCHEMA = require_core(), module.exports.DEFAULT_SAFE_SCHEMA = require_default_safe(), module.exports.DEFAULT_FULL_SCHEMA = require_default_full(), module.exports.load = loader.load, module.exports.loadAll = loader.loadAll, module.exports.safeLoad = loader.safeLoad, module.exports.safeLoadAll = loader.safeLoadAll, module.exports.dump = dumper.dump, module.exports.safeDump = dumper.safeDump, module.exports.YAMLException = require_exception(), module.exports.MINIMAL_SCHEMA = require_failsafe(), module.exports.SAFE_SCHEMA = require_default_safe(), module.exports.DEFAULT_SCHEMA = require_default_full(), module.exports.scan = deprecated("scan"), module.exports.parse = deprecated("parse"), module.exports.compose = deprecated("compose"), module.exports.addConstructor = deprecated("addConstructor");
})), require_js_yaml = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require_js_yaml$1();
})), require_engines = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var yaml = require_js_yaml(), engines$2 = exports = module.exports;
	engines$2.yaml = {
		parse: yaml.safeLoad.bind(yaml),
		stringify: yaml.safeDump.bind(yaml)
	}, engines$2.json = {
		parse: JSON.parse.bind(JSON),
		stringify: function(obj, options) {
			let opts = Object.assign({
				replacer: null,
				space: 2
			}, options);
			return JSON.stringify(obj, opts.replacer, opts.space);
		}
	}, engines$2.javascript = {
		parse: function parse$2(str, options, wrap$2) {
			try {
				return wrap$2 !== !1 && (str = "(function() {\nreturn " + str.trim() + ";\n}());"), eval(str) || {};
			} catch (err) {
				if (wrap$2 !== !1 && /(unexpected|identifier)/i.test(err.message)) return parse$2(str, options, !1);
				throw SyntaxError(err);
			}
		},
		stringify: function() {
			throw Error("stringifying JavaScript is not supported");
		}
	};
})), require_strip_bom_string = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function(str) {
		return typeof str == "string" && str.charAt(0) === "ï»¿" ? str.slice(1) : str;
	};
})), require_utils = /* @__PURE__ */ __commonJSMin(((exports) => {
	var stripBom = require_strip_bom_string(), typeOf$2 = require_kind_of();
	exports.define = function(obj, key, val) {
		Reflect.defineProperty(obj, key, {
			enumerable: !1,
			configurable: !0,
			writable: !0,
			value: val
		});
	}, exports.isBuffer = function(val) {
		return typeOf$2(val) === "buffer";
	}, exports.isObject = function(val) {
		return typeOf$2(val) === "object";
	}, exports.toBuffer = function(input) {
		return typeof input == "string" ? Buffer.from(input) : input;
	}, exports.toString = function(input) {
		if (exports.isBuffer(input)) return stripBom(String(input));
		if (typeof input != "string") throw TypeError("expected input to be a string or buffer");
		return stripBom(input);
	}, exports.arrayify = function(val) {
		return val ? Array.isArray(val) ? val : [val] : [];
	}, exports.startsWith = function(str, substr, len$1) {
		return typeof len$1 != "number" && (len$1 = substr.length), str.slice(0, len$1) === substr;
	};
})), require_defaults = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var engines$1 = require_engines(), utils$2 = require_utils();
	module.exports = function(options) {
		let opts = Object.assign({}, options);
		return opts.delimiters = utils$2.arrayify(opts.delims || opts.delimiters || "---"), opts.delimiters.length === 1 && opts.delimiters.push(opts.delimiters[0]), opts.language = (opts.language || opts.lang || "yaml").toLowerCase(), opts.engines = Object.assign({}, engines$1, opts.parsers, opts.engines), opts;
	};
})), require_engine = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function(name$1, options) {
		let engine = options.engines[name$1] || options.engines[aliase(name$1)];
		if (engine === void 0) throw Error("gray-matter engine \"" + name$1 + "\" is not registered");
		return typeof engine == "function" && (engine = { parse: engine }), engine;
	};
	function aliase(name$1) {
		switch (name$1.toLowerCase()) {
			case "js":
			case "javascript": return "javascript";
			case "coffee":
			case "coffeescript":
			case "cson": return "coffee";
			case "yaml":
			case "yml": return "yaml";
			default: return name$1;
		}
	}
})), require_stringify = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var typeOf$1 = require_kind_of(), getEngine$1 = require_engine(), defaults$3 = require_defaults();
	module.exports = function(file, data, options) {
		if (data == null && options == null) switch (typeOf$1(file)) {
			case "object":
				data = file.data, options = {};
				break;
			case "string": return file;
			default: throw TypeError("expected file to be a string or object");
		}
		let str = file.content, opts = defaults$3(options);
		if (data == null) {
			if (!opts.data) return file;
			data = opts.data;
		}
		let language$1 = file.language || opts.language, engine = getEngine$1(language$1, opts);
		if (typeof engine.stringify != "function") throw TypeError("expected \"" + language$1 + ".stringify\" to be a function");
		data = Object.assign({}, file.data, data);
		let open = opts.delimiters[0], close = opts.delimiters[1], matter$2 = engine.stringify(data, options).trim(), buf = "";
		return matter$2 !== "{}" && (buf = newline(open) + newline(matter$2) + newline(close)), typeof file.excerpt == "string" && file.excerpt !== "" && str.indexOf(file.excerpt.trim()) === -1 && (buf += newline(file.excerpt) + newline(close)), buf + newline(str);
	};
	function newline(str) {
		return str.slice(-1) === "\n" ? str : str + "\n";
	}
})), require_excerpt = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var defaults$2 = require_defaults();
	module.exports = function(file, options) {
		let opts = defaults$2(options);
		if (file.data ??= {}, typeof opts.excerpt == "function") return opts.excerpt(file, opts);
		let sep = file.data.excerpt_separator || opts.excerpt_separator;
		if (sep == null && (opts.excerpt === !1 || opts.excerpt == null)) return file;
		let delimiter = typeof opts.excerpt == "string" ? opts.excerpt : sep || opts.delimiters[0], idx = file.content.indexOf(delimiter);
		return idx !== -1 && (file.excerpt = file.content.slice(0, idx)), file;
	};
})), require_to_file = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var typeOf = require_kind_of(), stringify$1 = require_stringify(), utils$1 = require_utils();
	module.exports = function(file) {
		return typeOf(file) !== "object" && (file = { content: file }), typeOf(file.data) !== "object" && (file.data = {}), file.contents && file.content == null && (file.content = file.contents), utils$1.define(file, "orig", utils$1.toBuffer(file.content)), utils$1.define(file, "language", file.language || ""), utils$1.define(file, "matter", file.matter || ""), utils$1.define(file, "stringify", function(data, options) {
			return options && options.language && (file.language = options.language), stringify$1(file, data, options);
		}), file.content = utils$1.toString(file.content), file.isEmpty = !1, file.excerpt = "", file;
	};
})), require_parse = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var getEngine = require_engine(), defaults$1 = require_defaults();
	module.exports = function(language$1, str, options) {
		let opts = defaults$1(options), engine = getEngine(language$1, opts);
		if (typeof engine.parse != "function") throw TypeError("expected \"" + language$1 + ".parse\" to be a function");
		return engine.parse(str, opts);
	};
})), require_gray_matter = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var fs = require___vite_browser_external(), sections = require_section_matter(), defaults = require_defaults(), stringify = require_stringify(), excerpt = require_excerpt(), engines = require_engines(), toFile = require_to_file(), parse = require_parse(), utils = require_utils();
	function matter$1(input, options) {
		if (input === "") return {
			data: {},
			content: input,
			excerpt: "",
			orig: input
		};
		let file = toFile(input), cached = matter$1.cache[file.content];
		if (!options) {
			if (cached) return file = Object.assign({}, cached), file.orig = cached.orig, file;
			matter$1.cache[file.content] = file;
		}
		return parseMatter(file, options);
	}
	function parseMatter(file, options) {
		let opts = defaults(options), open = opts.delimiters[0], close = "\n" + opts.delimiters[1], str = file.content;
		opts.language && (file.language = opts.language);
		let openLen = open.length;
		if (!utils.startsWith(str, open, openLen)) return excerpt(file, opts), file;
		if (str.charAt(openLen) === open.slice(-1)) return file;
		str = str.slice(openLen);
		let len$1 = str.length, language$1 = matter$1.language(str, opts);
		language$1.name && (file.language = language$1.name, str = str.slice(language$1.raw.length));
		let closeIndex = str.indexOf(close);
		return closeIndex === -1 && (closeIndex = len$1), file.matter = str.slice(0, closeIndex), file.matter.replace(/^\s*#[^\n]+/gm, "").trim() === "" ? (file.isEmpty = !0, file.empty = file.content, file.data = {}) : file.data = parse(file.language, file.matter, opts), closeIndex === len$1 ? file.content = "" : (file.content = str.slice(closeIndex + close.length), file.content[0] === "\r" && (file.content = file.content.slice(1)), file.content[0] === "\n" && (file.content = file.content.slice(1))), excerpt(file, opts), (opts.sections === !0 || typeof opts.section == "function") && sections(file, opts.section), file;
	}
	matter$1.engines = engines, matter$1.stringify = function(file, data, options) {
		return typeof file == "string" && (file = matter$1(file, options)), stringify(file, data, options);
	}, matter$1.read = function(filepath, options) {
		let file = matter$1(fs.readFileSync(filepath, "utf8"), options);
		return file.path = filepath, file;
	}, matter$1.test = function(str, options) {
		return utils.startsWith(str, defaults(options).delimiters[0]);
	}, matter$1.language = function(str, options) {
		let open = defaults(options).delimiters[0];
		matter$1.test(str) && (str = str.slice(open.length));
		let language$1 = str.slice(0, str.search(/\r?\n/));
		return {
			raw: language$1,
			name: language$1 ? language$1.trim() : ""
		};
	}, matter$1.cache = {}, matter$1.clearCache = function() {
		matter$1.cache = {};
	}, module.exports = matter$1;
})), import_gray_matter = /* @__PURE__ */ __toESM(require_gray_matter(), 1), import_buffer = require_buffer();
function ensureBuffer() {
	typeof globalThis < "u" && globalThis.Buffer === void 0 && (globalThis.Buffer = import_buffer.Buffer);
}
ensureBuffer();
function loadDocs(options) {
	let { modules, contentPath = "" } = options, docs$1 = [];
	for (let path$1 in modules) {
		let { data, content: content$2 } = (0, import_gray_matter.default)(String(modules[path$1] || "")), relativePath = path$1.replace(contentPath, "").replace(".md", ""), slug$1 = relativePath.split("/").map((p$1) => p$1.toLowerCase()).join("/");
		slug$1 === "index" && (slug$1 = ""), docs$1.push({
			slug: `/${slug$1}`,
			path: relativePath,
			content: content$2,
			meta: data
		});
	}
	return docs$1;
}
export { APIResponse, Badge, Button, CTABanner, CTASection, Callout, CodeBlock, CodeComparison, CodeTabs, CodeWindow, Container, DocPage as DocPageComponent, Docs, DocsProvider, FeatureCard, FeatureGrid, FeatureList, FeatureShowcase, Footer, GradientText, Hero, HeroBackground, HeroBadge, Highlight, HomePage, Icon, IconBox, LandingPage, LogoCloud, MarkdownRenderer, NavButton, Navbar, PricingCard, PricingGrid, Section, SectionTitle, StatsSection, TableOfContents, TestimonialCard, TestimonialGrid, TestimonialHighlight, cn, loadDocs };
